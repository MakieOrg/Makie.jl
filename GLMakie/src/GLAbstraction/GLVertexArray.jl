"""
Represents an OpenGL vertex array type.
Can be created from a dict of buffers and an opengl Program.
Keys with the name `indices` will get special treatment and will be used as
the indexbuffer.
"""
mutable struct GLVertexArray
    context::GLContext
    id::GLuint
    buffers::Vector{Symbol} # probably unnecessary, actively used buffers

    function GLVertexArray(context::GLContext, buffernames::Vector{Symbol} = Symbol[])
        gl_switch_context!(context)
        id = glGenVertexArrays()
        vao = new(context, id, buffernames)
        DEBUG[] && finalizer(verify_free, vao)
        return vao
    end
end

function GLVertexArray(bufferdict::Dict{Symbol, GLBuffer}, program::GLProgram, indices)
    gl_switch_context!(program.context)

    # Grab all vertex attribute names that need to be present.
    # This includes attributes generated by OpenGL, like gl_VertexID. Filter those.
    N_attrib = max(0, get_attribute_count(program.id))
    buffernames = [glGetActiveAttrib(program.id, i-1)[1] for i in 1:N_attrib]
    filter!(name -> !startswith(string(name), "gl_"), buffernames)

    # All required vertex buffers must exist
    if !all(name -> haskey(bufferdict, name), buffernames)
        error("Could not construct VertexArray - not all buffers are available. \n  Required: $buffernames\n  Buffers: $bufferdict")
    end

    vao = GLVertexArray(program.context, buffernames)
    bind(vao)

    indices isa GLBuffer && bind(indices)

    for name in buffernames
        buffer = bufferdict[name]
        attribute = string(name)
        bind(buffer)
        attribLocation = get_attribute_location(program.id, attribute)
        if attribLocation != -1
            glVertexAttribPointer(attribLocation, cardinality(buffer), julia2glenum(eltype(buffer)), GL_FALSE, 0, C_NULL)
            glEnableVertexAttribArray(attribLocation)
        else
            # This shouldn't be reachable... If it is, maybe there is something
            # wrong with our glGetActiveAttrib()?
            error("Couldn't find vertex attribute $name in program even though program returned it as a used vertex attribute.")
        end
    end

    unbind(vao)

    return vao
end

using ShaderAbstractions: Buffer

# TODO: do this earlier (::GLTriangleFace) if it's ever used
# function GLVertexArray(program::GLProgram, buffers::Buffer, triangles::AbstractVector{<:GLTriangleFace})
#     gl_switch_context!(program.context)
#     # get the size of the first array, to assert later, that all have the same size
#     id = glGenVertexArrays()
#     glBindVertexArray(id)
#     for property_name in propertynames(buffers)
#         array = getproperty(buffers, property_name)
#         attribute = string(property_name)
#         # TODO: use glVertexAttribDivisor to allow multiples of the longest buffer
#         buffer = GLBuffer(program.context, array)
#         bind(buffer)
#         attribLocation = get_attribute_location(program.id, attribute)
#         if attribLocation == -1
#             error("could not bind attribute $(attribute)")
#         end
#         glVertexAttribPointer(attribLocation, cardinality(buffer), julia2glenum(eltype(buffer)), GL_FALSE, 0, C_NULL)
#         glEnableVertexAttribArray(attribLocation)
#         buffers[attribute] = buffer
#     end
#     glBindVertexArray(0)
#     indices = indexbuffer(triangles)
#     obj = GLVertexArray{typeof(indexes)}(program, id, len, buffers, indices)
#     DEBUG[] && finalizer(verify_free, obj)
#     return obj
# end

function bind(vao::GLVertexArray)
    if vao.id == 0
        error("Binding freed VertexArray")
    end
    return glBindVertexArray(vao.id)
end

unbind(::GLVertexArray) = glBindVertexArray(0)

Base.show(io::IO, vao::GLVertexArray) = print(io, "GLVertexArray $(vao.id)")
function Base.show(io::IO, ::MIME"text/plain", vao::GLVertexArray)
    # show(io, vao.program)
    println(io, "GLVertexArray $(vao.id):")
    print(io, "used buffers: ", vao.buffers)
    return
end
