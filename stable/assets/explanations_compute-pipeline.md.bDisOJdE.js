import{_ as i,c as a,o as t,aA as n}from"./chunks/framework.CCN8p9Vn.js";const E=JSON.parse('{"title":"Compute Pipeline","description":"","frontmatter":{},"headers":[],"relativePath":"explanations/compute-pipeline.md","filePath":"explanations/compute-pipeline.md","lastUpdated":null}'),e={name:"explanations/compute-pipeline.md"};function p(h,s,l,k,d,r){return t(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="Compute-Pipeline" tabindex="-1">Compute Pipeline <a class="header-anchor" href="#Compute-Pipeline" aria-label="Permalink to &quot;Compute Pipeline {#Compute-Pipeline}&quot;">​</a></h1><p>The compute pipeline is Makie&#39;s internal representation of the computations that a plot needs to do. They were previously represented by a loose network of Observables. Those had problems with synchronous updates (e.g. <code>x</code> and <code>y</code> need to update together, before updating <code>xy = Point.(x, y)</code>) and repeated updates which the compute pipeline solves.</p><h2 id="ComputeGraph" tabindex="-1">ComputeGraph <a class="header-anchor" href="#ComputeGraph" aria-label="Permalink to &quot;ComputeGraph {#ComputeGraph}&quot;">​</a></h2><p>The <code>ComputeGraph</code> is the central object of the compute pipeline. It contains nodes that hold data and edges that represent computations. They are both constructed indirectly through the two functions <code>add_input!()</code> and <code>register_computation!()</code>. Here is a brief example of a graph with two inputs that are added together and stored in an output node:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># create a new, empty graph</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ComputeGraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># add inputs</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_input!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_input!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((key, value) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value), graph, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># add computations (edges + output nodes)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register_computation!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputs, changed, cached</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    input1, input2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (input1[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input2[], )</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>The two <code>add_input!()</code> calls create nodes with the names :input1 and :input2, holding the initial values 1 and 2 respectively. The second call also defines a conversion function that is applied to input data before placing it into the graph.</p><p>The <code>register_computation!()</code> call refers to these two nodes by name and defines a computation on them. The result is stored in a new node called :output. The callback function of the computation always takes 3 arguments:</p><ol><li><p><code>inputs::NamedTuple{input_names, Ref}</code> which contains <code>Ref</code>s to the data held by the inputs of the computation. The order always matches the order of the input names given to <code>register_computation!()</code>.</p></li><li><p><code>changed::NamedTuple{input_names, Bool}</code> which contains information on which inputs have changed since the computation was last triggered.</p></li><li><p><code>cached::Union{Nothing, Tuple}</code> which contains the data of the previous output(s) in order, or nothing if no previous output exists.</p></li></ol><p>The output should be either a tuple with equal size to the output names set in <code>register_computations!()</code>, or <code>nothing</code> if the result is the same as the previous.</p><p>Alternatively to <code>register_computation!(f, graph, inputs, outputs)</code> you can also use <code>map!(f, graph, inputs, outputs)</code>. <code>map!()</code> simplifies the structure of the callback function <code>f</code> by passing the inputs directly as arguments, without <code>changed</code> or <code>cached</code>. It also allows you to pass just one symbol as the input and/or output.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ComputeGraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_input!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_input!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((key, value) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value), graph, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">map!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((a, b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b, graph, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">map!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((a, b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ([a, b], [b, a]), graph, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:ab</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:ba</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span></code></pre></div><h2 id="Updating-Data" tabindex="-1">Updating Data <a class="header-anchor" href="#Updating-Data" aria-label="Permalink to &quot;Updating Data {#Updating-Data}&quot;">​</a></h2><p>To update the compute graph at least one of its inputs need to be updated. This is done with the <code>update!()</code> function.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># update both inputs together</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, input1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, input2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Note that these updates will not immediately trigger computations. Instead dependent nodes in the graph will be marked as &quot;dirty&quot;. If data for one of those dirty nodes is requested, all necessary computations will run. This allows the graph to skip redundant and outdated updates. In this example we would trigger the computations by requesting the value of &quot;output&quot;:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][]</span></span></code></pre></div><h2 id="Connecting-multiple-Compute-Graphs" tabindex="-1">Connecting multiple Compute Graphs <a class="header-anchor" href="#Connecting-multiple-Compute-Graphs" aria-label="Permalink to &quot;Connecting multiple Compute Graphs {#Connecting-multiple-Compute-Graphs}&quot;">​</a></h2><p>Two separate compute graphs can be connected by using the output of one graph as the input of another. For that the output of parent graphs needs to be passed to the child graph with <code>add_inputs!(child_graph, name, node_from_parent)</code>.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ComputeGraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_input!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_input!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register_computation!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputs, changed, cached</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    input1, input2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inputs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (input1[] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input2[], )</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ComputeGraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_input!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph2, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, graph[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register_computation!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph2, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (sum,), changed, cached</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum[], )</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph2[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 2 * (1 + 2) = 6</span></span></code></pre></div><p>Note that connecting a node between graphs will disable updating of that node in the child graph. Therefore you can not use <code>update!(graph2, sum = new_value)</code> in the example above. Instead the <code>:sum</code> node is solely updated by the parent graph, in which you can update either <code>:input1</code> or <code>:input2</code> to update <code>:sum</code></p><h2 id="Interfacing-with-Observables" tabindex="-1">Interfacing with Observables <a class="header-anchor" href="#Interfacing-with-Observables" aria-label="Permalink to &quot;Interfacing with Observables {#Interfacing-with-Observables}&quot;">​</a></h2><p>You can use an <code>obs::Observable</code> as an input to a ComputeGraph by passing it to <code>add_input!(graph, name, obs)</code>. This will trigger <code>update!(graph, name = obs[])</code> every time the observable updates.</p><p>You can also generate an observable output for a compute node, either directly by calling <code>ComputePipeline.get_observable!(graph, name)</code> or by having it implicitly generate in a <code>map(f, computed, computed_or_obs...)</code> (or <code>on</code>, <code>onany</code>, <code>lift</code>, <code>@lift</code>) call. This will create or retrieve an observable that mirrors the value of the respective compute node. In order to preserve the &quot;push&quot; nature of observables, this will force the compute graph to resolve immediately when the compute node becomes outdated. As a result the graph becomes less lazy and may run more computations than otherwise necessary.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ComputeGraph</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_input!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_input!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">map!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((a, b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b, graph, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:input2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(println, graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">output)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">update!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, input1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># prints 4</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obs2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ComputePipeline</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_observable!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,24)])])}const g=i(e,[["render",p]]);export{E as __pageData,g as default};
