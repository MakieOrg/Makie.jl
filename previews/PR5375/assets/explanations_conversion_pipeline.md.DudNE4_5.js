import{_ as s,C as n,c as r,o as p,aA as a,j as t,G as i,a as c,w as l}from"./chunks/framework.Cpk485K9.js";const _=JSON.parse('{"title":"Conversion, Transformation and Projection Pipeline","description":"","frontmatter":{},"headers":[],"relativePath":"explanations/conversion_pipeline.md","filePath":"explanations/conversion_pipeline.md","lastUpdated":null}'),d={name:"explanations/conversion_pipeline.md"},h={class:"jldocstring custom-block",open:""};function m(u,e,f,k,g,y){const o=n("Badge");return p(),r("div",null,[e[4]||(e[4]=a('<h1 id="Conversion,-Transformation-and-Projection-Pipeline" tabindex="-1">Conversion, Transformation and Projection Pipeline <a class="header-anchor" href="#Conversion,-Transformation-and-Projection-Pipeline" aria-label="Permalink to &quot;Conversion, Transformation and Projection Pipeline {#Conversion,-Transformation-and-Projection-Pipeline}&quot;">​</a></h1><p>This section describes all the processing stages that are applied to data given to a plot on its way to being displayed.</p><h2 id="Overview" tabindex="-1">Overview <a class="header-anchor" href="#Overview" aria-label="Permalink to &quot;Overview {#Overview}&quot;">​</a></h2><p>The pipeline can be broadly be summarized in 3 parts each with a few steps:</p><ol><li>Conversions which mainly normalize types <ol><li>`expand_dimensions()` adds defaulted/generated data (e.g. x, y in `image()`)</li><li>`dim_convert` processes special types like Units</li><li>`convert_arguments()` normalizes numeric types &amp; data formats</li></ol></li><li>Transformations which transform data on a per-plot basis <ol><li>`transform_func` is a function applied to data</li><li>`model` matrix applies linear transformations</li></ol></li><li>Projections which project data from one coordinate system to another <ol><li>`view` matrix moves data from &quot;world&quot; space to a camera &quot;view/eye&quot; space</li><li>`projection` matrix moves from the camera space to &quot;clip&quot; space</li><li>`viewport` moves &quot;clip&quot; space to &quot;pixel/screen&quot; space</li></ol></li></ol><p>As a <strong>user</strong> you have direct control over the <code>model</code> matrix (1.2) with the <code>scale!()</code>, <code>translate!()</code> and <code>rotate!()</code> functions. You have indirect control over projections (3) with the <code>space</code> attribute. It sets what coordinate system is used as the initial space and adjusts the projections as a result. You also have indirect control over <code>transform_func</code>, which can be set by passing a <code>Transformation()</code> directly to a plot. However it usually inherited and controlled by the <code>Axis</code>.</p><p>As a <strong>developer</strong>, i.e. someone who wants to extend Makie, you can interact with most these steps. Most likely you will extend with <code>convert_arguments()</code> to allow special types to be plotted. But you can also implement more dim_converts, add methods for <code>expand_dimensions()</code>, implement more transform functions or add a camera which produces its own<code>view</code>and<code>projection</code>matrix. Only<code>model</code>and<code>viewport</code>handling as well as the interpretation of<code>space</code> are set.</p><h2 id="Argument-Conversions" tabindex="-1">Argument Conversions <a class="header-anchor" href="#Argument-Conversions" aria-label="Permalink to &quot;Argument Conversions {#Argument-Conversions}&quot;">​</a></h2><p>When calling a plot function, e.g. <code>scatter!(axis_or_scene, args...)</code> a new plot object is constructed. It keeps track of the original input arguments as an Observables in <code>plot.args</code>. Those input arguments are then converted by the conversion pipeline and stored in <code>plot.converted</code>. The pipeline consists of 3 steps as mentioned above:</p><h3 id="Data-Generation" tabindex="-1">Data Generation <a class="header-anchor" href="#Data-Generation" aria-label="Permalink to &quot;Data Generation {#Data-Generation}&quot;">​</a></h3><p>The first step is to generate &quot;missing&quot; data. For example, you can create an image plot with just <code>image(rand(10, 10))</code>. The most general form however also includes a <code>ClosedInterval</code> for the x and y dimensions, declaring the size of the image. This data is generated by <code>expand_dimensions(::Trait, args...)</code> where the <code>Trait = conversion_trait(::PlotType, args...)</code>.</p><h3 id="Special-Type-Processing" tabindex="-1">Special Type Processing <a class="header-anchor" href="#Special-Type-Processing" aria-label="Permalink to &quot;Special Type Processing {#Special-Type-Processing}&quot;">​</a></h3><p>The second step handles special types like <code>Unitful</code> types, <code>Dates</code> types or categorical values which need to be synchronized within the scene. For example, if one plot uses &quot;hours&quot; as unit for its x values other plots need to also use time units for x. If the scale of the unit differs between plots, i.e. one uses hours, the other minutes, then a common unit must be found and the values need to be scaled appropriately. This is what <strong>dim_converts</strong> handles. You can find more documentation on them in the <a href="/previews/PR5375/explanations/dim-converts#Dimension-conversions">Dimension conversions</a> docs.</p><h3 id="Convert-Arguments" tabindex="-1">Convert Arguments <a class="header-anchor" href="#Convert-Arguments" aria-label="Permalink to &quot;Convert Arguments {#Convert-Arguments}&quot;">​</a></h3><p>The last step and main work-horse in the conversion pipeline is the <code>convert_arguments()</code> function. It&#39;s purpose is to convert different data types and layouts into one or a select few formats. For example, any data passed to <code>scatter()</code> is converted to a <code>Vector{Point{D, T}}</code> where <code>D = 2</code> or <code>3</code> and <code>T = Float32</code> or <code>Float64</code>. These conversions can happen based on the plot type or its conversion trait. For <code>scatter()</code> the conversion trait <code>PointBased</code> is used.</p><p><code>convert_arguments()</code> can also accept keyword arguments sourced from plot attributes. For this the attribute needs to be marked with <code>used_attribute(::PlotType) = (names...)</code>. Any name in that list will be removed from the attributes of the final plot and be passed to <code>convert_arguments()</code> instead.</p><p>If you want to plot your own custom types you may want to extend <code>convert_arguments()</code>. Let&#39;s say you have some custom type <code>MySimulation</code> and some function <code>positions(::MySimulation)</code> which returns positions you want to plot when calling <code>scatter(::MySimulation)</code>. In this case you can define</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Makie</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convert_arguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PointBased</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MySimulation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Makie</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">convert_arguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PT, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">positions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sim))</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>to make that possible. You can use the plot type (i.e. <code>Scatter</code>) as the first argument as well.</p><h2 id="pipeline_transformations" tabindex="-1">Transformations <a class="header-anchor" href="#pipeline_transformations" aria-label="Permalink to &quot;Transformations {#pipeline_transformations}&quot;">​</a></h2><p>After conversions have normalized the type and layout of plot data, transformations can now adjust it. They are handled by the <code>Transformation</code> object, which exists both on the plot and scene level in the <code>transformation</code> field. It contains a <code>transform_func</code> which is a function-like object applied to the data, and a <code>model</code> matrix which handles linear transformations of the data.</p><p>The plot <code>Transformation</code> object may inherit from it&#39;s parent scene or plot if it acts in the same <code>space</code>. For <code>transform_func</code> this means using the same function as the parent. For <code>model</code> it means merging the parents <code>model</code> matrix with the local one as <code>plot.model = parent.model * local_model</code>.</p><h3 id="Transformation-Function" tabindex="-1">Transformation Function <a class="header-anchor" href="#Transformation-Function" aria-label="Permalink to &quot;Transformation Function {#Transformation-Function}&quot;">​</a></h3><p>The transformation function or <code>transform_func</code> is part of the <code>Transformation</code> object. It handles non-linear transformations like log transform of a logarithmic axis.</p><p>Each <code>transform_func</code> implements at least</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Makie</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">apply_transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transform_func, arg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VecTypes{N, T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {N, T}</span></span></code></pre></div><p>where the transform function can be represented by any type, not just a <code>Function</code>. That way it can carry auxiliary information that may be important to the transformation. Additionally methods with other <code>arg</code> types such as numbers of <code>Vector</code>s thereof may also be implemented to more efficiently apply the transform_func.</p><p>Typically a transform_func also implements</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Makie</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">inverse_transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transform_func)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Makie</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">apply_transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(transform_func, arg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Rect3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>The inverse allows transforming data back, which is used for example in Axis limits. If a reasonable inverse exists (even if it is incomplete or ambiguous) it should be given by <code>inverse_transform</code>. The other <code>apply_transform</code> method is used in <code>boundingbox()</code> and defaults to transforming the corners of the bounding box. It should be implemented if the default returns wrong results, e.g. with a Polar transform.</p><h3 id="Model-Transformations" tabindex="-1">Model Transformations <a class="header-anchor" href="#Model-Transformations" aria-label="Permalink to &quot;Model Transformations {#Model-Transformations}&quot;">​</a></h3><p>The model matrix takes care of linear transformations of plot data. This includes scaling with <code>scale!()</code>, translations with <code>translate!()</code> and rotations with <code>rotate!()</code>. See the <a href="/previews/PR5375/reference/generic/transformations#transformations_reference_docs">Transformation</a> reference docs for more details.</p><h2 id="Projections" tabindex="-1">Projections <a class="header-anchor" href="#Projections" aria-label="Permalink to &quot;Projections {#Projections}&quot;">​</a></h2><p>Projections are matrix transformations that move data from one coordinate system or &quot;space&quot; to another. The matrices are part of the <code>camera(scene)</code> and managed either by the <code>cameracontrols(scene)</code> or by the parent <code>Block</code>. The plot cannot change these matrices but can control which will be used via the <code>space</code> attribute.</p><h3 id="Camera-Controller" tabindex="-1">Camera Controller <a class="header-anchor" href="#Camera-Controller" aria-label="Permalink to &quot;Camera Controller {#Camera-Controller}&quot;">​</a></h3><p>The camera controller, be that the object in the Scene or the parent Block, generates the <code>view</code> and <code>projection</code> matrices. These matrices are stored in <code>camera(scene)</code> which also combines them into <code>projectionview = projection * view</code>. The <code>view</code> matrix moves plot data from a &quot;world&quot; coordinate system to centered and oriented based on the viewer. This coordinate system is typically called camera, eye or view space. From there the <code>projection</code> matrix may apply perspective projection and scales data to move to &quot;clip&quot; space. This space is a normalized space where everything outside a -1 .. 1 box is clipped. The final projection to pixel or screen space is handled implicitly by the Graphics API or explicitly in CairoMakie based on <code>viewport(scene)</code>. The <code>camera(scene)</code> also holds onto a <code>pixel_space</code> matrix, which transforms pixel space to clip space, the scenes resolution as well as some auxiliary information about the cameras orientation. Note that the camera controller is often referred to as the &quot;camera&quot; because the <code>camera(scene)</code> is just inactive storage.</p><h3 id="Space-Attribute" tabindex="-1">Space Attribute <a class="header-anchor" href="#Space-Attribute" aria-label="Permalink to &quot;Space Attribute {#Space-Attribute}&quot;">​</a></h3><p>The <code>space</code> attribute controls which projection matrices the plot uses. The options refer to the input space, which generally transforms to clip space. The options include:</p><ul><li><p><code>space = :data</code>: Apply the cameras <code>view</code> and <code>projection</code> matrices. (This is usually called world space in Graphics APIs.)</p></li><li><p><code>space = :pixel</code>: Apply the camera <code>pixel_space</code> matrix.</p></li><li><p><code>space = :clip</code>: Apply an identity matrix.</p></li><li><p><code>space = :relative</code>: Apply a constant translation-scale matrix.</p></li></ul><p>Note that all of these act after transformations, i.e. after the <code>model</code> matrix is applied.</p><h3 id="Marker-Space-Attribute" tabindex="-1">Marker Space Attribute <a class="header-anchor" href="#Marker-Space-Attribute" aria-label="Permalink to &quot;Marker Space Attribute {#Marker-Space-Attribute}&quot;">​</a></h3><p>A few plots include a <code>markerspace</code> attribute. For these, the projections above are split into two steps, going from <code>space</code> to <code>markerspace</code> to clip space. The same options as above apply. If needed, some of these matrices may also be inverted (e.g. going from :pixel -&gt; :data -&gt; :clip space).</p><h2 id="Float32Convert" tabindex="-1">Float32Convert <a class="header-anchor" href="#Float32Convert" aria-label="Permalink to &quot;Float32Convert {#Float32Convert}&quot;">​</a></h2><p>The Float32Convert is an optional step that doesn&#39;t fit as cleanly into the pipeline. It&#39;s job is to make sure that the data, projection matrices and model matrix are save to convert to Float32 types and thus can be passed to the graphics API without precision issues.</p><p>Currently only <code>Axis</code> actually defines this transformation. When calling <code>plot!(axis, ...)</code> the <code>data_limits()</code> of the plot are recorded by the Axis and combined with existing limits. The limits eventually trigger a camera update, where the <code>transform_func</code> gets applied. The result gets passed to the <code>Float32Convert</code>, which updates its linear transformation to make the transformed limits Float32-safe. The projection matrices are then derived from the safe limits. At this point the linear transformation of the Float32Convert exists just before <code>view</code>. If possible, it is permuted with <code>model</code> so that the model matrix can processed by the graphics API, i.e. on the GPU.</p><h2 id="pipeline_recipe_projections" tabindex="-1">Projecting in Recipes <a class="header-anchor" href="#pipeline_recipe_projections" aria-label="Permalink to &quot;Projecting in Recipes {#pipeline_recipe_projections}&quot;">​</a></h2><p>As of Makie 0.24.3 the function <code>register_projected_positions!()</code> can be used to project point-like data that exists in a plot.</p>',47)),t("details",h,[t("summary",null,[e[0]||(e[0]=t("a",{id:"Makie.register_projected_positions!",href:"#Makie.register_projected_positions!"},[t("span",{class:"jlbinding"},"Makie.register_projected_positions!")],-1)),e[1]||(e[1]=c()),i(o,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[3]||(e[3]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register_projected_positions!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(plot[, output_type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Point3f]; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Register projected positions for the given plot starting from plot argument space.</p><p>Note that this also generates compute nodes for transformed positions (i.e. with transform_func applied) and float32-converted positions (i.e. with float32convert applied).</p><p>Optionally <code>output_type</code> can be set to control the element type of projected positions. (4D points will not be w-normalized, 1D - 3D points will be. This is to allow clip space clipping to happen elsewhere.)</p><p><strong>Keyword Arguments:</strong></p><ul><li><p><code>input_space = :space</code> sets the input space. Can be <code>:space</code> or <code>:markerspace</code> to refer to those plot attributes or any static space like <code>:data</code>.</p></li><li><p><code>output_space = :pixel</code> sets the output space. Can be <code>:space</code> or <code>:markerspace</code> to refer to those plot attributes or any static space like <code>:pixel</code>.</p></li><li><p><code>input_name = :positions</code> sets the source positions which will be projected.</p></li><li><p><code>output_name = Symbol(output_space, :_, input_name)</code> sets the name of the projected positions.</p></li><li><p><code>apply_transform = input_space === :space</code> controls whether transformations and float32convert are applied.</p></li><li><p><code>apply_transform_func = apply_transform</code> controls whether <code>transform_func</code> is applied.</p></li><li><p><code>apply_float32convert = apply_transform</code> controls whether <code>float32convert</code> is applied.</p></li><li><p><code>apply_model = apply_transform</code> controls whether the <code>model</code> matrix is applied.</p></li><li><p><code>apply_clip_planes = false</code> controls whether points clipped by <code>clip_planes</code> are replaced by NaN. (Does not consider clip space clipping. Only applies if <code>is_data_space(input_space)</code>.)</p></li><li><p><code>yflip = false</code> flips the <code>y</code> coordinate if set to true and <code>output_space = :pixel</code></p></li></ul><p>Related: <a href="/previews/PR5375/api#Makie.register_position_transforms!-Tuple{Plot}"><code>register_position_transforms!</code></a>, <a href="/previews/PR5375/api#Makie.register_positions_transformed!-Tuple{Plot}"><code>register_positions_transformed!</code></a>, <a href="/previews/PR5375/api#Makie.register_positions_transformed_f32c!-Tuple{Plot}"><code>register_positions_transformed_f32c!</code></a>, <a href="/previews/PR5375/api#Makie.register_projected_rotations_2d!-Tuple{Plot}"><code>register_projected_rotations_2d!</code></a></p>',7)),i(o,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2]||(e[2]=[t("a",{href:"https://github.com/MakieOrg/Makie.jl/blob/727dcf0b1d7e3eda0651638bbb88eb869956e379/Makie/src/utilities/projection_utils.jl#L1-L28",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[5]||(e[5]=a(`<p>The most common cases are that you either want to project positions to pixel space, e.g. to mix in attributes that apply in pixel space, or apply the transform_func as it is a potentially non-linear transform.</p><p>To project to pixel space you can simply call <code>register_projected_positions!(plot, input_name = ...)</code>. For this positions need to exist as a compute node and their name needs to be passed as <code>input_name</code>. If your positions are an observable you can add them to the compute graph with <code>Makie.add_input!(plot.attributes, name, observable)</code>. The function will then step through the whole transformation-projection pipeline, applying <code>transform_func</code>, <code>float32convert</code>, <code>model</code> and a <code>plot.space -&gt; :pixel</code> projection matrix. The final output is written to a node with the name <code>Symbol(:pixel_, input_name)</code>, which can be addressed in <code>map!()</code> afterwards. The node is also returned.</p><p>If you just want to apply <code>transform_func</code> you can turn off all the other steps by setting the appropriate keyword arguments.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">register_projected_positions!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    plot, input_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    apply_transform </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># turn off model, transform_func, float32convert</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    apply_transform_func </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># turn transform_func back on</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    output_space </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :space</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # turn off projections</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Alternatively you can also call <code>Makie.register_positions_transformed!(plot, input_name = ..., output_name = ...)</code>.</p>`,5))])}const v=s(d,[["render",m]]);export{_ as __pageData,v as default};
