# Dimension conversions

Starting with Makie v0.21, support for types like units, categorical values and dates has been added.
They are converted to a plottable representation by dim(ensional) converts, which synchronize information between different plots in a scene and generate appropriate ticks for an axis.
In the following sections we will explain their usage and how to extend the interface with your own types.

## Usage Examples

The basic usage is as easy as replacing numbers with any supported type, e.g. `Dates.Second`:

```@figure dimconverts
using Makie.Dates, Makie.Unitful
Makie.inline!(true) # hide

f, ax, pl = scatter(rand(Second(1):Second(60):Second(20*60), 10))
```

Once an axis dimension is set to a certain unit, one must plot into that axis with compatible units.
In this case time units like hours work, since they're compatible with the Unitful conversion:

```@figure dimconverts
scatter!(ax, rand(Hour(1):Hour(1):Hour(20), 10))
# Unitful works as well
scatter!(ax, LinRange(0u"yr", 0.1u"yr", 5))
f
```

Note that the units displayed in ticks are set by first plot.
if you want a different unit of the same scale to be used you have three options.
You can adjust the units in the initial plot, initialize the axis with e.g. `Makie.UnitfulConversion(u"hr")` or change the unit of an existing dimensional conversion manually.
The latter two options are shown later in this section.

Plotting just numbers into the axis errors since the axis is unitful now:

```julia
try
    scatter!(ax, 1:4)
catch e
    return e
end
```

Similarly, trying to plot units into a unitless axis dimension errors too, as otherwise it would alter the meaning of the previous plotted values:

```julia
try
    scatter!(ax, LinRange(0u"yr", 0.1u"yr", 10), rand(Hour(1):Hour(1):Hour(20), 10))
catch e
    return e
end
```

Units can be shown in both axis labels and tick labels.
This can be controlled from the axis:

```@setup dc_axis
using Makie.Unitful
```

```@figure dc_axis
using Makie.Unitful

f,a,p = scatter((0:15:150) .* u"s", (0:1:10).^2 .* u"m")
a.x_unit_in_ticklabel = false
a.x_unit_in_label = true

a.y_unit_in_ticklabel = true
a.y_unit_in_label = false
f
```

You can set the formatter for units in axis labels via `x/ylabel_suffix`.
It accepts either a `Format.jl` compatible String or a function that acts on the suffix generated by the dim convert.
This maybe rich text (e.g. units), strings (e.g. categorical) or LaTeXStrings (unused by Makie).

```@figure dc_axis
a.xlabel_suffix = "unit: ({})"
f
```

Note that is also possible to completely replace the unit by passing a string without a value placeholder (`{}`) here.

Units also support switching to a long representation for axis labels.
This is controlled via

```@figure dc_axis
a.use_short_x_units = false
f
```

The dim converts are kept track of in the (generated) axis.
They can be accessed with `ax.dim1_conversion` and `ax.dim2_conversion`:

```@example dc_axis
(a.dim1_conversion[], a.dim2_conversion[])
```

and in the case of `UnitfulConversion`s their units can be adjusted by setting

```@figure dc_axis
a.dim1_conversion[].unit[] = u"minute"
reset_limits!(a)
f
```

An axis can also be created explicitly with a dimensional conversion by setting those attributes in the constructor:

```@setup dc_axis_construction
using Makie.Unitful
```

```@figure dc_axis_construction
using Makie.Unitful

f = Figure()
ax = Axis(f[1, 1]; dim1_conversion=Makie.UnitfulConversion(u"km"))
scatter!(ax, (1:20).^2 .* u"m", 1:20)
f
```

### Categorical Examples

Categorical values need to be wrapped in `Cateogrical()` when constructing a plot:

```@figure dc_categorical
f,a,p = scatter(Categorical([:A, :D, :F]), 1:3, color = :blue, marker = :circle, markersize = 30)
```

Adding another plot with (partially) different categories will result in the those categories being added to the conversion:

```@figure dc_categorical
scatter!(a, Categorical([:B, :C, :E, :F]), 4:-1:1, color = :orange, marker = :rect, markersize = 30)
f
```

Similar to units, categories need to be of the same type.
Adding a plot with `Categorical(["A", "B"])` would thus error here.
The axis attributes also work with categorical conversions, though axis labels won't show anything as the conversion does not define an output for them.

### Experimental DynamicQuantities.jl support

!!! warning
    This feature might change outside breaking releases, since the API is not yet finalized

Makie also provides support for [DynamicQuantities.jl](https://github.com/SymbolicML/DynamicQuantities.jl). This can used almost as a drop-in replacement for Unitful.jl, with the following key design differences:

* There is no conversion support between Dates.jl and DynamicQuantities.jl objects. Use `1.0u"hr"` in place of `Dates.Hour(1.0)`, `1.0u"d"` in place of `Dates.day(1.0)`, etc.
* Units are displayed in SI be default. Use `us"<desired unit>"` (note the `s`) to explicitly set your desired units, either implicitly in a plot call or explicitly as a `dim_conversion` axis argument.

Below are a few common usage examples to construct the same plot. Please file a bug report if you find an issue with this experimental feature!

```@setup DQ_dimconverts
using DynamicQuantities
```

```@figure DQ_dimconverts
using DynamicQuantities

# Implicitly define figure, axis, and units
f, ax, pl = scatter((100:100:1_000)us"cm")
scatter!(ax, (10:-1:1)u"m")

# Implicitly define axis and units
scatter(f[1, 2], (100:100:1_000)us"cm")
scatter!(f[1, 2], (10:-1:1)u"m")

# Explicitly define axis, implicitly define units
ax3 = Axis(f[2, 1])
scatter!(ax3, (100:100:1_000)us"cm") # The first plot sets the units
scatter!(ax3, (10:-1:1)u"m")

# Explicitly define axis and units
ax4 = Axis(f[2, 2]; dim2_conversion=Makie.DQConversion(us"cm"))
scatter!(ax4, (100:100:1_000)u"cm") # No need for us"cm" now
scatter!(ax4, (10:-1:1)u"m")

f
```

### Limitations


-   For now, dim conversions only work with data that is split by dimension, i.e. separate x and y (and z) values.
-   Only `Axis` and `Axis3` consider dim converts when generating ticks, tick labels and axis labels.
-   Categorical values need to be wrapped in `Categorical`, since it's hard to find a good type that isn't ambiguous when defaulting to a categorical conversion. You can find a work around in the docs.
-   To properly apply dim conversions only when applicable, one needs to use the new undocumented `@recipe` macro and define a conversion target type. This means user recipes only work if they pass through the arguments to any basic plotting type without conversion.
-   Plots like `Heatmap` which use dimensionally separated data `(x, y, matrix)` as their final conversion target need to define their target types in `@recipe` to properly detect when not to apply dim converts. Otherwise Makie will fail to detect cases where dim converts should not apply, e.g. when `Heatmap` is used within a recipe that has already resolved dim converts.

### Current conversions in Makie

```@docs
Makie.CategoricalConversion
Makie.UnitfulConversion
Makie.DQConversion
Makie.DateTimeConversion
```

## Developer docs

### Recipe Interface

To apply dim converts to a recipe, its arguments must be matched to dimensions.
This is done using the `argument_dims()` function which works similar to `convert_arguments()`.
It can be defined per plot type or conversion trait, takes a set of arguments and returns the respective dimensions.
Any plot with 2 or 3 arguments will default to dimensions (1, 2) or (1, 2, 3) if the data isn't point-like and no specialized method is defined.
Plots with more or less arguments require `argument_dims()` methods to apply dim converts.

Arrows is one such example.
Here are the methods implemented for `ArrowLike`, the conversion trait for `Arrows2D` and `Arrows3d`:

```julia
# Mark arrows with 2 arguments, i.e. point-like data as not dim-convertible.
# This is not required - it would otherwise be be marked invalid by the default
# path
Makie.argument_dims(::ArrowLike, xy, uv) = nothing

# Arrows can be called with a function that generates directions from positions.
# For the 2D case this declares the first two arguments as matching dimensions
# (1, 2). The last argument is not dimensional and can either be omitted or set
# to 0.
Makie.argument_dims(::ArrowLike, x, y, f) = (1, 2)
# In the 3D case the first 3 arguments map to dimensions (1, 2, 3)
Makie.argument_dims(::ArrowLike, x, y, z, f::Function) = (1, 2, 3)

# These methods deal with arrows calls with positional and directional arrays.
# (x, u) act in dimension 1, (y, v) in dimension 2 and (z, w) in dimension 3.
Makie.argument_dims(::ArrowLike, x, y, u, v) = (1, 2, 1, 2)
Makie.argument_dims(::ArrowLike, x, y, z, u, v, w) = (1, 2, 3, 1, 2, 3)
```

Like `convert_argument()`, `argument_dims()` can also include attributes.
For this `argument_dim_kwargs()` needs to be defined for the relevant plot type,
returning the relevant attribute names.
`band` for example uses:

```julia
# Mark `direction` as an attribute that needs to be included
Makie.argument_dim_kwargs(::Type{<:Band}) = (:direction, )

# The 3 argument version of band is convertible. Depending on `direction`
# the arguments may swap which direction they act in.
function Makie.argument_dims(::Type{<:Band}, x, ylower, yupper; direction)
    return direction === :x ? (1, 2, 2) : (2, 1, 1)
end
```

Given how frequent `direction` and `orientation` are as attributes, they are also handled by the default path in 2D.
With `argument_dim_kwargs()` defined, the default path flips dimensions if `direction != :y` or `orientation != :vertical`.

### Creating a new dim convert

You can extend the API to define your own dim converts by overloading the following functions:

```@figure dimconverts
# The type you target with the dim conversion
struct MyUnit
    value::Float64
end

# Required

# The Conversion that resolves your type to something numeric
struct MyDimConversion <: Makie.AbstractDimConversion end

# Creates the Conversion based on the element type used in plot data.
# The Type gets extracted via `Makie.get_element_type(plot_argument_for_dim_n)`
# so e.g. `plot(1:10, ["a", "b", "c"])` would call
# `Makie.get_element_type(["a", "b", "c"])` and return `String` for axis dim 2.
# The result is then used to call `create_dim_conversion(String)`
Makie.create_dim_conversion(::Type{MyUnit}) = MyDimConversion()

# Applies the conversion to plot data.
# This is called whenever plot data or the dim_convert changes.
# `attr` is the ComputeGraph of the plot. It can be used to cache results or
# identify the plot by `objectid(attr)`.
# `prev_values` contains the last result of the conversion, or nothing if this
# is the first call
function Makie.convert_dim_value(conversion::MyDimConversion, attr, values, prev_values)
    return Makie.convert_dim_value(conversion, values)
end

# The non observable version of the dim_convert.
# This is needed to convert axis limits, and should be a pure version of the
# `convert_dim_observable` method above
function Makie.convert_dim_value(::MyDimConversion, values)
    return [v.value for v in values]
end

# Generates ticks for the axis when using a dim convert.
# This function applies per dimension.
# `ticks` are ticks set directly by the user through `ax.xticks` etc
# `scale` is the x/y/zscale function of the axis (e.g. log10)
# `formatter` is the x/y/ztickformat of the axis
# `limits_min, limits_max` are the limits of the axis dimension, after applying
#   dim converts
# `show_units::Bool` sets whether units should be shown in ticklabels
function Makie.get_ticks(
        ::MyDimConversion, ticks, scale, formatter,
        limits_min, limits_max, show_units
    )
    # Don't do anything special to ticks for this example, just append `myunit`
    # to the labels and leave the rest to Makie's usual tick finding methods.
    ticknumbers, ticklabels = Makie.get_ticks(
        ticks, scale, formatter, limits_min, limits_max
    )
    if show_units
        ticklabels = ticklabels .* "myunit"
    end
    return ticknumbers, ticklabels
end

# Optional

# This is currently needed because `expand_dimensions` can only be narrowly
# defined for `Vector{<:Real}` in Makie. So, if you want to make
# `plot(some_y_values)` work for your own types, you need to define this method:
function Makie.expand_dimensions(::PointBased, y::AbstractVector{<:MyUnit})
    return keys(y.values), y
end

# This function should return an Observable which acts as an update trigger for
# axis ticks and labels. For example, UnitfulConversion returns the unit
# observable here to trigger updates when the unit changes.
Makie.needs_tick_update_observable(conversion::MyDimConversion) = nothing

# Handles the resolution of `ax.x/y/z_unit_in_ticklabel = automatic`.
# The result is passed to `get_ticks(..., show_unit)`.
Makie.show_dim_convert_in_ticklabel(::MyDimConversion, ::Makie.Automatic) = true

# Handles the resolution of `ax.x/y/z_unit_in_label = automatic`.
Makie.show_dim_convert_in_axis_label(::MyDimConversion, ::Makie.Automatic) = true

# Generates axis labels for the conversion.
# This is called when `x/y/z_unit_in_label` resolves to true, and defaults to
# an error when not implemented.
# `format` contains the content of x/y/zlabel_suffix
# `use_short_units` is a bool for switching to a long representation of a unit
function Makie.get_label_suffix(::MyDimConversion, format, use_short_units)
    # Here we just use "my unit" as the unit string for the label and apply
    # the passed formatter.
    return Makie.apply_format("my unit", format)
end

barplot([MyUnit(1), MyUnit(2), MyUnit(3)], 1:3)
```

For more complex examples, you should look at the implementation in:
`Makie/src/dim-converts`.

### Early Conversions

`convert_arguments()` is also applied before dim converts.
This can be helpful to reduce the number of types that need to be handled in `convert_dim_value()`.
For example `streamplot` implements:

```julia
function Makie.convert_arguments(
        ::Type{<:StreamPlot}, f::Function,
        xrange::Makie.RangeLike, yrange::Makie.RangeLike
    )
    return (f, extrema(xrange), extrema(yrange))
end

function Makie.convert_arguments(
        ::Type{<:StreamPlot}, f::Function,
        xrange::Makie.RangeLike, yrange::Makie.RangeLike, zrange::Makie.RangeLike
    )
    return (f, extrema(xrange), extrema(yrange), extrema(zrange))
end
```

These methods act on untyped `AbstractVector`, `Tuple` and `ClosedInterval` arguments and convert them to a `(min, max)` tuples.
This means that `convert_dim_value()` will only be called with `(min, max)` tuples.
