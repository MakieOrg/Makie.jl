# Dimension conversions

Starting with Makie v0.21, support for types like units, categorical values and dates has been added.
They are converted to a plottable representation by dim(ensional) converts, which synchronize information between different plots in a scene and generate appropriate ticks for an axis.
In the following sections we will explain their usage and how to extend the interface with your own types.

## Usage Examples

The basic usage is as easy as replacing numbers with any supported type, e.g. `Dates.Second`:

```@figure dimconverts
using Makie.Dates, Makie.Unitful
Makie.inline!(true) # hide

f, ax, pl = scatter(rand(Second(1):Second(60):Second(20*60), 10))
```

Once an axis dimension is set to a certain unit, one must plot into that axis with compatible units.
In this case time units like hours work, since they're compatible with the Unitful conversion:

```@figure dimconverts
scatter!(ax, rand(Hour(1):Hour(1):Hour(20), 10))
# Unitful works as well
scatter!(ax, LinRange(0u"yr", 0.1u"yr", 5))
f
```

Note that the units displayed in ticks are set by first plot.
if you want a different unit of the same scale to be used you have three options.
You can adjust the units in the initial plot, initialize the axis with e.g. `Makie.UnitfulConversion(u"hr")` or change the unit of an existing dimensional conversion manually.
The latter two options are shown later in this section.

Plotting just numbers into the axis errors since the axis is unitful now:

```julia
try
    scatter!(ax, 1:4)
catch e
    return e
end
```

Similarly, trying to plot units into a unitless axis dimension errors too, as otherwise it would alter the meaning of the previous plotted values:

```julia
try
    scatter!(ax, LinRange(0u"yr", 0.1u"yr", 10), rand(Hour(1):Hour(1):Hour(20), 10))
catch e
    return e
end
```

Units can be shown in both axis labels and tick labels.
This can be controlled from the axis:

```@setup dc_axis
using Makie.Unitful
```

```@figure dc_axis
using Makie.Unitful

f,a,p = scatter((0:15:150) .* u"s", (0:1:10).^2 .* u"m")
a.x_unit_in_ticklabel = false
a.x_unit_in_label = true

a.y_unit_in_ticklabel = true
a.y_unit_in_label = false
f
```

You can set the formatter for units in axis labels via `x/ylabel_suffix`.
It accepts either a `Format.jl` compatible String or a function that acts on the suffix generated by the dim convert.
This maybe rich text (e.g. units), strings (e.g. categorical) or LaTeXStrings (unused by Makie).

```@figure dc_axis
a.xlabel_suffix = "unit: ({})"
f
```

Note that is also possible to completely replace the unit by passing a string without a value placeholder (`{}`) here.

Units also support switching to a long representation for axis labels.
This is controlled via

```@figure dc_axis
a.use_short_x_units = false
f
```

The dim converts are kept track of in the (generated) axis.
They can be accessed with `ax.dim1_conversion` and `ax.dim2_conversion`:

```@example dc_axis
(a.dim1_conversion[], a.dim2_conversion[])
```

and in the case of `UnitfulConversion`s their units can be adjusted by setting

```@figure dc_axis
a.dim1_conversion[].unit[] = u"minute"
reset_limits!(a)
f
```

An axis can also be created explicitly with a dimensional conversion by setting those attributes in the constructor:

```@setup dc_axis_construction
using Makie.Unitful
```

```@figure dc_axis_construction
using Makie.Unitful

f = Figure()
ax = Axis(f[1, 1]; dim1_conversion=Makie.UnitfulConversion(u"km"))
scatter!(ax, (1:20).^2 .* u"m", 1:20)
f
```

### Categorical Examples

Categorical values need to be wrapped in `Cateogrical()` when constructing a plot:

```@figure dc_categorical
f,a,p = scatter(Categorical([:A, :D, :F]), 1:3, color = :blue, marker = :circle, markersize = 30)
```

Adding another plot with (partially) different categories will result in the those categories being added to the conversion:

```@figure dc_categorical
scatter!(a, Categorical([:B, :C, :E, :F]), 4:-1:1, color = :orange, marker = :rect, markersize = 30)
f
```

Similar to units, categories need to be of the same type.
Adding a plot with `Categorical(["A", "B"])` would thus error here.
The axis attributes also work with categorical conversions, though axis labels won't show anything as the conversion does not define an output for them.

### Experimental DynamicQuantities.jl support

!!! warning
    This feature might change outside breaking releases, since the API is not yet finalized

Makie also provides support for [DynamicQuantities.jl](https://github.com/SymbolicML/DynamicQuantities.jl). This can used almost as a drop-in replacement for Unitful.jl, with the following key design differences:

* There is no conversion support between Dates.jl and DynamicQuantities.jl objects. Use `1.0u"hr"` in place of `Dates.Hour(1.0)`, `1.0u"d"` in place of `Dates.day(1.0)`, etc.
* Units are displayed in SI be default. Use `us"<desired unit>"` (note the `s`) to explicitly set your desired units, either implicitly in a plot call or explicitly as a `dim_conversion` axis argument.

Below are a few common usage examples to construct the same plot. Please file a bug report if you find an issue with this experimental feature!

```@setup DQ_dimconverts
using DynamicQuantities
```

```@figure DQ_dimconverts
using DynamicQuantities

# Implicitly define figure, axis, and units
f, ax, pl = scatter((100:100:1_000)us"cm")
scatter!(ax, (10:-1:1)u"m")

# Implicitly define axis and units
scatter(f[1, 2], (100:100:1_000)us"cm")
scatter!(f[1, 2], (10:-1:1)u"m")

# Explicitly define axis, implicitly define units
ax3 = Axis(f[2, 1])
scatter!(ax3, (100:100:1_000)us"cm") # The first plot sets the units
scatter!(ax3, (10:-1:1)u"m")

# Explicitly define axis and units
ax4 = Axis(f[2, 2]; dim2_conversion=Makie.DQConversion(us"cm"))
scatter!(ax4, (100:100:1_000)u"cm") # No need for us"cm" now
scatter!(ax4, (10:-1:1)u"m")

f
```

### Limitations


-   For now, dim conversions only work with data that is split by dimension, i.e. separate x and y (and z) values.
-   Only `Axis` and `Axis3` consider dim converts when generating ticks, tick labels and axis labels.
-   Categorical values need to be wrapped in `Categorical`, since it's hard to find a good type that isn't ambiguous when defaulting to a categorical conversion. You can find a work around in the docs.
-   To properly apply dim conversions only when applicable, one needs to use the new undocumented `@recipe` macro and define a conversion target type. This means user recipes only work if they pass through the arguments to any basic plotting type without conversion.
-   Plots like `Heatmap` which use dimensionally separated data `(x, y, matrix)` as their final conversion target need to define their target types in `@recipe` to properly detect when not to apply dim converts. Otherwise Makie will fail to detect cases where dim converts should not apply, e.g. when `Heatmap` is used within a recipe that has already resolved dim converts.

### Current conversions in Makie

```@docs
Makie.CategoricalConversion
Makie.UnitfulConversion
Makie.DQConversion
Makie.DateTimeConversion
```

## Developer docs

### Overview

When building a plot a few conditions are evaluated to decide whether a plot applies dim converts or not.
They are given in two layers.
The first layer checks the state of the plot and conversion: (This is an if, elseif, ... pattern.)
1. If a plot is not in data space it does not apply dim converts.
2. If the plot has `force_dimconverts == true` which means it plots to a scene rather than another plot (unless set explicitly), and dim converts are already fixed by the parent they are applied.
3. If `convert_arguments()` reached the final conversion target or if it returned a SpecApi type then dim converts are not applied.
4. If `convert_arguments()`  did not reach the final conversion target or if it is unknown, then dim_converts do apply. If applying `convert_arguments()` resulted in a change they are applied before applying dim converts

If the first layer decides to apply dim converts we move to the second.
Here we check `argument_dims()` with partially converted or raw arguments.
If it returns `nothing` we assume dim converts can not be applied and continue without.
Otherwise dim converts get initialized via `update_dim_conversion!()`, added to the plot and included in the conversion pipeline using `convert_dim_value!()`.

### Target Conversion Types / Target Recipe Types

In order for `convert_arguments()` to reach the final conversion target (i.e. hit case 3.) that type needs to be defined.
This can be done when creating a recipe for a plot type or for its conversion trait (lower priority):

```julia
# Sets the target type of convert_arguments() for a plot type.
# This doesn't need to be a concrete type and can be a Union of types
@recipe MyPlot (converted1::TargetType1, converted2::TargetType2) begin
    ...
end

# Sets the target type for a conversion trait.
# This must be a Tuple type
Makie.type_for_plot_arguments(::ConversionTrait) = Tuple{TargetType1, TargetType2}
```

### Partial Conversions

`convert_arguments()` is allowed to act on arguments before dim converts.
Whether a method is used or not depends on its types.

```julia
# These can match arrays before dim conversion and thus apply
Makie.convert_arguments(::MyConversionTrait, data::AbstractVector) = ...
Makie.convert_arguments(::Type{<:MyPlot}, data::AbstractVector) = ...

# These are only defined for numerical data as is present after dim converts.
# They will not apply before them.
Makie.convert_arguments(::MyConversionTrait, data::AbstractVector{<:Real}) = ...
Makie.convert_arguments(::MyConversionTrait, data::AbstractVector{<:VecTypes}) = ...
Makie.convert_arguments(::Type{<:MyPlot}, data::AbstractVector{<:Real}) = ...
Makie.convert_arguments(::Type{<:MyPlot}, data::AbstractVector{<:VecTypes}) = ...
```

### Argument Dims

The `argument_dims(::PlotTypeOrTrait, args...; kwargs...)` function declares how plot arguments map to to dimensions for which dim converts are defined.
The arguments may be partially converted by `convert_arguments()` methods that apply before dim converts.
They can include plot attributes as keyword arguments by defining `argument_dim_kwargs(::PlotTypeOrTrait) = (:attribute1, :attribute2, ...)`.

```julia
# For MyPlot with 4 arguments, args[1] and args[3] act in dimension 1,
# and args[2] and args[4] act in dimension 2
Makie.argument_dims(::Type{<:MyPlot}, x, y, dx, dy) = (1, 2, 1, 2)

# Plots with MyConversionTrait have an attribute `direction` which
# swaps the which dimension arguments apply to
Makie.argument_dim_kwargs(::MyConversionTrait) = (:direction,)
function Makie.argument_dims(::MyConversionTrait, x, y; direction)
    return direction === :y ? (1, 2) : (2, 1)
end

# MyPlot2 has a 4 argument version where the first and last argument
# do not relate to a dimension
# (0 means no dimension and trailing 0s can be omited)
function Makie.argument_dims(::MyPlot2, f, x, y, color_data)
    return (0, 1, 2)
end

# VecTypes (Points, Tuples, ...) can be handled with "inner" dimensions:
function Makie.argument_dims(
        ::MyPlot,
        xy::AbstractVector{VecTypes{N}},
        dxy::AbstractVector{VecTypes{N}}
    ) where {N}
    # can also use ntuple(identity, N) instead of 1:N
    return (1:N, 1:N)
end

# These arguments should never be dim converted
Makie.argument_dims(::MyPlot, unconvertable) = nothing
```

Note that `argument_dims` handle `x, y`, `x, y, z` vectors as well as their point-like representations automatically.
These cases also treat `direction` and `orientation` automatically if included via `argument_dim_kwargs()`.
For this `direction == :y` and `orientation = :vertical` are treated as the neutral (no swap) case.

### Creating a new dim convert

You can extend the dim convert API to define your own by overloading the following functions:

```@figure dimconverts
# The type you target with the dim conversion
struct MyUnit
    value::Float64
end

# Required

# A struct representing the Conversion that resolves your type to something numeric
struct MyDimConversion <: Makie.AbstractDimConversion end

# Creates the Conversion based on the element type used in plot data.
# The Type gets extracted via `Makie.get_element_type(plot_argument_for_dim_n)`
# so e.g. `plot(1:10, ["a", "b", "c"])` would call
# `Makie.get_element_type(["a", "b", "c"])` and return `String` for axis dim 2.
# The result is then used to call `create_dim_conversion(String)`
Makie.create_dim_conversion(::Type{MyUnit}) = MyDimConversion()

# Applies the conversion to plot data.
# This is called whenever plot data or the dim_convert changes.
# `attr` is the ComputeGraph of the plot. It can be used to cache results or
# identify the plot by `objectid(attr)`.
# `prev_values` contains the last result of the conversion, or nothing if this
# is the first call
function Makie.convert_dim_value(conversion::MyDimConversion, attr, values, prev_values)
    return Makie.convert_dim_value(conversion, values)
end

# The non observable version of the dim_convert.
# This is needed to convert axis limits, and should be a pure version of the
# `convert_dim_observable` method above
function Makie.convert_dim_value(::MyDimConversion, values)
    return [v.value for v in values]
end

# Generates ticks for the axis when using a dim convert.
# This function applies per dimension.
# `ticks` are ticks set directly by the user through `ax.xticks` etc
# `scale` is the x/y/zscale function of the axis (e.g. log10)
# `formatter` is the x/y/ztickformat of the axis
# `limits_min, limits_max` are the limits of the axis dimension, after applying
#   dim converts
# `show_units::Bool` sets whether units should be shown in ticklabels
function Makie.get_ticks(
        ::MyDimConversion, ticks, scale, formatter,
        limits_min, limits_max, show_units
    )
    # Don't do anything special to ticks for this example, just append `myunit`
    # to the labels and leave the rest to Makie's usual tick finding methods.
    ticknumbers, ticklabels = Makie.get_ticks(
        ticks, scale, formatter, limits_min, limits_max
    )
    if show_units
        ticklabels = ticklabels .* "myunit"
    end
    return ticknumbers, ticklabels
end

# Optional

# This is currently needed because `expand_dimensions` can only be narrowly
# defined for `Vector{<:Real}` in Makie. So, if you want to make
# `plot(some_y_values)` work for your own types, you need to define this method:
function Makie.expand_dimensions(::PointBased, y::AbstractVector{<:MyUnit})
    return keys(y.values), y
end

# This function should return an Observable which acts as an update trigger for
# axis ticks and labels. For example, UnitfulConversion returns the unit
# observable here to trigger updates when the unit changes.
Makie.needs_tick_update_observable(conversion::MyDimConversion) = nothing

# Handles the resolution of `ax.x/y/z_unit_in_ticklabel = automatic`.
# The result is passed to `get_ticks(..., show_unit)`.
Makie.show_dim_convert_in_ticklabel(::MyDimConversion) = true

# Handles the resolution of `ax.x/y/z_unit_in_label = automatic`.
Makie.show_dim_convert_in_axis_label(::MyDimConversion) = true

# Generates axis labels for the conversion.
# This is called when `x/y/z_unit_in_label` resolves to true, and defaults to
# an error when not implemented.
# `format` contains the content of x/y/zlabel_suffix
# `use_short_units` is a bool for switching to a long representation of a unit
function Makie.get_label_suffix(::MyDimConversion, format, use_short_units)
    # Here we just use "my unit" as the unit string for the label and apply
    # the passed formatter.
    return Makie.apply_format("my unit", format)
end

barplot([MyUnit(1), MyUnit(2), MyUnit(3)], 1:3)
```

For more complex examples, you should look at the implementation in:
`Makie/src/dim-converts`.
