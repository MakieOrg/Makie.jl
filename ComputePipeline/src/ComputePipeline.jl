module ComputePipeline

using Observables

using Base: RefValue

abstract type AbstractEdge end

#=
TODO, use this for Ref{NamedTuple} ?
@generated function _setindex(nt::T, value, field::Symbol)::T where {T<:NamedTuple}
    names = Base.fieldnames(T)
    result = Expr(:tuple)
    for name in names
        qn = QuoteNode(name)
        expr = Expr(:(=), name, :(($(qn) === field ? value : getfield(nt, $(qn)))::fieldtype(T, $(qn))))
        push!(result.args, expr)
    end
    return result
end
=#

"""
    struct Computed

A `Computed` represents a node in the `ComputeGraph`. It should not be created
directly but be generated by [`add_input!`](@ref) or [`register_computation!`](@ref).

A `Computed` can be accessed from the graph by `graph[:name]` where `:name` is
the name the node was created with. Its value is returned by `graph[:name][]`
which also runs any pending updates.
"""
mutable struct Computed
    name::Symbol
    # if a parent edge got resolved and updated this computed, dirty is temporarily true
    # so that the edges dependents can update their inputs accordingly
    dirty::Bool

    value::RefValue
    parent::AbstractEdge
    parent_idx::Int # index of parent.outputs this value refers to
    Computed(name) = new(name, false)
    Computed(name, value::RefValue) = new(name, false, value)
    function Computed(name, value::RefValue, parent::AbstractEdge, idx::Integer)
        return new(name, false, value, parent, idx)
    end
    function Computed(name, edge::AbstractEdge, idx::Integer)
        p = new(name, false)
        p.parent = edge
        p.parent_idx = idx
        return p
    end
end

hasparent(computed::Computed) = isdefined(computed, :parent)
getparent(computed::Computed) = hasparent(computed) ? computed.parent : nothing

struct ResolveException{E <: Exception} <: Exception
    start::Computed
    error::E
end

struct TypedEdge{InputTuple,OutputTuple,F}
    callback::F
    inputs::InputTuple
    inputs_dirty::Vector{Bool}
    outputs::OutputTuple
    output_nodes::Vector{Computed}
end

"""
    struct ComputeEdge

A `ComputeEdge` represents the computation connecting one set of nodes to another.
They are considered internal and should not be interacted with or created directly.
"""
struct ComputeEdge <: AbstractEdge
    callback::Function

    inputs::Vector{Computed}
    inputs_dirty::Vector{Bool}

    outputs::Vector{Computed}
    got_resolved::RefValue{Bool}

    # edges, that rely on outputs from this edge
    # Mainly needed for mark_dirty!(edge) to propagate to all dependents
    dependents::Vector{ComputeEdge}
    typed_edge::RefValue{TypedEdge}
end

function ComputeEdge(f, input, output)
    return ComputeEdge(
        f, [input], [true], [output], RefValue(false),
        ComputeEdge[], RefValue{TypedEdge}()
    )
end

function _get_named_change(::NamedTuple{Names}, dirty) where {Names}
    values = ntuple(i -> dirty[i], length(Names))
    return NamedTuple{Names,NTuple{length(Names),Bool}}(values)
end

function TypedEdge(edge::ComputeEdge)
    N = length(edge.inputs)
    names = ntuple(i -> edge.inputs[i].name, N)
    values = ntuple(i -> edge.inputs[i].value, N)
    inputs = NamedTuple{names}(values)
    dirty = _get_named_change(inputs, edge.inputs_dirty)

    result = edge.callback(map(getindex, inputs), dirty, nothing)

    if result isa Tuple
        if length(result) != length(edge.outputs)
            m = first(methods(edge.callback))
            line = string(m.file, ":", m.line)
            error("Result needs to have same length. Found: $(result), for func $(line)")
        end
        outputs = ntuple(length(edge.outputs)) do i
            v = RefValue(result[i])
            edge.outputs[i].value = v # initialize to fully typed RefValue
            return v
        end
        foreach(node -> node.dirty = true, edge.outputs)
    elseif isnothing(result)
        outputs = ntuple(length(edge.outputs)) do i
            v = RefValue(nothing)
            edge.outputs[i].value = v # initialize to fully typed RefValue
            return v
        end
        foreach(node -> node.dirty = false, edge.outputs)
    else
        error("Wrong type as result $(typeof(result)). Needs to be Tuple with one element per output or nothing. Value: $result")
    end

    return TypedEdge(edge.callback, inputs, edge.inputs_dirty, outputs, edge.outputs)
end


ComputeEdge(f) = ComputeEdge(f, Computed[])
function ComputeEdge(f, inputs::Vector{Computed})
    return ComputeEdge(f, inputs, fill(true, length(inputs)), Computed[], RefValue(false),
                       ComputeEdge[], RefValue{TypedEdge}())
end

"""
    struct Input

A `Input` represents an entry point to the `ComputeGraph`. Like [`Computed`](@ref)
it should not be created directly, but rely on [`add_input!`](@ref). It should
be updated by `update!(graph, input_name = new_value)` to correctly update the
state of the compute graph.
"""
mutable struct Input <: AbstractEdge
    name::Symbol
    value::Any
    f::Function
    output::Computed
    dirty::Bool
    dependents::Vector{ComputeEdge}
end

function Input(name, value, f, output)
    @assert !(value isa Computed)
    return Input(name, value, f, output, true, ComputeEdge[])
end

"""
    ComputeGraph()

Creates a new empty `ComputeGraph`.

Inputs can be added to the graph using [`add_input`](@ref). Computations and the
connected outputs can be added with [`register_computation!`](@ref).

To update an input, `update!(graph, input_name = new_value)` can be used. To get
an up-to-date value from an output use `graph[:output_name][]`.

## Example:

```
graph = ComputeGraph()

add_input!(graph, :first_node, 1)
register_computation!(graph, [:first_node], [:derived_node]) do inputs, changed, cached
    return (2 * inputs[1][], )
end

update!(graph, first_node = 2)
graph[:derived_node][]
```
"""
struct ComputeGraph
    inputs::Dict{Symbol,Input}
    outputs::Dict{Symbol,Computed}
    onchange::Observable{Nothing}
end

function ComputeGraph()
    return ComputeGraph(Dict{Symbol,ComputeEdge}(), Dict{Symbol,Computed}(), Observable{Nothing}())
end

_first_arg(args, changed, last) = (args[1],)

function alias!(attr::ComputeGraph, key::Symbol, alias_key::Symbol)
    haskey(attr.inputs, key) || throw(KeyError(key))
    haskey(attr.outputs, alias_key) && throw(KeyError(alias_key))
    #TODO more efficient implementation!
    register_computation!(_first_arg, attr, [key], [alias_key])
    return attr
end

function isdirty(computed::Computed)
    return hasparent(computed) && isdirty(computed.parent)
end

function isdirty(edge::ComputeEdge)
    # If resolve hasn't run, it has to be dirty
    edge.got_resolved[] || return true
    # Otherwise it's dirty if the input changed
    return any(edge.inputs_dirty)
end

function mark_dirty!(edge::ComputeEdge)
    edge.got_resolved[] = false
    for dep in edge.dependents
        mark_dirty!(dep)
    end
    return
end

function mark_dirty!(computed::Computed)
    hasparent(computed) || return
    return mark_dirty!(computed.parent)
end

function resolve!(input::Input)
    input.dirty || return
    value = input.f(input.value)
    if isassigned(input.output.value)
        input.output.value[] = value
    else
        input.output.value = RefValue(value)
    end
    input.dirty = false
    input.output.dirty = true
    for edge in input.dependents
        mark_input_dirty!(input, edge)
    end
    input.output.dirty = false
    return input.output.value[]
end

function mark_dirty!(input::Input)
    input.dirty = true
    for edge in input.dependents
        mark_dirty!(edge)
    end
    return
end

function Base.setindex!(computed::Computed, value)
    if computed.parent isa Input
        return setindex!(computed.parent, value)
    else
        computed.value[] = value
        return mark_dirty!(computed)
    end
end

function Base.setindex!(input::Input, value)
    input.value = value
    return mark_dirty!(input)
end

function _setproperty!(attr::ComputeGraph, key::Symbol, value)
    input = attr.inputs[key]
    # Skip if the value is the same as before
    is_same(input.value, value) && return value
    input.value = value
    mark_dirty!(input)
    return value
end

function Base.setproperty!(attr::ComputeGraph, key::Symbol, value)
    _setproperty!(attr, key, value)
    notify(attr.onchange)
    return value
end

"""
    update!(graph; kwargs...)
    update!(graph, pairs::Pair{Symbol, Any}...)

Updates any number of inputs in the graph based on the passed `key = value`
keyword arguments. The `key` refers to the name of the input and the `value` is
the new value.

## Example:

```
graph = ComputeGraph()
add_input!(graph, :first_node, 1)
update!(graph, first_node = 2)
update!(graph, :first_node => 2)
```
"""
update!(attr::ComputeGraph; kwargs...) = update!(attr, kwargs...)

function update!(attr::ComputeGraph, pairs...)
    for (key, value) in pairs
        if haskey(attr.inputs, key)
            _setproperty!(attr, key, value)
        else
            error("Attribute $key not found in ComputeGraph")
        end
    end
    notify(attr.onchange)
    return attr
end

# TODO: should this check inputs, outputs, both?
# Note: WGLMakie relies on this checking output to avoid double-defining
Base.haskey(attr::ComputeGraph, key::Symbol) = haskey(attr.inputs, key) || haskey(attr.outputs, key)

function Base.getproperty(attr::ComputeGraph, key::Symbol)
    # more efficient to hardcode?
    key === :inputs && return getfield(attr, :inputs)
    key === :outputs && return getfield(attr, :outputs)
    key === :onchange && return getfield(attr, :onchange)
    return attr.inputs[key].output
end

function Base.getindex(attr::ComputeGraph, key::Symbol)
    return attr.outputs[key]
end
isdirty(input::Input) = input.dirty

Base.getindex(computed::Computed) = resolve!(computed)

function mark_input_dirty!(parent::ComputeEdge, edge::ComputeEdge)
    @assert parent.got_resolved[] # parent should only call this after resolve!
    for i in eachindex(edge.inputs)
        edge.inputs_dirty[i] |= getfield(edge.inputs[i], :dirty)
    end
end

function mark_input_dirty!(parent::Input, edge::ComputeEdge)
    @assert !parent.dirty # should got resolved
    for i in eachindex(edge.inputs)
        edge.inputs_dirty[i] |= getfield(edge.inputs[i], :dirty)
    end
end

function set_result!(edge::TypedEdge, result, i, value)
    if isnothing(value) || is_same(edge.outputs[i][], value)
        edge.output_nodes[i].dirty = false
    else
        edge.output_nodes[i].dirty = true
        edge.outputs[i][] = value
    end
    if !isempty(result)
        next_val = first(result)
        rem = Base.tail(result)
        set_result!(edge, rem, i + 1, next_val)
    end
    return
end

function set_result!(edge::TypedEdge, result)
    next_val = first(result)
    rem = Base.tail(result)
    return set_result!(edge, rem, 1, next_val)
end

is_same(@nospecialize(a), @nospecialize(b)) = false
function is_same(a::T, b::T) where T
    if isbitstype(T)
        # We can compare immutable isbits type per value with `===`
        return a === b
    else
        # For mutable types, we can only compare them if they're not pointing to the same  object
        # If they are the same, we have to give up since we cant test if they got mutated inbetween
        # Otherwise we can compare by equivalence
        same_object = a === b
        return same_object ? false : a == b
    end
end

# do we want this type stable?
# This is how we could get a type stable callback body for resolve
function resolve!(edge::TypedEdge)
    if any(edge.inputs_dirty) # only call if inputs changed
        dirty = _get_named_change(edge.inputs, edge.inputs_dirty)
        vals = map(getindex, edge.outputs)
        names = ntuple(length(vals)) do i
            edge.output_nodes[i].name
        end
        last = NamedTuple{names}(vals)
        result = edge.callback(map(getindex, edge.inputs), dirty, last)
        if result === :deregister
            # TODO
        elseif result isa Tuple
            if length(result) != length(edge.outputs)
                error("Did not return correct length: $(result), $(edge.callback)")
            end
            set_result!(edge, result)
        elseif isnothing(result)
            foreach(x -> x.dirty = false, edge.output_nodes)
        else
            error("Needs to return a Tuple with one element per output, or nothing")
        end
    end
end

function resolve!(computed::Computed)
    try
        return _resolve!(computed)
    catch e
        rethrow(ResolveException(computed, e))
    end
end

function _resolve!(computed::Computed)
    if hasparent(computed)
        resolve!(computed.parent)
    end
    return computed.value[]
end

function resolve!(edge::ComputeEdge)
    edge.got_resolved[] && return false
    isdirty(edge) || return false
    # Resolve inputs first
    foreach(_resolve!, edge.inputs)
    # We pass the refs, so that no boxing accours and code that actually needs Ref{T}(value) can directly use those (ccall/opengl)
    # TODO, can/should we store this tuple?
    if !isassigned(edge.typed_edge)
        # constructor does first resolve to determine fully typed outputs
        edge.typed_edge[] = TypedEdge(edge)
    else
        resolve!(edge.typed_edge[])
    end
    edge.got_resolved[] = true
    fill!(edge.inputs_dirty, false)
    for dep in edge.dependents
        mark_input_dirty!(edge, dep)
    end
    foreach(comp -> comp.dirty = false, edge.outputs)
    return true
end


"""
    add_input!([callback], compute_graph, name::Symbol, value)

Adds a new input to the given `compute_graph`. The input is referred to by the
given `name` and is initialized with the given `value`. If a `callback` is given
any new value will be passed to `callback(name, new_value)` before being stored
in the compute graph.

## Example:

```
graph = ComputeGraph()

add_input!(graph, :first_node, 1)
add_input!((k, v) -> Float32(v), graph, :second_node, 2)
```
"""
add_input!(attr::ComputeGraph, key::Symbol, value) = _add_input!(identity, attr, key, value)

# For cleaner printing and error tracking we do not use an anonymous function
#   value -> conversion_function(key, value)
# or
#   (value,), changed, cached -> conversion_function(key, value)
# but instead create an explicit wrapper here.
struct InputFunctionWrapper{FT} <: Function
    key::Symbol
    user_func::FT
end
(x::InputFunctionWrapper)(v) = x.user_func(x.key, v)
(x::InputFunctionWrapper)(inputs, changed, cached) = (x.user_func(x.key, inputs[1]),)

function add_input!(conversion_func, attr::ComputeGraph, key::Symbol, value)
    return _add_input!(InputFunctionWrapper(key, conversion_func), attr, key, value)
end

function _add_input!(func, attr::ComputeGraph, key::Symbol, value)
    @assert !(value isa Computed)
    if haskey(attr.inputs, key) || haskey(attr.outputs, key)
        error("Cannot attach input with name $key - already exists!")
    end

    output = Computed(key, RefValue{Any}())
    input = Input(key, value, func, output)
    output.parent = input
    output.parent_idx = 1
    # Needs to be Any, since input can change type
    attr.inputs[key] = input
    attr.outputs[key] = output
    return attr
end

function add_inputs!(conversion_func, attr::ComputeGraph; kw...)
    for (k, v) in pairs(kw)
        add_input!(conversion_func, attr, k, v)
    end
    return attr
end

compute_identity(inputs, changed, cached) = values(inputs)

# TODO: These functions place the given Computed node into the graph. This
#       typically results in `key != node.name`, which invites errors
# for recipe -> recipe (mostly)
"""
    add_input!([callback], compute_graph, name::Symbol, node::Computed)

Connects an output `node` of another compute graph to the given `compute_graph`.

This does not create a settable input, meaning you cannot use
`update!(graph, name = new_value)` to update it. It is solely updated by the
connected node.
"""
function add_input!(attr::ComputeGraph, key::Symbol, value::Computed)
    if haskey(attr.outputs, key)
        error("Cannot attach throughput with name $key - already exists!")
    end
    # This skips checks and allows direct passing of input nodes.
    # With one input & output, the checks boil down to:
    # 1. input exists
    # 2. output does not exist (or is already what we want to create)
    # which are given here
    unsafe_register!(compute_identity, attr, [value], (key,))
    return attr
end

# for recipe -> primitive (mostly)
function add_input!(conversion_func, attr::ComputeGraph, key::Symbol, value::Computed)
    if haskey(attr.outputs, key)
        error("Cannot attach throughput with name $key - already exists!")
    end
    unsafe_register!(InputFunctionWrapper(key, conversion_func), attr, [value], (key,))
    return attr
end

"""
    add_input!([callback], compute_graph, name::Symbol, obs::Observable)

Connects an `Observable` as a input to the given `compute_graph`. The input will
be updated automatically whenever the observable updates. It can also be updated
through the usual `update!(graph, name = new_value)` call.

The Observable listener is set up with `priority = typemax(Int)-1` and
`Consume(false)`. This means it will take precedence over all but `typemax(Int)`
priority and not block later updates.
"""
function add_input!(attr::ComputeGraph, k::Symbol, obs::Observable)
    add_input!(attr, k, obs[])
    # typemax-1 so it doesn't get disturbed by other listeners but can still be
    # blocked by a typamax obs
    on(obs, priority = typemax(Int)-1) do new_val
        setproperty!(attr, k, new_val)
        return Consume(false)
    end
    return attr
end

function add_input!(f, attr::ComputeGraph, k::Symbol, obs::Observable)
    add_input!(f, attr, k, obs[])
    on(obs, priority = typemax(Int)-1) do new_val
        setproperty!(attr, k, new_val)
        return Consume(false)
    end
    return attr
end

get_callback(computed::Computed) = hasparent(computed) ? computed.parent.callback : nothing

"""
    register_computation!(callback, compute_graph, input_names, output_names)

Registers a new computation which transforms the given inputs to a new set of
outputs. Both the inputs and outputs are referred to by name. The inputs must
exist when the function is called. The outputs should usually created by this
function.

The callback function must accept 3 arguments:
- `inputs::NamedTuple` which contains the `input_names` and input values in the order given to `register_computation`
- `changed::NamedTuple` which a `Bool` per input name signifying whether the input has been updated since the last execution of `callback`
- `cached::Tuple` which contain the last outputs returned by function. If no previous outputs exist `cached = nothing`.

Note that `inputs` and `cached` always wrap input and outputs values in `Ref`,
so you need to always dereference them.

## Example:

```julia
graph = ComputeGraph()
add_input!(graph, :input1, 1)
add_input!(graph, :input2, 1)

register_computation!(graph, [:input1, :input2], [:output1, :output2]) do inputs, changed, cached
    input1, input2 = inputs
    has_input1_changed, has_input2_changed2 = changed
    cached_output1, cached_output2 = cached

    # compute new outputs

    return (new_output1, new_output2)
end
```
"""
function register_computation!(f, attr::ComputeGraph, inputs::Vector{Symbol}, outputs::Vector{Symbol})
    if any(x-> getfield(f, x) isa Core.Box, propertynames(f))
        boxed = [x => getfield(f, x) for x in propertynames(f) if getfield(f, x) isa Core.Box]
        boxed_str = map(boxed) do (k, v)
            box = isdefined(v, :contents) ? typeof(v.contents) : "#undef"
            return "$(k)::Core.Box($(box))"
        end
        error("Cannot register computation: Callback function cannot use boxed values: $(first(methods(f))), $(join(boxed_str, ","))")
    end
    if any(k -> haskey(attr.outputs, k), outputs)
        existing = [k for k in outputs if haskey(attr.outputs, k) && hasparent(attr.outputs[k])]
        if length(existing) == 0
            # fine, we won't be overwriting an edge
        elseif length(existing) != length(outputs)
            combined = join(existing, ", ")
            error("Cannot register computation: Some outputs already have parent compute edges: $combined")
        else
            e1 = attr.outputs[outputs[1]].parent

            if length(inputs) != length(e1.inputs)
                error("Cannot register computation: At least one parent compute exists with a different set of inputs.")
            end

            if !all(attr.outputs[k].parent == e1 for k in outputs)
                # bad_keys = join([k for k in outputs if attr.outputs[k].parent != e1], ", ")
                error("Cannot register computation: $outputs already have multiple parent compute edges.")
            end

            if e1.callback != f
                # We should only care about input arg types...
                func1, loc1 = edge_callback_to_string(f)
                func2, loc2 = edge_callback_to_string(e1.callback)
                error(
                    "Cannot register computation: The outputs already have a parent compute edge using " *
                    "a different callback function.\n  Given: $func1 $loc1\n  Found: $func2 $loc2\n  $(methods(f))"
                )
            end

            # We can not rely on e1.inputs.name here because name can be different
            # from the key in attr.outputs
            inputs_to_verify = Set(e1.inputs)
            for key in inputs
                if attr.outputs[key] in inputs_to_verify
                    delete!(inputs_to_verify, attr.outputs[key])
                else
                    error("Cannot register computation: There already exists a parent compute edge for the given outputs " *
                    "that uses a different set of inputs. (Failed to find $( attr.outputs[key]) in existing)")
                end
            end
            if !isempty(inputs_to_verify)
                error("Cannot register computation: There already exists a parent compute edge for the given outputs " *
                "that uses a different set of inputs. (Given outputs exclude $inputs_to_verify.)")
            end

            # edge already exists so we can return
            return
        end
    end

    _inputs = Computed[attr.outputs[k] for k in inputs]
    unsafe_register!(f, attr, _inputs, outputs)
    return
end

function unsafe_register!(f, attr::ComputeGraph, inputs::Vector{Computed}, output_names)
    new_edge = ComputeEdge(f, inputs)
    for input in inputs
        @assert hasparent(input)
        # Edges can have multiple outputs so multiple inputs of this edge could
        # come from the same edge
        any(x -> x === new_edge, input.parent.dependents) && continue
        push!(input.parent.dependents, new_edge)
    end

    # use order of namedtuple, which should not change!
    for (i, symbol) in enumerate(output_names)
        # create an uninitialized Ref, which gets replaced by the correctly strictly typed Ref on first resolve
        value = get!(attr.outputs, symbol, Computed(symbol))
        value.parent = new_edge
        value.parent_idx = i
        value.dirty = true
        push!(new_edge.outputs, value)
    end
    return
end

"""
    delete!(graph::ComputeGraph, key::Symbol[; force = false, recursive = false])

Deletes a node from the given graph based on its name.

If `recursive = true` all child nodes of the selected node are deleted. If
`force = true` all siblings are deleted. If either exists without the respective
option being true an error will be thrown.
"""
function Base.delete!(attr::ComputeGraph, key::Symbol; force::Bool = false, recursive::Bool = false)
    haskey(attr.outputs, key) || throw(KeyError(key))
    _delete!(attr, attr.outputs[key], force, recursive)
    return attr
end

function _delete!(attr::ComputeGraph, node::Computed, force::Bool, recursive::Bool)
    @assert hasparent(node)
    _delete!(attr, node.parent, force, recursive)
    return attr
end

function validate_deletion(edge::ComputeEdge, force::Bool, recursive::Bool)
    force && recursive && return
    if !(length(edge.outputs) == 1 || force)
        error("Cannot delete node because it or one of its dependents has siblings. Set `force = true` to also delete siblings.")
    end
    if !(recursive || isempty(edge.dependents))
        error("Cannot delete node because it has children. Set `recursive = true` to also delete its children.")
    end
    foreach(e -> validate_deletion(e, force, recursive), edge.dependents)
end

function validate_deletion(edge::Input, force::Bool, recursive::Bool)
    force && recursive && return
    if !(recursive || isempty(edge.dependents))
        error("Cannot delete node because it has children. Set `recursive = true` to also delete its children.")
    end
    foreach(e -> validate_deletion(e, force, recursive), edge.dependents)
end

function _delete!(attr::ComputeGraph, edge::AbstractEdge, force::Bool, recursive::Bool)
    validate_deletion(edge, force, recursive)
    return unsafe_delete!(attr, edge)
end

function unsafe_delete!(attr::ComputeGraph, edge::ComputeEdge)
    # all dependents become invalid as their parent computation no longer runs
    for dependent in edge.dependents
        unsafe_delete!(attr, dependent)
    end

    # deregister this edge as a dependency of its parents
    for computed in edge.inputs
        @assert hasparent(computed)
        parent_edge = computed.parent
        filter!(e -> e !== edge, parent_edge.dependents)
    end

    # Delete output nodes of this edge
    for computed in edge.outputs
        k = computed.name
        @assert haskey(attr.outputs, k) && attr.outputs[k] === computed
        delete!(attr.outputs, k)
    end

    return attr
end

function unsafe_delete!(attr::ComputeGraph, edge::Input)
    # all dependents become invalid as their parent computation no longer runs
    for dependent in edge.dependents
        unsafe_delete!(attr, dependent)
    end

    # Delete output node of this edge
    k = edge.name
    @assert haskey(attr.outputs, k) && attr.outputs[k] === edge.output
    delete!(attr.outputs, k)

    # Delete Input
    @assert haskey(attr.inputs, k) && attr.inputs[k] === edge
    delete!(attr.inputs, k)

    return attr
end

include("io.jl")

export Computed, Computed, ComputeEdge, ComputeGraph, register_computation!, add_input!, add_inputs!, update!

end
