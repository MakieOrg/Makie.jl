<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link href="../css/franklin.css" rel="stylesheet"/><link href="../css/minimal-mistakes.css" rel="stylesheet"/><link href="../css/makie.css" rel="stylesheet"/><link href="../assets/icon_transparent.png" rel="icon"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://files.stork-search.net/releases/v1.4.2/basic.css" rel="stylesheet"/><style>
    .stork-wrapper {
      width:99%
    }
    .stork-wrapper .stork-results {
      max-height: 42vh;
    }
</style><title>API Â· Makie</title></head><body class="layout--single"><div class="site-container"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav class="greedy-nav" id="site-nav"><a class="title-icon" href=".."><img src="../assets/makie_logo_transparent.svg"/></a><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/JuliaPlots/Makie.jl"><img class="masthead-icon" src="../assets/GitHub-Mark-64px.png"/></a></li><li class="masthead__menu-item"><a href="../reference/">Reference</a></li><li class="masthead__menu-item"><a href="../tutorials/">Tutorials</a></li><li class="masthead__menu-item"><a href="../how-to/">How-Tos</a></li><li class="masthead__menu-item"><a href="../explanations/">Explanations</a></li><li class="masthead__menu-item"><a href="">API</a></li><li class="masthead__menu-item"><a href="../news/">News</a></li><li class="masthead__menu-item" id="masthead-search-button"><script>
                            function toggleSearchOverlay(){
                                const overlay = document.querySelector("#makiesearch-overlay-container");
                                overlay.classList.toggle("hidden");
                                overlay.querySelector("input").focus();
                                overlay.onclick = function(e){
                                    if (e.target !== this){
                                        return
                                    }
                                    this.classList.toggle("hidden");
                                };
                            }
                        </script><button onclick="toggleSearchOverlay()"><i class="fas fa-search"></i> Search</button></li></ul><button class="greedy-nav__toggle" type="button"><span class="visually-hidden">Toggle menu</span><div class="navicon"></div></button><ul class="hidden-links hidden"></ul></nav></div></div></div><div id="main" role="main"><div id="overlay"></div><div class="hidden" id="makiesearch-overlay-container"><div id="makiesearch-overlay-container-inner"><div id="makiesearch-overlay"></div></div></div><div class="content-table-hidden" id="content-table-container"><button id="on-this-page" onclick="toggle_content_table_visibility()">On this page</button><script>
            function toggle_content_table_visibility(){
              const c = document.querySelector("#content-table-container");
              const ct = c.querySelector("#content-table");
              const vh = window.visualViewport.height;
              ct.style.height = `${Math.min(ct.scrollHeight, 0.66*vh)}px`;
              c.classList.toggle("content-table-hidden");
            }
          </script><div id="content-table"></div></div><div id="navbar-container"><div id="navbar"><div id="makiesearch"></div><ul><li><div class="tocitem-container"><a href="..">Home</a></div></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-2"><i class="docs-chevron"></i></label><a href="../reference">Reference</a></div><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-2-1"><i class="docs-chevron"></i></label><a href="../reference/blocks">Blocks</a></div><ul><li><div class="tocitem-container"><a href="../reference/blocks/axis">Axis</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/axis3">Axis3</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/box">Box</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/button">Button</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/colorbar">Colorbar</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/gridlayout">GridLayout</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/intervalslider">IntervalSlider</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/label">Label</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/legend">Legend</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/lscene">LScene</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/menu">Menu</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/polaraxis">PolarAxis</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/slider">Slider</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/slidergrid">SliderGrid</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/textbox">Textbox</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/toggle">Toggle</a></div></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-2-2"><i class="docs-chevron"></i></label><a href="../reference/plots">Plots</a></div><ul><li><div class="tocitem-container"><a href="../reference/plots/ablines">ablines</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/arc">arc</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/arrows">arrows</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/band">band</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/barplot">barplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/boxplot">boxplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/bracket">bracket</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/contour">contour</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/contour3d">contour3d</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/contourf">contourf</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/crossbar">crossbar</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/datashader">datashader</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/density">density</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/ecdf">ecdfplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/errorbars">errorbars</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/heatmap">heatmap</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/hexbin">hexbin</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/hist">hist</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/hvlines">hlines and vlines</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/hvspan">hspan and vspan</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/image">image</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/lines">lines</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/linesegments">linesegments</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/mesh">mesh</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/meshscatter">meshscatter</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/pie">pie</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/poly">poly</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/qqplot">qqplot and qqnorm</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/rainclouds">rainclouds</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/rangebars">rangebars</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/scatter">scatter</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/scatterlines">scatterlines</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/series">series</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/spy">spy</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/stairs">stairs</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/stem">stem</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/stephist">stephist</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/streamplot">streamplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/surface">surface</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/text">text</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/tooltip">tooltip</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/tricontourf">tricontourf</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/triplot">triplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/violin">violin</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/volume">volume</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/volumeslices">volumeslices</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/voronoiplot">voronoiplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/waterfall">waterfall</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/wireframe">wireframe</a></div></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-2-3"><i class="docs-chevron"></i></label><a href="../reference/scene">Scene</a></div><ul><li><div class="tocitem-container"><a href="../reference/scene/SSAO">SSAO</a></div></li><li><div class="tocitem-container"><a href="../reference/scene/lighting">Lighting</a></div></li><li><div class="tocitem-container"><a href="../reference/scene/matcap">Matcap</a></div></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-3"><i class="docs-chevron"></i></label><a href="../tutorials">Tutorials</a></div><ul><li><div class="tocitem-container"><a href="../tutorials/aspect-tutorial">Aspect ratio and size control tutorial</a></div></li><li><div class="tocitem-container"><a href="../tutorials/basic-tutorial">Basic Tutorial</a></div></li><li><div class="tocitem-container"><a href="../tutorials/layout-tutorial">Layout Tutorial</a></div></li><li><div class="tocitem-container"><a href="../tutorials/scenes">Scene tutorial</a></div></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-4"><i class="docs-chevron"></i></label><a href="../how-to">How-Tos</a></div><ul><li><div class="tocitem-container"><a href="../how-to/draw-boxes-around-subfigures">How to draw boxes around subfigures</a></div></li><li><div class="tocitem-container"><a href="../how-to/save-figure-with-transparency">How to save a <code>Figure</code> with transparency</a></div></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-5"><i class="docs-chevron"></i></label><a href="../explanations">Explanations</a></div><ul><li><div class="tocitem-container"><a href="../explanations/animation">Animations</a></div></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-5-2"><i class="docs-chevron"></i></label><a href="../explanations/backends">Backends</a></div><ul><li><div class="tocitem-container"><a href="../explanations/backends/cairomakie">CairoMakie</a></div></li><li><div class="tocitem-container"><a href="../explanations/backends/glmakie">GLMakie</a></div></li><li><div class="tocitem-container"><a href="../explanations/backends/rprmakie">RPRMakie</a></div></li><li><div class="tocitem-container"><a href="../explanations/backends/wglmakie">WGLMakie</a></div></li></ul></li><li><div class="tocitem-container"><a href="../explanations/blocks">Blocks</a></div></li><li><div class="tocitem-container"><a href="../explanations/cameras">Cameras</a></div></li><li><div class="tocitem-container"><a href="../explanations/colors">Colors</a></div></li><li><div class="tocitem-container"><a href="../explanations/events">Events</a></div></li><li><div class="tocitem-container"><a href="../explanations/faq">Frequently Asked Questions</a></div></li><li><div class="tocitem-container"><a href="../explanations/figure">Figures</a></div></li><li><div class="tocitem-container"><a href="../explanations/fonts">Fonts</a></div></li><li><div class="tocitem-container"><a href="../explanations/headless">Headless</a></div></li><li><div class="tocitem-container"><a href="../explanations/inspector">Inspecting Data</a></div></li><li><div class="tocitem-container"><a href="../explanations/latex">LaTeX</a></div></li><li><div class="tocitem-container"><a href="../explanations/layouting">How layouts work</a></div></li><li><div class="tocitem-container"><a href="../explanations/nodes">Observables &amp; Interaction</a></div></li><li><div class="tocitem-container"><a href="../explanations/plot_method_signatures">Plot Method Signatures</a></div></li><li><div class="tocitem-container"><a href="../explanations/recipes">Plot Recipes</a></div></li><li><div class="tocitem-container"><a href="../explanations/scenes">Scenes</a></div></li><li><div class="tocitem-container"><a href="../explanations/specapi">SpecApi</a></div></li><li><input class="collapse-toggle" id="menuitem-5-19" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-5-19"><i class="docs-chevron"></i></label><a href="../explanations/theming">Theming</a></div><ul><li><div class="tocitem-container"><a href="../explanations/theming/predefined_themes">Predefined themes</a></div></li></ul></li><li><div class="tocitem-container"><a href="../explanations/transparency">Basic transparency</a></div></li></ul></li><li><div class="tocitem-container"><a class="active" href="">API</a></div></li><li><div class="tocitem-container"><a href="../news">Changelog</a></div></li></ul></div></div><div class="franklin-content"><h1 id="api"><a class="header-anchor" href="#api">API</a></h1><div class="docstring"><div class="doc-header" id=".."><a href="#..">..</a></div><div class="doc-content"><pre><code>iv = l..r</code></pre><p>Construct a ClosedInterval <code>iv</code> spanning the region from <code>l</code> to <code>r</code>.</p><h1>Examples</h1><pre><code class="language-jldoctest">julia&gt; 1..2
1 .. 2

julia&gt; 3..1  # Empty interval set can be defined
3 .. 1</code></pre></div></div><div class="docstring"><div class="doc-header" id="@L_str"><a href="#@L_str">@L_str</a></div><div class="doc-content"><pre><code>L"..."</code></pre><p>Creates a <code>LaTeXString</code> and is equivalent to <code>latexstring(raw"...")</code>, except that <code>%$</code> can be used for interpolation.</p><pre><code class="language-jldoctest">julia&gt; L"x = \sqrt{2}"
L"$x = \sqrt{2}$"

julia&gt; L"x = %$(sqrt(2))"
L"$x = 1.4142135623730951$"</code></pre></div></div><div class="docstring"><div class="doc-header" id="@colorant_str"><a href="#@colorant_str">@colorant_str</a></div><div class="doc-content"><pre><code>@colorant_str(ex)</code></pre><p>Parse a literal color name as a Colorant. See <a href="@ref"><code>Base.parse(Colorant, desc)</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="@extract"><a href="#@extract">@extract</a></div><div class="doc-content"><pre><code>@extract scene (a, b, c, d)</code></pre><p>This becomes</p><pre><code class="language-julia">begin
    a = scene[:a]
    b = scene[:b]
    c = scene[:d]
    d = scene[:d]
    (a, b, c, d)
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="@extractvalue"><a href="#@extractvalue">@extractvalue</a></div><div class="doc-content"><p>usage @extractvalue scene (a, b, c, d) will become:</p><pre><code class="language-julia">begin
    a = to_value(scene[:a])
    b = to_value(scene[:b])
    c = to_value(scene[:c])
    (a, b, c)
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="@get_attribute"><a href="#@get_attribute">@get_attribute</a></div><div class="doc-content"><pre><code>@get_attribute scene (a, b, c, d)</code></pre><p>This will extract attribute <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> from <code>scene</code> and apply the correct attribute conversions + will extract the value if it's a signal. It will make those attributes available as variables and return them as a tuple. So the above is equal to: will become:</p><pre><code class="language-julia">begin
    a = get_attribute(scene, :a)
    b = get_attribute(scene, :b)
    c = get_attribute(scene, :c)
    (a, b, c)
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="@key_str"><a href="#@key_str">@key_str</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.@key_str</code> is a macro.</p><pre><code># 1 method for macro "@key_str" from MakieCore:
 [1] var"@key_str"(__source__::LineNumberNode, __module__::Module, arg)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/types.jl:94</code></pre></div></div><div class="docstring"><div class="doc-header" id="@lift"><a href="#@lift">@lift</a></div><div class="doc-content"><p>Replaces an expression with <code>lift(argtuple -&gt; expression, args...)</code>, where <code>args</code> are all expressions inside the main one that begin with $.</p><h1>Example:</h1><pre><code class="language-julia">x = Observable(rand(100))
y = Observable(rand(100))</code></pre><h2>before</h2><pre><code class="language-julia">z = lift((x, y) -&gt; x .+ y, x, y)</code></pre><h2>after</h2><pre><code class="language-julia">z = @lift($x .+ $y)</code></pre><p>You can also use parentheses around an expression if that expression evaluates to an observable.</p><pre><code class="language-julia">nt = (x = Observable(1), y = Observable(2))
@lift($(nt.x) + $(nt.y))</code></pre></div></div><div class="docstring"><div class="doc-header" id="@recipe"><a href="#@recipe">@recipe</a></div><div class="doc-content"><h1>Plot Recipes in <code>Makie</code></h1><p>There's two types of recipes. <em>Type recipes</em> define a simple mapping from a user defined type to an existing plot type. <em>Full recipes</em> can customize the theme and define a custom plotting function.</p><h2>Type recipes</h2><p>Type recipe are really simple and just overload the argument conversion pipeline. This can be done for all plot types or for a subset of plot types:</p><pre><code># All plot types
convert_arguments(P::Type{&lt;:AbstractPlot}, x::MyType) = convert_arguments(P, rand(10, 10))
# Only for scatter plots
convert_arguments(P::Type{&lt;:Scatter}, x::MyType) = convert_arguments(P, rand(10, 10))</code></pre><p>Optionally you may define the default plot type so that <code>plot(x::MyType)</code> will use this:</p><pre><code>plottype(::MyType) = Surface</code></pre><h2>Full recipes with the <code>@recipe</code> macro</h2><p>A full recipe for <code>MyPlot</code> comes in two parts. First is the plot type name, arguments and theme definition which are defined using the <code>@recipe</code> macro. Second is a custom <code>plot!</code> for <code>MyPlot</code>, implemented in terms of the atomic plotting functions.</p><p>We use an example to show how this works:</p><pre><code># arguments (x, y, z) &amp;&amp; theme are optional
@recipe(MyPlot, x, y, z) do scene
    Attributes(
        plot_color = :red
    )
end</code></pre><p>This macro expands to several things. Firstly a type definition:</p><pre><code>const MyPlot{ArgTypes} = Plot{myplot, ArgTypes}</code></pre><p>The type parameter of <code>Plot</code> contains the function instead of e.g. a symbol. This way the mapping from <code>MyPlot</code> to <code>myplot</code> is safer and simpler. (The downside is we always need a function <code>myplot</code> - TODO: is this a problem?)</p><p>The following signatures are defined to make <code>MyPlot</code> nice to use:</p><pre><code>myplot(args...; kw_args...) = ...
myplot!(scene, args...; kw_args...) = ...
myplot(kw_args::Dict, args...) = ...
myplot!(scene, kw_args::Dict, args...) = ...
#etc (not 100% settled what signatures there will be)</code></pre><p>A specialization of <code>argument_names</code> is emitted if you have an argument list <code>(x,y,z)</code> provided to the recipe macro:</p><pre><code>argument_names(::Type{&lt;: MyPlot}) = (:x, :y, :z)</code></pre><p>This is optional but it will allow the use of <code>plot_object[:x]</code> to fetch the first argument from the call <code>plot_object = myplot(rand(10), rand(10), rand(10))</code>, for example. Alternatively you can always fetch the <code>i</code>th argument using <code>plot_object[i]</code>, and if you leave out the <code>(x,y,z)</code>, the default version of <code>argument_names</code> will provide <code>plot_object[:arg1]</code> etc.</p><p>The theme given in the body of the <code>@recipe</code> invocation is inserted into a specialization of <code>default_theme</code> which inserts the theme into any scene that plots <code>MyPlot</code>:</p><pre><code>function default_theme(scene, ::MyPlot)
    Attributes(
        plot_color = :red
    )
end</code></pre><p>As the second part of defining <code>MyPlot</code>, you should implement the actual plotting of the <code>MyPlot</code> object by specializing <code>plot!</code>:</p><pre><code>function plot!(plot::MyPlot)
    # normal plotting code, building on any previously defined recipes
    # or atomic plotting operations, and adding to the combined `plot`:
    lines!(plot, rand(10), color = plot[:plot_color])
    plot!(plot, plot[:x], plot[:y])
    plot
end</code></pre><p>It's possible to add specializations here, depending on the argument <em>types</em> supplied to <code>myplot</code>. For example, to specialize the behavior of <code>myplot(a)</code> when <code>a</code> is a 3D array of floating point numbers:</p><pre><code>const MyVolume = MyPlot{Tuple{&lt;:AbstractArray{&lt;: AbstractFloat, 3}}}
argument_names(::Type{&lt;: MyVolume}) = (:volume,) # again, optional
function plot!(plot::MyVolume)
    # plot a volume with a colormap going from fully transparent to plot_color
    volume!(plot, plot[:volume], colormap = :transparent =&gt; plot[:plot_color])
    plot
end</code></pre><p>The docstring given to the recipe will be transferred to the functions it generates.</p></div></div><div class="docstring"><div class="doc-header" id="ABLines"><a href="#ABLines">ABLines</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Absolute"><a href="#Absolute">Absolute</a></div><div class="doc-content"><pre><code>Absolute</code></pre><p>Force transformation to be absolute, not relative to the current state. This is the default setting.</p></div></div><div class="docstring"><div class="doc-header" id="Absorption"><a href="#Absorption">Absorption</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbsorptionRGBA"><a href="#AbsorptionRGBA">AbsorptionRGBA</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbstractCamera"><a href="#AbstractCamera">AbstractCamera</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type AbstractCamera</code></pre><h1>Subtypes</h1><pre><code>Camera2D
EmptyCamera
Makie.AbstractCamera3D
Makie.OldCamera3D
Makie.OrthographicCamera
Makie.PixelCamera
Makie.RelativeCamera</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbstractPlot"><a href="#AbstractPlot">AbstractPlot</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type AbstractPlot{Typ}</code></pre><h1>Subtypes</h1><pre><code>Makie.FakePlot
MakieCore.ScenePlot{Typ}</code></pre><h1>Supertype Hierarchy</h1><pre><code>AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbstractScene"><a href="#AbstractScene">AbstractScene</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type AbstractScene</code></pre><h1>Subtypes</h1><pre><code>Scene</code></pre><h1>Supertype Hierarchy</h1><pre><code>AbstractScene &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Accum"><a href="#Accum">Accum</a></div><div class="doc-content"><pre><code>Accum</code></pre><p>Force transformation to be relative to the current state, not absolute.</p></div></div><div class="docstring"><div class="doc-header" id="AmbientLight"><a href="#AmbientLight">AmbientLight</a></div><div class="doc-content"><pre><code>AmbientLight(color) &lt;: AbstractLight</code></pre><p>A simple ambient light that uniformly lights every object based on its light color.</p><p>Availability:</p><ul><li><p>All backends with <code>shading = FastShading</code> or <code>MultiLightShading</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Annotations"><a href="#Annotations">Annotations</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Arc"><a href="#Arc">Arc</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Arrows"><a href="#Arrows">Arrows</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Aspect"><a href="#Aspect">Aspect</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Aspect</code></pre><h1>Fields</h1><pre><code>index :: Int64
ratio :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="Atomic"><a href="#Atomic">Atomic</a></div><div class="doc-content"><pre><code>Union{Types...}</code></pre><p>A type union is an abstract type which includes all instances of any of its argument types. The empty union <a href="@ref"><code>Union{}</code></a> is the bottom type of Julia.</p><h1>Examples</h1><pre><code class="language-jldoctest">julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 isa IntOrString
true

julia&gt; "Hello!" isa IntOrString
true

julia&gt; 1.0 isa IntOrString
false</code></pre></div></div><div class="docstring"><div class="doc-header" id="Attributes"><a href="#Attributes">Attributes</a></div><div class="doc-content"><p>Main structure for holding attributes, for theming plots etc! Will turn all values into observables, so that they can be updated.</p></div></div><div class="docstring"><div class="doc-header" id="Auto"><a href="#Auto">Auto</a></div><div class="doc-content"><pre><code>struct Auto</code></pre><p>If used as a <code>GridLayout</code>'s row / column size and <code>trydetermine == true</code>, signals to the <code>GridLayout</code> that the row / column should shrink to match the largest determinable element inside. If no size of a content element can be determined, the remaining space is split between all <code>Auto</code> rows / columns according to their <code>ratio</code>.</p><p>If used as width / height of a layoutable element and <code>trydetermine == true</code>, the element's computed width / height will report the auto width / height if it can be determined. This enables a parent <code>GridLayout</code> to adjust its column / rowsize to the element's width / height. If <code>trydetermine == false</code>, the element's computed width / height will report <code>nothing</code> even if an auto width / height can be determined, which will prohibit a parent <code>GridLayout</code> from adjusting a row / column to the element's width / height. This is useful to, e.g., prohibit a <code>GridLayout</code> from shrinking a column's width to the width of a super title, even though the title's width can be auto-determined.</p><p>The <code>ratio</code> is ignored if <code>Auto</code> is used as an element size.</p></div></div><div class="docstring"><div class="doc-header" id="Axis"><a href="#Axis">Axis</a></div><div class="doc-content"><p><strong><code>Axis &lt;: Block</code></strong></p><p>A 2D axis which can be plotted into.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">Axis(fig_or_scene; palette = nothing, kwargs...)</code></pre><p><strong>Attributes</strong></p><p>(type <code>?Axis.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>aspect</code>, <code>autolimitaspect</code>, <code>backgroundcolor</code>, <code>bottomspinecolor</code>, <code>bottomspinevisible</code>, <code>flip_ylabel</code>, <code>halign</code>, <code>height</code>, <code>leftspinecolor</code>, <code>leftspinevisible</code>, <code>limits</code>, <code>panbutton</code>, <code>rightspinecolor</code>, <code>rightspinevisible</code>, <code>spinewidth</code>, <code>subtitle</code>, <code>subtitlecolor</code>, <code>subtitlefont</code>, <code>subtitlegap</code>, <code>subtitlelineheight</code>, <code>subtitlesize</code>, <code>subtitlevisible</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>title</code>, <code>titlealign</code>, <code>titlecolor</code>, <code>titlefont</code>, <code>titlegap</code>, <code>titlelineheight</code>, <code>titlesize</code>, <code>titlevisible</code>, <code>topspinecolor</code>, <code>topspinevisible</code>, <code>valign</code>, <code>width</code>, <code>xautolimitmargin</code>, <code>xaxisposition</code>, <code>xgridcolor</code>, <code>xgridstyle</code>, <code>xgridvisible</code>, <code>xgridwidth</code>, <code>xlabel</code>, <code>xlabelcolor</code>, <code>xlabelfont</code>, <code>xlabelpadding</code>, <code>xlabelrotation</code>, <code>xlabelsize</code>, <code>xlabelvisible</code>, <code>xminorgridcolor</code>, <code>xminorgridstyle</code>, <code>xminorgridvisible</code>, <code>xminorgridwidth</code>, <code>xminortickalign</code>, <code>xminortickcolor</code>, <code>xminorticks</code>, <code>xminorticksize</code>, <code>xminorticksvisible</code>, <code>xminortickwidth</code>, <code>xpankey</code>, <code>xpanlock</code>, <code>xrectzoom</code>, <code>xreversed</code>, <code>xscale</code>, <code>xtickalign</code>, <code>xtickcolor</code>, <code>xtickformat</code>, <code>xticklabelalign</code>, <code>xticklabelcolor</code>, <code>xticklabelfont</code>, <code>xticklabelpad</code>, <code>xticklabelrotation</code>, <code>xticklabelsize</code>, <code>xticklabelspace</code>, <code>xticklabelsvisible</code>, <code>xticks</code>, <code>xticksize</code>, <code>xticksmirrored</code>, <code>xticksvisible</code>, <code>xtickwidth</code>, <code>xtrimspine</code>, <code>xzoomkey</code>, <code>xzoomlock</code>, <code>yautolimitmargin</code>, <code>yaxisposition</code>, <code>ygridcolor</code>, <code>ygridstyle</code>, <code>ygridvisible</code>, <code>ygridwidth</code>, <code>ylabel</code>, <code>ylabelcolor</code>, <code>ylabelfont</code>, <code>ylabelpadding</code>, <code>ylabelrotation</code>, <code>ylabelsize</code>, <code>ylabelvisible</code>, <code>yminorgridcolor</code>, <code>yminorgridstyle</code>, <code>yminorgridvisible</code>, <code>yminorgridwidth</code>, <code>yminortickalign</code>, <code>yminortickcolor</code>, <code>yminorticks</code>, <code>yminorticksize</code>, <code>yminorticksvisible</code>, <code>yminortickwidth</code>, <code>ypankey</code>, <code>ypanlock</code>, <code>yrectzoom</code>, <code>yreversed</code>, <code>yscale</code>, <code>ytickalign</code>, <code>ytickcolor</code>, <code>ytickformat</code>, <code>yticklabelalign</code>, <code>yticklabelcolor</code>, <code>yticklabelfont</code>, <code>yticklabelpad</code>, <code>yticklabelrotation</code>, <code>yticklabelsize</code>, <code>yticklabelspace</code>, <code>yticklabelsvisible</code>, <code>yticks</code>, <code>yticksize</code>, <code>yticksmirrored</code>, <code>yticksvisible</code>, <code>ytickwidth</code>, <code>ytrimspine</code>, <code>yzoomkey</code>, <code>yzoomlock</code></p></div></div><div class="docstring"><div class="doc-header" id="Axis3"><a href="#Axis3">Axis3</a></div><div class="doc-content"><p><strong><code>Axis3 &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Axis3.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>aspect</code>, <code>azimuth</code>, <code>backgroundcolor</code>, <code>elevation</code>, <code>halign</code>, <code>height</code>, <code>limits</code>, <code>perspectiveness</code>, <code>protrusions</code>, <code>targetlimits</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>title</code>, <code>titlealign</code>, <code>titlecolor</code>, <code>titlefont</code>, <code>titlegap</code>, <code>titlesize</code>, <code>titlevisible</code>, <code>valign</code>, <code>viewmode</code>, <code>width</code>, <code>xautolimitmargin</code>, <code>xgridcolor</code>, <code>xgridvisible</code>, <code>xgridwidth</code>, <code>xlabel</code>, <code>xlabelalign</code>, <code>xlabelcolor</code>, <code>xlabelfont</code>, <code>xlabeloffset</code>, <code>xlabelrotation</code>, <code>xlabelsize</code>, <code>xlabelvisible</code>, <code>xreversed</code>, <code>xspinecolor_1</code>, <code>xspinecolor_2</code>, <code>xspinecolor_3</code>, <code>xspinesvisible</code>, <code>xspinewidth</code>, <code>xtickcolor</code>, <code>xtickformat</code>, <code>xticklabelcolor</code>, <code>xticklabelfont</code>, <code>xticklabelpad</code>, <code>xticklabelsize</code>, <code>xticklabelsvisible</code>, <code>xticks</code>, <code>xticksize</code>, <code>xticksvisible</code>, <code>xtickwidth</code>, <code>xypanelcolor</code>, <code>xypanelvisible</code>, <code>xzpanelcolor</code>, <code>xzpanelvisible</code>, <code>yautolimitmargin</code>, <code>ygridcolor</code>, <code>ygridvisible</code>, <code>ygridwidth</code>, <code>ylabel</code>, <code>ylabelalign</code>, <code>ylabelcolor</code>, <code>ylabelfont</code>, <code>ylabeloffset</code>, <code>ylabelrotation</code>, <code>ylabelsize</code>, <code>ylabelvisible</code>, <code>yreversed</code>, <code>yspinecolor_1</code>, <code>yspinecolor_2</code>, <code>yspinecolor_3</code>, <code>yspinesvisible</code>, <code>yspinewidth</code>, <code>ytickcolor</code>, <code>ytickformat</code>, <code>yticklabelcolor</code>, <code>yticklabelfont</code>, <code>yticklabelpad</code>, <code>yticklabelsize</code>, <code>yticklabelsvisible</code>, <code>yticks</code>, <code>yticksize</code>, <code>yticksvisible</code>, <code>ytickwidth</code>, <code>yzpanelcolor</code>, <code>yzpanelvisible</code>, <code>zautolimitmargin</code>, <code>zgridcolor</code>, <code>zgridvisible</code>, <code>zgridwidth</code>, <code>zlabel</code>, <code>zlabelalign</code>, <code>zlabelcolor</code>, <code>zlabelfont</code>, <code>zlabeloffset</code>, <code>zlabelrotation</code>, <code>zlabelsize</code>, <code>zlabelvisible</code>, <code>zreversed</code>, <code>zspinecolor_1</code>, <code>zspinecolor_2</code>, <code>zspinecolor_3</code>, <code>zspinesvisible</code>, <code>zspinewidth</code>, <code>ztickcolor</code>, <code>ztickformat</code>, <code>zticklabelcolor</code>, <code>zticklabelfont</code>, <code>zticklabelpad</code>, <code>zticklabelsize</code>, <code>zticklabelsvisible</code>, <code>zticks</code>, <code>zticksize</code>, <code>zticksvisible</code>, <code>ztickwidth</code></p></div></div><div class="docstring"><div class="doc-header" id="Axis3D"><a href="#Axis3D">Axis3D</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="AxisAspect"><a href="#AxisAspect">AxisAspect</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct AxisAspect</code></pre><h1>Fields</h1><pre><code>aspect :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="BBox"><a href="#BBox">BBox</a></div><div class="doc-content"><pre><code>BBox(left::Number, right::Number, bottom::Number, top::Number)</code></pre><p>Convenience constructor to create a <code>Rect2</code> with left, right, bottom and top extent instead of the usual origin, widths combination.</p></div></div><div class="docstring"><div class="doc-header" id="Band"><a href="#Band">Band</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="BarPlot"><a href="#BarPlot">BarPlot</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="BezierPath"><a href="#BezierPath">BezierPath</a></div><div class="doc-content"><pre><code>BezierPath(commands::Vector)</code></pre><p>Construct a <code>BezierPath</code> with a vector of path commands. The available path commands are</p><ul><li><p><code>MoveTo</code></p></li><li><p><code>LineTo</code></p></li><li><p><code>CurveTo</code></p></li><li><p><code>EllipticalArc</code></p></li><li><p><code>ClosePath</code></p></li></ul><p>A <code>BezierPath</code> can be used in certain places in Makie as an alternative to a polygon or a collection of lines, for example as an input to <code>poly</code> or <code>lines</code>, or as a <code>marker</code> for <code>scatter</code>.</p><p>The benefit of using a <code>BezierPath</code> is that curves do not need to be converted into a vector of vertices by the user. CairoMakie can use the path commands directly when it writes vector graphics which is more efficient and uses less space than approximating them visually using line segments.</p><pre><code>BezierPath(svg::AbstractString; fit = false, bbox = nothing, flipy = false, flipx = false, keep_aspect = true)</code></pre><p>Construct a <code>BezierPath</code> using a string of <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#path_commands">SVG path commands</a>. The commands will be parsed first into <code>MoveTo</code>, <code>LineTo</code>, <code>CurveTo</code>, <code>EllipticalArc</code> and <code>ClosePath</code> objects which are then passed to the <code>BezierPath</code> constructor.</p><p>If <code>fit === true</code>, the path will be scaled to fit into a square of width 1 centered on the origin. If, additionally, <code>bbox</code> is set to some <code>Rect</code>, the path will be fit into this rectangle instead. If you want to use a path as a scatter marker, it is usually good to fit it so that it's centered and of a comparable size relative to other scatter markers.</p><p>If <code>flipy === true</code> or <code>flipx === true</code>, the respective dimensions of the path will be flipped. Makie uses a coordinate system where y=0 is at the bottom and y increases upwards while in SVG, y=0 is at the top and y increases downwards, so for most SVG paths <code>flipy = true</code> will be needed.</p><p>If <code>keep_aspect === true</code>, the path will be fit into the bounding box such that its longer dimension fits and the other one is scaled to retain the original aspect ratio. If you set <code>keep_aspect = false</code>, the new boundingbox of the path will be the one it is fit to, but note that this can result in a squished appearance.</p><h2>Example</h2><p>Construct a triangular <code>BezierPath</code> out of a path command string and use it as a scatter marker:</p><pre><code class="language-julia">str = "M 0,0 L 10,0 L 5,10 z"
bp = BezierPath(str, fit = true)
scatter(1:10, marker = bp, markersize = 20)</code></pre></div></div><div class="docstring"><div class="doc-header" id="Billboard"><a href="#Billboard">Billboard</a></div><div class="doc-content"><pre><code>Billboard([angle::Real])
Billboard([angles::Vector{&lt;: Real}])</code></pre><p>Billboard attribute to always have a primitive face the camera. Can be used for rotation.</p></div></div><div class="docstring"><div class="doc-header" id="Bottom"><a href="#Bottom">Bottom</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Bottom</code></pre><h1>Supertype Hierarchy</h1><pre><code>Bottom &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="BottomLeft"><a href="#BottomLeft">BottomLeft</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct BottomLeft</code></pre><h1>Supertype Hierarchy</h1><pre><code>BottomLeft &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="BottomRight"><a href="#BottomRight">BottomRight</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct BottomRight</code></pre><h1>Supertype Hierarchy</h1><pre><code>BottomRight &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Box"><a href="#Box">Box</a></div><div class="doc-content"><p><strong><code>Box &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Box.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>color</code>, <code>cornerradius</code>, <code>halign</code>, <code>height</code>, <code>linestyle</code>, <code>strokecolor</code>, <code>strokevisible</code>, <code>strokewidth</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>visible</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="BoxPlot"><a href="#BoxPlot">BoxPlot</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Bracket"><a href="#Bracket">Bracket</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Button"><a href="#Button">Button</a></div><div class="doc-content"><p><strong><code>Button &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Button.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>buttoncolor</code>, <code>buttoncolor_active</code>, <code>buttoncolor_hover</code>, <code>clicks</code>, <code>cornerradius</code>, <code>cornersegments</code>, <code>font</code>, <code>fontsize</code>, <code>halign</code>, <code>height</code>, <code>label</code>, <code>labelcolor</code>, <code>labelcolor_active</code>, <code>labelcolor_hover</code>, <code>padding</code>, <code>strokecolor</code>, <code>strokewidth</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Camera"><a href="#Camera">Camera</a></div><div class="doc-content"><pre><code>Camera(pixel_area)</code></pre><p>Struct to hold all relevant matrices and additional parameters, to let backends apply camera based transformations.</p><h2>Fields</h2><ul><li><p><code>pixel_space::Observable{StaticArraysCore.SMatrix{4, 4, Float32, 16}}</code>: projection used to convert pixel to device units</p></li></ul><ul><li><p><code>view::Observable{StaticArraysCore.SMatrix{4, 4, Float32, 16}}</code>: View matrix is usually used to rotate, scale and translate the scene</p></li></ul><ul><li><p><code>projection::Observable{StaticArraysCore.SMatrix{4, 4, Float32, 16}}</code>: Projection matrix is used for any perspective transformation</p></li></ul><ul><li><p><code>projectionview::Observable{StaticArraysCore.SMatrix{4, 4, Float32, 16}}</code>: just projection * view</p></li></ul><ul><li><p><code>resolution::Observable{Vec{2, Float32}}</code>: resolution of the canvas this camera draws to</p></li></ul><ul><li><p><code>lookat::Observable{Vec{3, Float32}}</code>: Focal point of the camera, used for e.g. camera synchronized light direction.</p></li></ul><ul><li><p><code>eyeposition::Observable{Vec{3, Float32}}</code>: Eye position of the camera, used for e.g. ray tracing.</p></li></ul><ul><li><p><code>steering_nodes::Vector{Observables.ObserverFunction}</code>: To make camera interactive, steering observables are connected to the different matrices. We need to keep track of them, so, that we can connect and disconnect them.</p></li></ul><ul><li><p><code>calculated_values::Dict{Symbol, Observable}</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Camera2D"><a href="#Camera2D">Camera2D</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Camera2D</code></pre><h1>Fields</h1><pre><code>area          :: Observable{GeometryBasics.HyperRectangle{2, Float32}}
zoomspeed     :: Observable{Float32}
zoombutton    :: Observable{Union{Bool, Makie.Keyboard.Button, Makie.Mouse.Button, Tuple, Makie.BooleanOperator, Set, Vector}}
panbutton     :: Observable{Union{Bool, Makie.Keyboard.Button, Makie.Mouse.Button, Tuple, Makie.BooleanOperator, Set, Vector}}
padding       :: Observable{Float32}
last_area     :: Observable{Vec{2, Int64}}
update_limits :: Observable{Bool}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Camera2D &lt;: AbstractCamera &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Camera3D"><a href="#Camera3D">Camera3D</a></div><div class="doc-content"><pre><code>Camera3D(scene[; kwargs...])</code></pre><p>Sets up a 3D camera with mouse and keyboard controls.</p><p>The behavior of the camera can be adjusted via keyword arguments or the fields <code>settings</code> and <code>controls</code>.</p><h2>Settings</h2><p>Settings include anything that isn't a mouse or keyboard button.</p><ul><li><p><code>projectiontype = Perspective</code> sets the type of the projection. Can be <code>Orthographic</code> or <code>Perspective</code>.</p></li><li><p><code>rotation_center = :lookat</code> sets the default center for camera rotations. Currently allows <code>:lookat</code> or <code>:eyeposition</code>.</p></li><li><p><code>fixed_axis = true</code>: If true panning uses the (world/plot) z-axis instead of the camera up direction.</p></li><li><p><code>zoom_shift_lookat = true</code>: If true keeps the data under the cursor when zooming.</p></li><li><p><code>cad = false</code>: If true rotates the view around <code>lookat</code> when zooming off-center.</p></li><li><p><code>clipping_mode = :adaptive</code>: Controls how <code>near</code> and <code>far</code> get processed. Options:</p><ul><li><p><code>:static</code> passes <code>near</code> and <code>far</code> as is</p></li><li><p><code>:adaptive</code> scales <code>near</code> by <code>norm(eyeposition - lookat)</code> and passes <code>far</code> as is</p></li><li><p><code>:view_relative</code> scales <code>near</code> and <code>far</code> by <code>norm(eyeposition - lookat)</code></p></li><li><p><code>:bbox_relative</code> scales <code>near</code> and <code>far</code> to the scene bounding box as passed to the camera with <code>update_cam!(..., bbox)</code>. (More specifically <code>far = 1</code> is scaled to the furthest point of a bounding sphere and <code>near</code> is generally overwritten to be the closest point.)</p></li></ul></li><li><p><code>center = true</code>: Controls whether the camera placement gets reset when calling <code>center!(scene)</code>, which is called when a new plot is added.</p></li><li><p><code>keyboard_rotationspeed = 1f0</code> sets the speed of keyboard based rotations.</p></li><li><p><code>keyboard_translationspeed = 0.5f0</code> sets the speed of keyboard based translations.</p></li><li><p><code>keyboard_zoomspeed = 1f0</code> sets the speed of keyboard based zooms.</p></li><li><p><code>mouse_rotationspeed = 1f0</code> sets the speed of mouse rotations.</p></li><li><p><code>mouse_translationspeed = 0.5f0</code> sets the speed of mouse translations.</p></li><li><p><code>mouse_zoomspeed = 1f0</code> sets the speed of mouse zooming (mousewheel).</p></li><li><p><code>update_rate = 1/30</code> sets the rate at which keyboard based camera updates are evaluated.</p></li><li><p><code>circular_rotation = (true, true, true)</code> enables circular rotations for (fixed x, fixed y, fixed z) rotation axis. (This means drawing a circle with your mouse around the center of the scene will result in a continuous rotation.)</p></li></ul><h2>Controls</h2><p>Controls include any kind of hotkey setting.</p><ul><li><p><code>up_key   = Keyboard.r</code> sets the key for translations towards the top of the screen.</p></li><li><p><code>down_key = Keyboard.f</code> sets the key for translations towards the bottom of the screen.</p></li><li><p><code>left_key  = Keyboard.a</code> sets the key for translations towards the left of the screen.</p></li><li><p><code>right_key = Keyboard.d</code> sets the key for translations towards the right of the screen.</p></li><li><p><code>forward_key  = Keyboard.w</code> sets the key for translations into the screen.</p></li><li><p><code>backward_key = Keyboard.s</code> sets the key for translations out of the screen.</p></li><li><p><code>zoom_in_key   = Keyboard.u</code> sets the key for zooming into the scene (translate eyeposition towards lookat).</p></li><li><p><code>zoom_out_key  = Keyboard.o</code> sets the key for zooming out of the scene (translate eyeposition away from lookat).</p></li><li><p><code>increase_fov_key = Keyboard.b</code> sets the key for increasing the fov.</p></li><li><p><code>decrease_fov_key = Keyboard.n</code> sets the key for decreasing the fov.</p></li><li><p><code>pan_left_key  = Keyboard.j</code> sets the key for rotations around the screens vertical axis.</p></li><li><p><code>pan_right_key = Keyboard.l</code> sets the key for rotations around the screens vertical axis.</p></li><li><p><code>tilt_up_key   = Keyboard.i</code> sets the key for rotations around the screens horizontal axis.</p></li><li><p><code>tilt_down_key = Keyboard.k</code> sets the key for rotations around the screens horizontal axis.</p></li><li><p><code>roll_clockwise_key        = Keyboard.e</code> sets the key for rotations of the screen.</p></li><li><p><code>roll_counterclockwise_key = Keyboard.q</code> sets the key for rotations of the screen.</p></li><li><p><code>fix_x_key = Keyboard.x</code> sets the key for fixing translations and rotations to the (world/plot) x-axis.</p></li><li><p><code>fix_y_key = Keyboard.y</code> sets the key for fixing translations and rotations to the (world/plot) y-axis.</p></li><li><p><code>fix_z_key = Keyboard.z</code> sets the key for fixing translations and rotations to the (world/plot) z-axis.</p></li><li><p><code>reset = Keyboard.left_control &amp; Mouse.left</code> sets the key for resetting the camera. This equivalent to calling <code>center!(scene)</code>.</p></li><li><p><code>reposition_button = Keyboard.left_alt &amp; Mouse.left</code> sets the key for focusing the camera on a plot object.</p></li><li><p><code>translation_button = Mouse.right</code> sets the mouse button for drag-translations. (up/down/left/right)</p></li><li><p><code>scroll_mod = true</code> sets an additional modifier button for scroll-based zoom. (true being neutral)</p></li><li><p><code>rotation_button = Mouse.left</code> sets the mouse button for drag-rotations. (pan, tilt)</p></li></ul><h2>Other kwargs</h2><p>Some keyword arguments are used to initialize fields. These include</p><ul><li><p><code>eyeposition = Vec3f(3)</code>: The position of the camera.</p></li><li><p><code>lookat = Vec3f(0)</code>: The point the camera is focused on.</p></li><li><p><code>upvector = Vec3f(0, 0, 1)</code>: The world direction corresponding to the up direction of the screen.</p></li><li><p><code>fov = 45.0</code> is the field of view. This is irrelevant if the camera uses an orthographic projection.</p></li><li><p><code>near = automatic</code> sets the position of the near clip plane. Anything between the camera and the near clip plane is hidden. Must be greater 0. Usage depends on <code>clipping_mode</code>.</p></li><li><p><code>far = automatic</code> sets the position of the far clip plane. Anything further away than the far clip plane is hidden. Usage depends on <code>clipping_mode</code>. Defaults to <code>1</code> for <code>clipping_mode = :bbox_relative</code>, <code>2</code> for <code>:view_relative</code> or a value derived from limits for <code>:static</code>.</p></li></ul><p>Note that updating these observables in an active camera requires a call to <code>update_cam(scene)</code> for them to be applied. For updating <code>eyeposition</code>, <code>lookat</code> and/or upvector <code>update_cam!(scene, eyeposition, lookat, upvector = Vec3f(0,0,1))</code> is preferred.</p><p>The camera position and orientation can also be adjusted via the functions</p><ul><li><p><code>translate_cam!(scene, v)</code> will translate the camera by the given world/plot space vector <code>v</code>.</p></li><li><p><code>rotate_cam!(scene, angles)</code> will rotate the camera around its axes with the corresponding angles. The first angle will rotate around the cameras "right" that is the screens horizontal axis, the second around the up vector/vertical axis or <code>Vec3f(0, 0, +-1)</code> if <code>fixed_axis = true</code>, and the third will rotate around the view direction i.e. the axis out of the screen. The rotation respects the current <code>rotation_center</code> of the camera.</p></li><li><p><code>zoom!(scene, zoom_step)</code> will change the zoom level of the scene without translating or rotating the scene. <code>zoom_step</code> applies multiplicatively to <code>cam.zoom_mult</code> which is used as a multiplier to the fov (perspective projection) or width and height (orthographic projection).</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="CellGrid"><a href="#CellGrid">CellGrid</a></div><div class="doc-content"><pre><code>CellGrid() &lt;: GridBased &lt;: ConversionTrait</code></pre><p>Plots with the <code>CellGrid</code> trait convert their input data to <code>(xs::Vector{Float32}, ys::Vector{Float32}, zs::Matrix{Float32})</code> such that <code>(length(xs), length(ys)) == size(zs) .+ 1</code>. After the conversion the x and y values represent the edges of cells corresponding to z values.</p><p>See also: <a href="@ref"><code>VertexGrid</code></a>, <a href="@ref"><code>ImageLike</code></a> Used for: Heatmap</p></div></div><div class="docstring"><div class="doc-header" id="Circle"><a href="#Circle">Circle</a></div><div class="doc-content"><pre><code>HyperSphere{N, T}</code></pre><p>A <code>HyperSphere</code> is a generalization of a sphere into N-dimensions. A <code>center</code> and radius, <code>r</code>, must be specified.</p></div></div><div class="docstring"><div class="doc-header" id="ClosePath"><a href="#ClosePath">ClosePath</a></div><div class="doc-content"><pre><code>ClosePath()</code></pre><p>A path command for use within a <code>BezierPath</code> which closes the current subpath. The resulting path will have an implicit line segment between the last point and the first point if they do not match.</p></div></div><div class="docstring"><div class="doc-header" id="Colorbar"><a href="#Colorbar">Colorbar</a></div><div class="doc-content"><p><strong><code>Colorbar &lt;: Block</code></strong></p><p>Create a colorbar that shows a continuous or categorical colormap with ticks chosen according to the colorrange.</p><p>You can set colorrange and colormap manually, or pass a plot object as the second argument to copy its respective attributes.</p><h2>Constructors</h2><pre><code class="language-julia">Colorbar(fig_or_scene; kwargs...)
Colorbar(fig_or_scene, plot::AbstractPlot; kwargs...)
Colorbar(fig_or_scene, heatmap::Union{Heatmap, Image}; kwargs...)
Colorbar(fig_or_scene, contourf::Makie.Contourf; kwargs...)</code></pre><p><strong>Attributes</strong></p><p>(type <code>?Colorbar.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>bottomspinecolor</code>, <code>bottomspinevisible</code>, <code>colormap</code>, <code>colorrange</code>, <code>flip_vertical_label</code>, <code>flipaxis</code>, <code>halign</code>, <code>height</code>, <code>highclip</code>, <code>label</code>, <code>labelcolor</code>, <code>labelfont</code>, <code>labelpadding</code>, <code>labelrotation</code>, <code>labelsize</code>, <code>labelvisible</code>, <code>leftspinecolor</code>, <code>leftspinevisible</code>, <code>limits</code>, <code>lowclip</code>, <code>minortickalign</code>, <code>minortickcolor</code>, <code>minorticks</code>, <code>minorticksize</code>, <code>minorticksvisible</code>, <code>minortickwidth</code>, <code>nsteps</code>, <code>rightspinecolor</code>, <code>rightspinevisible</code>, <code>scale</code>, <code>size</code>, <code>spinewidth</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>tickalign</code>, <code>tickcolor</code>, <code>tickformat</code>, <code>ticklabelalign</code>, <code>ticklabelcolor</code>, <code>ticklabelfont</code>, <code>ticklabelpad</code>, <code>ticklabelrotation</code>, <code>ticklabelsize</code>, <code>ticklabelspace</code>, <code>ticklabelsvisible</code>, <code>ticks</code>, <code>ticksize</code>, <code>ticksvisible</code>, <code>tickwidth</code>, <code>topspinecolor</code>, <code>topspinevisible</code>, <code>valign</code>, <code>vertical</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Consume"><a href="#Consume">Consume</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Consume</code></pre><h1>Fields</h1><pre><code>x :: Bool</code></pre></div></div><div class="docstring"><div class="doc-header" id="Contour"><a href="#Contour">Contour</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Contour3d"><a href="#Contour3d">Contour3d</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Contourf"><a href="#Contourf">Contourf</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="ConversionTrait"><a href="#ConversionTrait">ConversionTrait</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type ConversionTrait</code></pre><h1>Subtypes</h1><pre><code>GridBased
ImageLike
Makie.SampleBased
NoConversion
PointBased
VolumeLike</code></pre></div></div><div class="docstring"><div class="doc-header" id="CrossBar"><a href="#CrossBar">CrossBar</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="CurveTo"><a href="#CurveTo">CurveTo</a></div><div class="doc-content"><pre><code>CurveTo(c1::VecTypes, c2::VecTypes, p::VecTypes)
CurveTo(cx1::Real, cy1::Real, cx2::Real, cy2::Real, px::Real, py::Real)</code></pre><p>A path command for use within a <code>BezierPath</code> which continues the current subpath with a cubic bezier curve to point <code>p</code>, with the first control point <code>c1</code> and the second control point <code>c2</code>. </p></div></div><div class="docstring"><div class="doc-header" id="Cycle"><a href="#Cycle">Cycle</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Cycle</code></pre><h1>Fields</h1><pre><code>cycle  :: Vector{Pair{Vector{Symbol}, Symbol}}
covary :: Bool</code></pre></div></div><div class="docstring"><div class="doc-header" id="Cycled"><a href="#Cycled">Cycled</a></div><div class="doc-content"><pre><code>Cycled(i::Int)</code></pre><p>If a <code>Cycled</code> value is passed as an attribute to a plotting function, it is replaced with the value from the cycler for this attribute (as long as there is one defined) at the index <code>i</code>.</p></div></div><div class="docstring"><div class="doc-header" id="DataAspect"><a href="#DataAspect">DataAspect</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct DataAspect</code></pre></div></div><div class="docstring"><div class="doc-header" id="DataInspector"><a href="#DataInspector">DataInspector</a></div><div class="doc-content"><pre><code>DataInspector(figure_axis_or_scene = current_figure(); kwargs...)</code></pre><p>Creates a data inspector which will show relevant information in a tooltip when you hover over a plot.</p><p>This functionality can be disabled on a per-plot basis by setting <code>plot.inspectable[] = false</code>. The displayed text can be adjusted by setting <code>plot.inspector_label</code> to a function <code>(plot, index, position) -&gt; "my_label"</code> returning a label. See Makie documentation for more detail.</p><h3>Keyword Arguments:</h3><ul><li><p><code>range = 10</code>: Controls the snapping range for selecting an element of a plot.</p></li><li><p><code>priority = 100</code>: The priority of creating a tooltip on a mouse movement or   scrolling event.</p></li><li><p><code>enabled = true</code>: Disables inspection of plots when set to false. Can also be   adjusted with <code>enable!(inspector)</code> and <code>disable!(inspector)</code>.</p></li><li><p><code>indicator_color = :red</code>: Color of the selection indicator.</p></li><li><p><code>indicator_linewidth = 2</code>: Linewidth of the selection indicator.</p></li><li><p><code>indicator_linestyle = nothing</code>: Linestyle of the selection indicator</p></li><li><p><code>enable_indicators = true)</code>: Enables or disables indicators</p></li><li><p><code>depth = 9e3</code>: Depth value of the tooltip. This should be high so that the   tooltip is always in front.</p></li><li><p><code>apply_tooltip_offset = true</code>: Enables or disables offsetting tooltips based   on, for example, markersize.</p></li><li><p>and all attributes from <code>Tooltip</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="DataShader"><a href="#DataShader">DataShader</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Density"><a href="#Density">Density</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="DirectionalLight"><a href="#DirectionalLight">DirectionalLight</a></div><div class="doc-content"><pre><code>DirectionalLight(color, direction[, camera_relative = false])</code></pre><p>A light type which simulates a distant light source with parallel light rays going in the given <code>direction</code>.</p><p>Availability:</p><ul><li><p>All backends with <code>shading = FastShading</code> or <code>MultiLightShading</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="ECDFPlot"><a href="#ECDFPlot">ECDFPlot</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="EllipticalArc"><a href="#EllipticalArc">EllipticalArc</a></div><div class="doc-content"><pre><code>EllipticalArc(c::VecTypes, r1::Real, r2::Real, angle::Real, a1::Real, a2::Real)
EllipticalArc(cx::Real, cy::Real, r1::Real, r2::Real, angle::Real, a1::Real, a2::Real)</code></pre><p>A path command for use within a <code>BezierPath</code> which continues the current subpath with an elliptical arc. The ellipse is centered at <code>c</code> and has two radii, <code>r1</code> and <code>r2</code>, the orientation of which depends on <code>angle</code>.</p><p>If <code>angle == 0</code>, <code>r1</code> goes in x direction and <code>r2</code> in y direction. A positive <code>angle</code> in radians rotates the ellipse counterclockwise, and a negative <code>angle</code> clockwise.</p><p>The angles <code>a1</code> and <code>a2</code> are the start and stop positions of the arc on the ellipse. A value of <code>0</code> is where the radius <code>r1</code> points to, <code>pi/2</code> is where the radius <code>r2</code> points to, and so on. If <code>a2 &gt; a1</code>, the arc turns counterclockwise. If <code>a1 &gt; a2</code>, it turns clockwise.</p><p>If the last position of the subpath does not equal the start of the arc, the resulting path will have an implicit line segment between the two.</p><pre><code>EllipticalArc(x1::Real, y1::Real, x2::Real, y2::Real, rx::Real, ry::Real, Ï::Real, largearc::Bool, sweepflag::Bool)</code></pre><p>Construct an <code>EllipticalArc</code> using the endpoint parameterization.</p><p><code>x1, y1</code> is the starting point and <code>x2, y2</code> the end point, <code>rx</code> and <code>ry</code> are the two ellipse radii. <code>Ï</code> is the angle of <code>rx</code> vs the x axis.</p><p>Usually, four arcs can be constructed between two points given these ellipse parameters. One of them is chosen using two boolean flags:</p><p>If <code>largearc === true</code>, the arc will be longer than 180 degrees. If <code>sweepflag === true</code>, the arc will sweep through increasing angles.  </p></div></div><div class="docstring"><div class="doc-header" id="EmptyCamera"><a href="#EmptyCamera">EmptyCamera</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct EmptyCamera</code></pre><h1>Supertype Hierarchy</h1><pre><code>EmptyCamera &lt;: AbstractCamera &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="EnvironmentLight"><a href="#EnvironmentLight">EnvironmentLight</a></div><div class="doc-content"><pre><code>EnvironmentLight(intensity, image)</code></pre><p>An environment light that uses a spherical environment map to provide lighting. See: https://en.wikipedia.org/wiki/Reflection_mapping</p><p>Availability:</p><ul><li><p>RPRMakie</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Errorbars"><a href="#Errorbars">Errorbars</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Events"><a href="#Events">Events</a></div><div class="doc-content"><p>This struct provides accessible <code>Observable</code>s to monitor the events associated with a Scene.</p><p>Functions that act on an <code>Observable</code> must return <code>Consume()</code> if the function consumes an event. When an event is consumed it does not trigger other observer functions. The order in which functions are executed can be controlled via the <code>priority</code> keyword (default 0) in <code>on</code>.</p><p>Example:</p><pre><code>on(events(scene).mousebutton, priority = 20) do event
    if is_correct_event(event)
        do_something()
        return Consume()
    end
    return
end</code></pre><h2>Fields</h2><ul><li><p><code>window_area::Observable{GeometryBasics.HyperRectangle{2, Int64}}</code>: The area of the window in pixels, as a <code>Rect2</code>.</p></li></ul><ul><li><p><code>window_dpi::Observable{Float64}</code>: The DPI resolution of the window, as a <code>Float64</code>.</p></li></ul><ul><li><p><code>window_open::Observable{Bool}</code>: The state of the window (open =&gt; true, closed =&gt; false).</p></li></ul><ul><li><p><code>mousebutton::Observable{Makie.MouseButtonEvent}</code>: Most recently triggered <code>MouseButtonEvent</code>. Contains the relevant <code>event.button</code> and <code>event.action</code> (press/release)</p><p>See also <a href="@ref"><code>ispressed</code></a>.</p></li></ul><ul><li><p><code>mousebuttonstate::Set{Makie.Mouse.Button}</code>: A Set of all currently pressed mousebuttons.</p></li></ul><ul><li><p><code>mouseposition::Observable{Tuple{Float64, Float64}}</code>: The position of the mouse as a <code>NTuple{2, Float64}</code>. Updates once per event poll/frame.</p></li></ul><ul><li><p><code>scroll::Observable{Tuple{Float64, Float64}}</code>: The direction of scroll</p></li></ul><ul><li><p><code>keyboardbutton::Observable{Makie.KeyEvent}</code>: Most recently triggered <code>KeyEvent</code>. Contains the relevant <code>event.key</code> and <code>event.action</code> (press/repeat/release)</p><p>See also <a href="@ref"><code>ispressed</code></a>.</p></li></ul><ul><li><p><code>keyboardstate::Set{Makie.Keyboard.Button}</code>: Contains all currently pressed keys.</p></li></ul><ul><li><p><code>unicode_input::Observable{Char}</code>: Contains the last typed character.</p></li></ul><ul><li><p><code>dropped_files::Observable{Vector{String}}</code>: Contains a list of filepaths to files dragged into the scene.</p></li></ul><ul><li><p><code>hasfocus::Observable{Bool}</code>: Whether the Scene window is in focus or not.</p></li></ul><ul><li><p><code>entered_window::Observable{Bool}</code>: Whether the mouse is inside the window or not.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Exclusively"><a href="#Exclusively">Exclusively</a></div><div class="doc-content"><pre><code>Exclusively(x)</code></pre><p>Marks a button, button collection or logical expression of buttons as the exclusive subset of buttons that must be pressed for <code>ispressed</code> to return true.</p><p>For example <code>Exclusively((Keyboard.left_control, Keyboard.c))</code> would require left control and c to be pressed without any other buttons.</p><p>Boolean expressions are lowered to multiple <code>Exclusive</code> sets in an <code>Or</code>. It is worth noting that <code>Not</code> branches are ignored here, i.e. it assumed that every button under a <code>Not</code> must not be pressed and that this follows automatically from the subset of buttons that must be pressed.</p><p>See also: <a href="@ref"><code>And</code></a>, <a href="@ref"><code>Or</code></a>, <a href="@ref"><code>Not</code></a>, <a href="@ref"><code>ispressed</code></a>, <a href="@ref"><code>&amp;</code></a>, <a href="@ref"><code>|</code></a>, <a href="@ref"><code>!</code></a></p></div></div><div class="docstring"><div class="doc-header" id="FastShading"><a href="#FastShading">FastShading</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type MakieCore.ShadingAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>MakieCore.ShadingAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Figure"><a href="#Figure">Figure</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Figure</code></pre><h1>Fields</h1><pre><code>scene        :: Scene
layout       :: GridLayout
content      :: Vector
attributes   :: Attributes
current_axis :: Ref{Any}</code></pre></div></div><div class="docstring"><div class="doc-header" id="Fixed"><a href="#Fixed">Fixed</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Fixed</code></pre><h1>Fields</h1><pre><code>x :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="GridBased"><a href="#GridBased">GridBased</a></div><div class="doc-content"><pre><code>GridBased &lt;: ConversionTrait</code></pre><p>GridBased is an abstract conversion trait for data that exists on a grid.</p><p>Child types: <a href="@ref"><code>VertexGrid</code></a>, <a href="@ref"><code>CellGrid</code></a> See also: <a href="@ref"><code>ImageLike</code></a> Used for: Scatter, Lines</p></div></div><div class="docstring"><div class="doc-header" id="GridLayout"><a href="#GridLayout">GridLayout</a></div><div class="doc-content"><pre><code>GridLayout(; kwargs...)</code></pre><p>Create a <code>GridLayout</code> without parent and with size [1, 1].</p><pre><code>GridLayout(g::Union{GridPosition, GridSubposition}, args...; kwargs...)</code></pre><p>Create a <code>GridLayout</code> at position <code>g</code> in the parent <code>GridLayout</code> of <code>g</code> if it is a <code>GridPosition</code> and in a nested child <code>GridLayout</code> if it is a <code>GridSubposition</code>. The <code>args</code> and <code>kwargs</code> are passed on to the normal <code>GridLayout</code> constructor.</p><pre><code>function GridLayout(nrows::Integer, ncols::Integer;
    parent = nothing,
    rowsizes = nothing,
    colsizes = nothing,
    addedrowgaps = nothing,
    addedcolgaps = nothing,
    alignmode = Inside(),
    equalprotrusiongaps = (false, false),
    bbox = nothing,
    width = Auto(),
    height = Auto(),
    tellwidth::Bool = true,
    tellheight::Bool = true,
    halign = :center,
    valign = :center,
    default_rowgap = get_default_rowgap(),
    default_colgap = get_default_colgap(),
    kwargs...)</code></pre><p>Create a <code>GridLayout</code> with optional parent <code>parent</code> with <code>nrows</code> rows and <code>ncols</code> columns.</p></div></div><div class="docstring"><div class="doc-header" id="GridPosition"><a href="#GridPosition">GridPosition</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridPosition</code></pre><h1>Fields</h1><pre><code>layout :: GridLayout
span   :: GridLayoutBase.Span
side   :: GridLayoutBase.Side</code></pre></div></div><div class="docstring"><div class="doc-header" id="GridSubposition"><a href="#GridSubposition">GridSubposition</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridSubposition</code></pre><h1>Fields</h1><pre><code>parent :: Union{GridPosition, GridSubposition}
rows   :: Any
cols   :: Any
side   :: GridLayoutBase.Side</code></pre></div></div><div class="docstring"><div class="doc-header" id="HLines"><a href="#HLines">HLines</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="HSpan"><a href="#HSpan">HSpan</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Heatmap"><a href="#Heatmap">Heatmap</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Hexbin"><a href="#Hexbin">Hexbin</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Hist"><a href="#Hist">Hist</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Image"><a href="#Image">Image</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="ImageLike"><a href="#ImageLike">ImageLike</a></div><div class="doc-content"><pre><code>ImageLike() &lt;: ConversionTrait</code></pre><p>Plots with the <code>ImageLike</code> trait convert their input data to <code>(xs::Interval, ys::Interval, zs::Matrix{Float32})</code> where xs and ys mark the limits of a quad containing zs.</p><p>See also: <a href="@ref"><code>CellGrid</code></a>, <a href="@ref"><code>VertexGrid</code></a> Used for: Image</p></div></div><div class="docstring"><div class="doc-header" id="IndexedAbsorptionRGBA"><a href="#IndexedAbsorptionRGBA">IndexedAbsorptionRGBA</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Inside"><a href="#Inside">Inside</a></div><div class="doc-content"><p>AlignMode that excludes the protrusions from the bounding box. Construct with <code>Inside()</code>.</p><p>See also <code>Outside</code> and <code>Mixed</code>.</p></div></div><div class="docstring"><div class="doc-header" id="IntervalSlider"><a href="#IntervalSlider">IntervalSlider</a></div><div class="doc-content"><p><strong><code>IntervalSlider &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?IntervalSlider.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>color_active</code>, <code>color_active_dimmed</code>, <code>color_inactive</code>, <code>halign</code>, <code>height</code>, <code>horizontal</code>, <code>interval</code>, <code>linewidth</code>, <code>range</code>, <code>snap</code>, <code>startvalues</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="IntervalsBetween"><a href="#IntervalsBetween">IntervalsBetween</a></div><div class="doc-content"><pre><code>IntervalsBetween(n::Int, mirror::Bool = true)</code></pre><p>Indicates to create n-1 minor ticks between every pair of adjacent major ticks.</p></div></div><div class="docstring"><div class="doc-header" id="IsoValue"><a href="#IsoValue">IsoValue</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="KeysEvent"><a href="#KeysEvent">KeysEvent</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct KeysEvent</code></pre><h1>Fields</h1><pre><code>keys :: Set{Makie.Keyboard.Button}</code></pre></div></div><div class="docstring"><div class="doc-header" id="LScene"><a href="#LScene">LScene</a></div><div class="doc-content"><p><strong><code>LScene &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?LScene.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>halign</code>, <code>height</code>, <code>show_axis</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Label"><a href="#Label">Label</a></div><div class="doc-content"><p><strong><code>Label &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Label.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>color</code>, <code>font</code>, <code>fontsize</code>, <code>halign</code>, <code>height</code>, <code>justification</code>, <code>lineheight</code>, <code>padding</code>, <code>rotation</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>text</code>, <code>valign</code>, <code>visible</code>, <code>width</code>, <code>word_wrap</code></p></div></div><div class="docstring"><div class="doc-header" id="LayoutObservables"><a href="#LayoutObservables">LayoutObservables</a></div><div class="doc-content"><pre><code>struct LayoutObservables{G}</code></pre><p><code>T</code> is the same type parameter of contained <code>GridContent</code>, <code>G</code> is <code>GridLayout</code> which is defined only after <code>LayoutObservables</code>.</p><p>A collection of <code>Observable</code>s and an optional <code>GridContent</code> that are needed to interface with the MakieLayout layouting system.</p><ul><li><p><code>suggestedbbox::Observable{Rect2f}</code>: The bounding box that an element should place itself in. Depending on the element's <code>width</code> and <code>height</code> attributes, this is not necessarily equal to the computedbbox.</p></li><li><p><code>protrusions::Observable{RectSides{Float32}}</code>: The sizes of content "sticking out" of the main element into the <code>GridLayout</code> gaps.</p></li><li><p><code>reporteddimensions::Observable{Dimensions}</code>: The dimensions (inner and outer) that the object communicates to the containing <code>GridLayout</code>.</p></li><li><p><code>autosize::Observable{NTuple{2, Optional{Float32}}}</code>: The width and height that the element reports to its parent <code>GridLayout</code>. If the element doesn't want to cause the parent to adjust to its size, autosize can hide the reportedsize from it by being set to <code>nothing</code>.</p></li><li><p><code>computedbbox::Observable{Rect2f}</code>: The bounding box that the element computes for itself after it has received a suggestedbbox.</p></li><li><p><code>gridcontent::Optional{GridContent{G}}</code>: A reference of a <code>GridContent</code> if the element is currently placed in a <code>GridLayout</code>. This can be used to retrieve the parent layout, remove the element from it or change its position, and assign it to a different layout.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Left"><a href="#Left">Left</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Left</code></pre><h1>Supertype Hierarchy</h1><pre><code>Left &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Legend"><a href="#Legend">Legend</a></div><div class="doc-content"><p><strong><code>Legend &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Legend.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>backgroundcolor</code>, <code>bgcolor</code>, <code>colgap</code>, <code>framecolor</code>, <code>framevisible</code>, <code>framewidth</code>, <code>gridshalign</code>, <code>gridsvalign</code>, <code>groupgap</code>, <code>halign</code>, <code>height</code>, <code>label</code>, <code>labelcolor</code>, <code>labelfont</code>, <code>labelhalign</code>, <code>labeljustification</code>, <code>labelsize</code>, <code>labelvalign</code>, <code>linecolor</code>, <code>linecolormap</code>, <code>linecolorrange</code>, <code>linepoints</code>, <code>linestyle</code>, <code>linewidth</code>, <code>margin</code>, <code>marker</code>, <code>markercolor</code>, <code>markercolormap</code>, <code>markercolorrange</code>, <code>markerpoints</code>, <code>markersize</code>, <code>markerstrokecolor</code>, <code>markerstrokewidth</code>, <code>nbanks</code>, <code>orientation</code>, <code>padding</code>, <code>patchcolor</code>, <code>patchlabelgap</code>, <code>patchsize</code>, <code>patchstrokecolor</code>, <code>patchstrokewidth</code>, <code>polycolor</code>, <code>polycolormap</code>, <code>polycolorrange</code>, <code>polypoints</code>, <code>polystrokecolor</code>, <code>polystrokewidth</code>, <code>rowgap</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>titlecolor</code>, <code>titlefont</code>, <code>titlegap</code>, <code>titlehalign</code>, <code>titleposition</code>, <code>titlesize</code>, <code>titlevalign</code>, <code>titlevisible</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="LegendElement"><a href="#LegendElement">LegendElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type LegendElement</code></pre><h1>Subtypes</h1><pre><code>LineElement
MarkerElement
PolyElement</code></pre></div></div><div class="docstring"><div class="doc-header" id="LegendEntry"><a href="#LegendEntry">LegendEntry</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct LegendEntry</code></pre><h1>Fields</h1><pre><code>elements   :: Vector{LegendElement}
attributes :: Attributes</code></pre></div></div><div class="docstring"><div class="doc-header" id="LineElement"><a href="#LineElement">LineElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct LineElement</code></pre><h1>Fields</h1><pre><code>attributes :: Attributes</code></pre><h1>Supertype Hierarchy</h1><pre><code>LineElement &lt;: LegendElement &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="LineSegments"><a href="#LineSegments">LineSegments</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="LineTo"><a href="#LineTo">LineTo</a></div><div class="doc-content"><pre><code>LineTo(p::VecTypes)
LineTo(x::Real, y::Real)</code></pre><p>A path command for use within a <code>BezierPath</code> which continues the current subpath with a line to the given point.</p></div></div><div class="docstring"><div class="doc-header" id="LinearTicks"><a href="#LinearTicks">LinearTicks</a></div><div class="doc-content"><p>LinearTicks with ideally a number of <code>n_ideal</code> tick marks.</p></div></div><div class="docstring"><div class="doc-header" id="Lines"><a href="#Lines">Lines</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Linestyle"><a href="#Linestyle">Linestyle</a></div><div class="doc-content"><pre><code>Linestyle(value::Vector{&lt;:Real})</code></pre><p>A type that can be used as value for the <code>linestyle</code> keyword argument of plotting functions to arbitrarily customize the linestyle.</p><p>The <code>value</code> is a vector of positions where the line flips from being drawn or not and vice versa. The values of <code>value</code> are in units of linewidth.</p><p>For example, with <code>value = [0.0, 4.0, 6.0, 9.5]</code> you start drawing at 0, stop at 4 linewidths, start again at 6, stop at 9.5, then repeat with 0 and 9.5 being treated as the same position.</p></div></div><div class="docstring"><div class="doc-header" id="LogTicks"><a href="#LogTicks">LogTicks</a></div><div class="doc-content"><pre><code>LogTicks{T}(linear_ticks::T)</code></pre><p>Wraps any other tick object. Used to apply a linear tick searching algorithm on a log-transformed interval.</p></div></div><div class="docstring"><div class="doc-header" id="MakieScreen"><a href="#MakieScreen">MakieScreen</a></div><div class="doc-content"><p>Screen constructors implemented by all backends:</p><pre><code class="language-julia"># Constructor aimed at showing the plot in a window.
Screen(scene::Scene; screen_config...)

# Screen to save a png/jpeg to file or io
Screen(scene::Scene, io::IO, mime; screen_config...)

# Screen that is efficient for `colorbuffer(screen, format)`
Screen(scene::Scene, format::Makie.ImageStorageFormat; screen_config...)</code></pre><p>Interface implemented by all backends:</p><pre><code class="language-julia"># Needs to be overload:
size(screen) # Size in pixel
empty!(screen) # empties screen state to reuse the screen, or to close it

# Optional
wait(screen) # waits as long window is open

# Provided by Makie:
push_screen!(scene, screen)</code></pre></div></div><div class="docstring"><div class="doc-header" id="MarkerElement"><a href="#MarkerElement">MarkerElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct MarkerElement</code></pre><h1>Fields</h1><pre><code>attributes :: Attributes</code></pre><h1>Supertype Hierarchy</h1><pre><code>MarkerElement &lt;: LegendElement &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="MaximumIntensityProjection"><a href="#MaximumIntensityProjection">MaximumIntensityProjection</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Menu"><a href="#Menu">Menu</a></div><div class="doc-content"><p><strong><code>Menu &lt;: Block</code></strong></p><p>A drop-down menu with multiple selectable options. You can pass options with the keyword argument <code>options</code>.</p><p>Options are given as an iterable of elements. For each element, the option label in the menu is determined with <code>optionlabel(element)</code> and the option value with <code>optionvalue(element)</code>. These functions can be overloaded for custom types. The default is that tuples of two elements are expected to be label and value, where <code>string(label)</code> is used as the label, while for all other objects, label = <code>string(object)</code> and value = object.</p><p>When an item is selected in the menu, the menu's <code>selection</code> attribute is set to <code>optionvalue(selected_element)</code>. When nothing is selected, that value is <code>nothing</code>.</p><p>You can set the initial selection by passing one of the labels with the <code>default</code> keyword.</p><h2>Constructors</h2><pre><code class="language-julia">Menu(fig_or_scene; default = nothing, kwargs...)</code></pre><h2>Examples</h2><p>Menu with string entries, second preselected:</p><pre><code class="language-julia">menu1 = Menu(fig[1, 1], options = ["first", "second", "third"], default = "second")</code></pre><p>Menu with two-element entries, label and function:</p><pre><code class="language-julia">funcs = [sin, cos, tan]
labels = ["Sine", "Cosine", "Tangens"]

menu2 = Menu(fig[1, 1], options = zip(labels, funcs))</code></pre><p>Executing a function when a selection is made:</p><pre><code class="language-julia">on(menu2.selection) do selected_function
    # do something with the selected function
end</code></pre><p><strong>Attributes</strong></p><p>(type <code>?Menu.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>cell_color_active</code>, <code>cell_color_hover</code>, <code>cell_color_inactive_even</code>, <code>cell_color_inactive_odd</code>, <code>direction</code>, <code>dropdown_arrow_color</code>, <code>dropdown_arrow_size</code>, <code>fontsize</code>, <code>halign</code>, <code>height</code>, <code>i_selected</code>, <code>is_open</code>, <code>options</code>, <code>prompt</code>, <code>scroll_speed</code>, <code>selection</code>, <code>selection_cell_color_inactive</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>textcolor</code>, <code>textpadding</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Mesh"><a href="#Mesh">Mesh</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="MeshScatter"><a href="#MeshScatter">MeshScatter</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Mixed"><a href="#Mixed">Mixed</a></div><div class="doc-content"><p>AlignMode that is <code>Inside</code> where <code>padding</code> is <code>Nothing</code>, <code>Outside</code> where it is <code>Real</code>, and overrides the protrusion with a fixed value where it is a <code>Protrusion</code>.</p><p>See also <code>Inside</code> and <code>Outside</code>.</p><pre><code>Mixed(; left = nothing, right = nothing, bottom = nothing, top = nothing)</code></pre><p>Construct a <code>Mixed</code> AlignMode, which has different behavior on each side. Arguments that are <code>nothing</code> will exclude protrusions from the bounding box on that side. Those that are real numbers will be padded by that amount and include protrusions from the bounding box on that side. Arguments that are <code>Protrusion</code> will override the protrusion with a fixed value.</p></div></div><div class="docstring"><div class="doc-header" id="MouseEvent"><a href="#MouseEvent">MouseEvent</a></div><div class="doc-content"><pre><code>MouseEvent</code></pre><p>Describes a mouse state change. Fields:</p><ul><li><p><code>type</code>: MouseEventType</p></li><li><p><code>t</code>: Time of the event</p></li><li><p><code>data</code>: Mouse position in data coordinates</p></li><li><p><code>px</code>: Mouse position in px relative to scene origin</p></li><li><p><code>prev_t</code>: Time of previous event</p></li><li><p><code>prev_data</code>: Previous mouse position in data coordinates</p></li><li><p><code>prev_px</code>: Previous mouse position in data coordinates</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="MoveTo"><a href="#MoveTo">MoveTo</a></div><div class="doc-content"><pre><code>MoveTo(p::VecTypes)
MoveTo(x::Real, y::Real)</code></pre><p>A path command for use within a <code>BezierPath</code> which starts a new subpath at the given point.</p></div></div><div class="docstring"><div class="doc-header" id="MultiLightShading"><a href="#MultiLightShading">MultiLightShading</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type MakieCore.ShadingAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>MakieCore.ShadingAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="MultiplesTicks"><a href="#MultiplesTicks">MultiplesTicks</a></div><div class="doc-content"><p>Like LinearTicks but for multiples of <code>multiple</code>. Example where approximately 5 numbers should be found that are multiples of pi, printed like "1Ï", "2Ï", etc.:</p><pre><code>MultiplesTicks(5, pi, "Ï")</code></pre></div></div><div class="docstring"><div class="doc-header" id="NoConversion"><a href="#NoConversion">NoConversion</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct NoConversion</code></pre><h1>Supertype Hierarchy</h1><pre><code>NoConversion &lt;: ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="NoShading"><a href="#NoShading">NoShading</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type MakieCore.ShadingAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>MakieCore.ShadingAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Observable"><a href="#Observable">Observable</a></div><div class="doc-content"><pre><code>obs = Observable(val; ignore_equal_values=false)
obs = Observable{T}(val; ignore_equal_values=false)</code></pre><p>Like a <code>Ref</code>, but updates can be watched by adding a handler using <a href="@ref"><code>on</code></a> or <a href="@ref"><code>map</code></a>. Set <code>ignore_equal_values=true</code> to not trigger an event for <code>observable[] = new_value</code> if <code>isequal(observable[], new_value)</code>.</p></div></div><div class="docstring"><div class="doc-header" id="OldAxis"><a href="#OldAxis">OldAxis</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct OldAxis</code></pre></div></div><div class="docstring"><div class="doc-header" id="Outside"><a href="#Outside">Outside</a></div><div class="doc-content"><p>AlignMode that includes the protrusions within the bounding box, plus paddings.</p><p>See also <code>Inside</code> and <code>Mixed</code>.</p><pre><code>Outside()</code></pre><p>Construct an <code>Outside</code> AlignMode with no padding.</p><pre><code>Outside(padding::Real)</code></pre><p>Construct an <code>Outside</code> AlignMode with equal padding on all sides.</p><pre><code>Outside(left::Real, right::Real, bottom::Real, top::Real)</code></pre><p>Construct an <code>Outside</code> AlignMode with different paddings on each side.</p></div></div><div class="docstring"><div class="doc-header" id="Pattern"><a href="#Pattern">Pattern</a></div><div class="doc-content"><pre><code>Pattern(image)
Pattern(mask[; color1, color2])</code></pre><p>Creates an <code>ImagePattern</code> from an <code>image</code> (a matrix of colors) or a <code>mask</code> (a matrix of real numbers). The pattern can be passed as a <code>color</code> to a plot to texture it. If a <code>mask</code> is passed, one can specify to colors between which colors are interpolated.</p><pre><code>Pattern(style::String = "/"; kwargs...)
Pattern(style::Char = '/'; kwargs...)</code></pre><p>Creates a line pattern based on the given argument. Available patterns are <code>'/'</code>, <code>'\'</code>, <code>'-'</code>, <code>'|'</code>, <code>'x'</code>, and <code>'+'</code>. All keyword arguments correspond to the keyword arguments for <a href="@ref"><code>LinePattern</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="Pie"><a href="#Pie">Pie</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Pixel"><a href="#Pixel">Pixel</a></div><div class="doc-content"><p>Unit in pixels on screen. This one is a bit tricky, since it refers to a static attribute (pixels on screen don't change) but since every visual is attached to a camera, the exact scale might change. So in the end, this is just relative to some normed camera - the value on screen, depending on the camera, will not actually sit on those pixels. Only camera that guarantees the correct mapping is the <code>:pixel</code> camera type.</p></div></div><div class="docstring"><div class="doc-header" id="PixelSpace"><a href="#PixelSpace">PixelSpace</a></div><div class="doc-content"><p>Unit in pixels on screen. This one is a bit tricky, since it refers to a static attribute (pixels on screen don't change) but since every visual is attached to a camera, the exact scale might change. So in the end, this is just relative to some normed camera - the value on screen, depending on the camera, will not actually sit on those pixels. Only camera that guarantees the correct mapping is the <code>:pixel</code> camera type.</p></div></div><div class="docstring"><div class="doc-header" id="Plot"><a href="#Plot">Plot</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="PlotList"><a href="#PlotList">PlotList</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="PlotSpec"><a href="#PlotSpec">PlotSpec</a></div><div class="doc-content"><pre><code>PlotSpec(plottype, args...; kwargs...)</code></pre><p>Object encoding positional arguments (<code>args</code>), a <code>NamedTuple</code> of attributes (<code>kwargs</code>) as well as plot type <code>P</code> of a basic plot.</p></div></div><div class="docstring"><div class="doc-header" id="Point"><a href="#Point">Point</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point2"><a href="#Point2">Point2</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point2f"><a href="#Point2f">Point2f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point3"><a href="#Point3">Point3</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point3f"><a href="#Point3f">Point3f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point4"><a href="#Point4">Point4</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point4f"><a href="#Point4f">Point4f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="PointBased"><a href="#PointBased">PointBased</a></div><div class="doc-content"><pre><code>PointBased() &lt;: ConversionTrait</code></pre><p>Plots with the <code>PointBased</code> trait convert their input data to a <code>Vector{Point{D, Float32}}</code>.</p></div></div><div class="docstring"><div class="doc-header" id="PointLight"><a href="#PointLight">PointLight</a></div><div class="doc-content"><pre><code>PointLight(color, position[, attenuation = Vec2f(0)])
PointLight(color, position, range::Real)</code></pre><p>A point-like light source placed at the given <code>position</code> with the given light <code>color</code>.</p><p>Optionally an attenuation parameter can be used to reduce the brightness of the light source with distance. The reduction is given by <code>1 / (1 + attenuation[1] * distance + attenuation[2] * distance^2)</code>. Alternatively you can pass a light <code>range</code> to generate matching default attenuation parameters. Note that you may need to set the light intensity, i.e. the light color to values greater than 1 to get satisfying results.</p><p>Availability:</p><ul><li><p>GLMakie with <code>shading = MultiLightShading</code></p></li><li><p>RPRMakie</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="PolarAxis"><a href="#PolarAxis">PolarAxis</a></div><div class="doc-content"><p><strong><code>PolarAxis &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?PolarAxis.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>axis_rotation_button</code>, <code>backgroundcolor</code>, <code>clip</code>, <code>clip_r</code>, <code>clipcolor</code>, <code>direction</code>, <code>fixrmin</code>, <code>gridz</code>, <code>halign</code>, <code>height</code>, <code>normalize_theta_ticks</code>, <code>r_translation_button</code>, <code>radius_at_origin</code>, <code>rautolimitmargin</code>, <code>reset_axis_orientation</code>, <code>reset_button</code>, <code>rgridcolor</code>, <code>rgridstyle</code>, <code>rgridvisible</code>, <code>rgridwidth</code>, <code>rlimits</code>, <code>rminorgridcolor</code>, <code>rminorgridstyle</code>, <code>rminorgridvisible</code>, <code>rminorgridwidth</code>, <code>rminorticks</code>, <code>rtickangle</code>, <code>rtickformat</code>, <code>rticklabelcolor</code>, <code>rticklabelfont</code>, <code>rticklabelpad</code>, <code>rticklabelrotation</code>, <code>rticklabelsize</code>, <code>rticklabelstrokecolor</code>, <code>rticklabelstrokewidth</code>, <code>rticklabelsvisible</code>, <code>rticks</code>, <code>rzoomkey</code>, <code>rzoomlock</code>, <code>sample_density</code>, <code>spinecolor</code>, <code>spinestyle</code>, <code>spinevisible</code>, <code>spinewidth</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>theta_0</code>, <code>theta_as_x</code>, <code>theta_translation_button</code>, <code>thetaautolimitmargin</code>, <code>thetagridcolor</code>, <code>thetagridstyle</code>, <code>thetagridvisible</code>, <code>thetagridwidth</code>, <code>thetalimits</code>, <code>thetaminorgridcolor</code>, <code>thetaminorgridstyle</code>, <code>thetaminorgridvisible</code>, <code>thetaminorgridwidth</code>, <code>thetaminorticks</code>, <code>thetatickformat</code>, <code>thetaticklabelcolor</code>, <code>thetaticklabelfont</code>, <code>thetaticklabelpad</code>, <code>thetaticklabelsize</code>, <code>thetaticklabelstrokecolor</code>, <code>thetaticklabelstrokewidth</code>, <code>thetaticklabelsvisible</code>, <code>thetaticks</code>, <code>thetazoomkey</code>, <code>thetazoomlock</code>, <code>title</code>, <code>titlealign</code>, <code>titlecolor</code>, <code>titlefont</code>, <code>titlegap</code>, <code>titlesize</code>, <code>titlevisible</code>, <code>valign</code>, <code>width</code>, <code>zoomspeed</code></p></div></div><div class="docstring"><div class="doc-header" id="Poly"><a href="#Poly">Poly</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="PolyElement"><a href="#PolyElement">PolyElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct PolyElement</code></pre><h1>Fields</h1><pre><code>attributes :: Attributes</code></pre><h1>Supertype Hierarchy</h1><pre><code>PolyElement &lt;: LegendElement &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="QQNorm"><a href="#QQNorm">QQNorm</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="QQPlot"><a href="#QQPlot">QQPlot</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Quaternion"><a href="#Quaternion">Quaternion</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Quaternion{T}</code></pre><h1>Fields</h1><pre><code>data :: NTuple{4, T}</code></pre></div></div><div class="docstring"><div class="doc-header" id="Quaternionf"><a href="#Quaternionf">Quaternionf</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Quaternion{T}</code></pre><h1>Fields</h1><pre><code>data :: NTuple{4, T}</code></pre></div></div><div class="docstring"><div class="doc-header" id="RGBAf"><a href="#RGBAf">RGBAf</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct ColorTypes.RGBA{T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}}</code></pre><h1>Fields</h1><pre><code>r     :: T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}
g     :: T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}
b     :: T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}
alpha :: T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}</code></pre><h1>Supertype Hierarchy</h1><pre><code>ColorTypes.RGBA{T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}} &lt;: ColorTypes.ColorAlpha{ColorTypes.RGB{T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}}, T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}, 4} &lt;: ColorTypes.TransparentColor{ColorTypes.RGB{T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}}, T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}, 4} &lt;: ColorTypes.Colorant{T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}, 4} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="RGBf"><a href="#RGBf">RGBf</a></div><div class="doc-content"><p><code>RGB</code> is the standard Red-Green-Blue (sRGB) colorspace.  Values of the individual color channels range from 0 (black) to 1 (saturated). If you want "Integer" storage types (e.g., 255 for full color), use <code>N0f8(1)</code> instead (see FixedPointNumbers).</p></div></div><div class="docstring"><div class="doc-header" id="RainClouds"><a href="#RainClouds">RainClouds</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Rangebars"><a href="#Rangebars">Rangebars</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="RaymarchAlgorithm"><a href="#RaymarchAlgorithm">RaymarchAlgorithm</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="RealVector"><a href="#RealVector">RealVector</a></div><div class="doc-content"><pre><code>AbstractArray{T,N}</code></pre><p>Supertype for <code>N</code>-dimensional arrays (or array-like types) with elements of type <code>T</code>. <a href="@ref"><code>Array</code></a> and other types are subtypes of this. See the manual section on the <a href="@ref man-interface-array"><code>AbstractArray</code> interface</a>.</p><p>See also: <a href="@ref"><code>AbstractVector</code></a>, <a href="@ref"><code>AbstractMatrix</code></a>, <a href="@ref"><code>eltype</code></a>, <a href="@ref"><code>ndims</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="Record"><a href="#Record">Record</a></div><div class="doc-content"><pre><code>Record(func, figlike, [iter]; kw_args...)</code></pre><p>Check <a href="@ref"><code>Makie.record</code></a> for documentation.</p></div></div><div class="docstring"><div class="doc-header" id="RecordEvents"><a href="#RecordEvents">RecordEvents</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct RecordEvents</code></pre><h1>Fields</h1><pre><code>scene :: Scene
path  :: String</code></pre></div></div><div class="docstring"><div class="doc-header" id="Rect"><a href="#Rect">Rect</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect2"><a href="#Rect2">Rect2</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect2f"><a href="#Rect2f">Rect2f</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect2i"><a href="#Rect2i">Rect2i</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect3"><a href="#Rect3">Rect3</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect3f"><a href="#Rect3f">Rect3f</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect3i"><a href="#Rect3i">Rect3i</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="RectLight"><a href="#RectLight">RectLight</a></div><div class="doc-content"><pre><code>RectLight(color, r::Rect2[, direction = -normal])
RectLight(color, center::Point3f, b1::Vec3f, b2::Vec3f[, direction = -normal])</code></pre><p>Creates a RectLight with a given color. The first constructor derives the light from a <code>Rect2</code> extending in x and y directions. The second specifies the <code>center</code> of the rect (or more accurately parallelogram) with <code>b1</code> and <code>b2</code> specifying the width and height vectors (including scale).</p><p>Note that RectLight implements <code>translate!</code>, <code>rotate!</code> and <code>scale!</code> to simplify adjusting the light.</p><p>Availability:</p><ul><li><p>GLMakie with <code>Shading = MultiLightShading</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Rectf"><a href="#Rectf">Rectf</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Recti"><a href="#Recti">Recti</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Relative"><a href="#Relative">Relative</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Relative</code></pre><h1>Fields</h1><pre><code>x :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="Reverse"><a href="#Reverse">Reverse</a></div><div class="doc-content"><p>Reverses the attribute T upon conversion</p></div></div><div class="docstring"><div class="doc-header" id="ReversibleScale"><a href="#ReversibleScale">ReversibleScale</a></div><div class="doc-content"><pre><code>ReversibleScale</code></pre><p>Custom scale struct, taking a forward and inverse arbitrary scale function.</p><h2>Fields</h2><ul><li><p><code>forward::Function</code>: forward transformation (e.g. <code>log10</code>)</p></li></ul><ul><li><p><code>inverse::Function</code>: inverse transformation (e.g. <code>exp10</code> for <code>log10</code> such that inverse â forward â¡ identity)</p></li></ul><ul><li><p><code>limits::Tuple{Float32, Float32}</code>: default limits (optional)</p></li></ul><ul><li><p><code>interval::IntervalSets.AbstractInterval</code>: valid limits interval (optional)</p></li></ul><ul><li><p><code>name::Symbol</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Right"><a href="#Right">Right</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Right</code></pre><h1>Supertype Hierarchy</h1><pre><code>Right &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="SSAO"><a href="#SSAO">SSAO</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct SSAO</code></pre><h1>Fields</h1><pre><code>radius :: Observable{Float32}
bias   :: Observable{Float32}
blur   :: Observable{Int32}</code></pre></div></div><div class="docstring"><div class="doc-header" id="Scatter"><a href="#Scatter">Scatter</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="ScatterLines"><a href="#ScatterLines">ScatterLines</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Scene"><a href="#Scene">Scene</a></div><div class="doc-content"><pre><code>Scene TODO document this</code></pre><h2>Constructors</h2><h2>Fields</h2><ul><li><p><code>parent</code>: The parent of the Scene; if it is a top-level Scene, <code>parent == nothing</code>.</p></li><li><p><code>events</code>: <a href="@ref"><code>Events</code></a> associated with the Scene.</p></li><li><p><code>viewport</code>: The current pixel area of the Scene.</p></li><li><p><code>clear</code>: Whether the scene should be cleared.</p></li><li><p><code>camera</code>: The <code>Camera</code> associated with the Scene.</p></li><li><p><code>camera_controls</code>: The controls for the camera of the Scene.</p></li><li><p><code>transformation</code>: The <a href="@ref"><code>Transformation</code></a> of the Scene.</p></li><li><p><code>plots</code>: The plots contained in the Scene.</p></li><li><p><code>theme</code></p></li><li><p><code>children</code>: Children of the Scene inherit its transformation.</p></li><li><p><code>current_screens</code>: The Screens which the Scene is displayed to.</p></li></ul><ul><li><p><code>backgroundcolor</code></p></li><li><p><code>visible</code></p></li><li><p><code>ssao</code></p></li><li><p><code>lights</code></p></li><li><p><code>deregister_callbacks</code></p></li><li><p><code>cycler</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="SceneLike"><a href="#SceneLike">SceneLike</a></div><div class="doc-content"><pre><code>Union{Types...}</code></pre><p>A type union is an abstract type which includes all instances of any of its argument types. The empty union <a href="@ref"><code>Union{}</code></a> is the bottom type of Julia.</p><h1>Examples</h1><pre><code class="language-jldoctest">julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 isa IntOrString
true

julia&gt; "Hello!" isa IntOrString
true

julia&gt; 1.0 isa IntOrString
false</code></pre></div></div><div class="docstring"><div class="doc-header" id="SceneSpace"><a href="#SceneSpace">SceneSpace</a></div><div class="doc-content"><p>Unit space of the scene it's displayed on. Also referred to as data units</p></div></div><div class="docstring"><div class="doc-header" id="ScrollEvent"><a href="#ScrollEvent">ScrollEvent</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct ScrollEvent</code></pre><h1>Fields</h1><pre><code>x :: Float32
y :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="Series"><a href="#Series">Series</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Slider"><a href="#Slider">Slider</a></div><div class="doc-content"><p><strong><code>Slider &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Slider.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>color_active</code>, <code>color_active_dimmed</code>, <code>color_inactive</code>, <code>halign</code>, <code>height</code>, <code>horizontal</code>, <code>linewidth</code>, <code>range</code>, <code>snap</code>, <code>startvalue</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>value</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="SliderGrid"><a href="#SliderGrid">SliderGrid</a></div><div class="doc-content"><p><strong><code>SliderGrid &lt;: Block</code></strong></p><p>A grid of horizontal <code>Slider</code>s, where each slider has one name label on the left, and a value label on the right.</p><p>Each <code>NamedTuple</code> you pass specifies one <code>Slider</code>. You always have to pass <code>range</code> and <code>label</code>, and optionally a <code>format</code> for the value label. Beyond that, you can set any keyword that <code>Slider</code> takes, such as <code>startvalue</code>.</p><p>The <code>format</code> keyword can be a <code>String</code> with Format.jl style, such as "{:.2f}Hz", or a function.</p><h2>Constructors</h2><pre><code class="language-julia">SliderGrid(fig_or_scene, nts::NamedTuple...; kwargs...)</code></pre><h2>Examples</h2><pre><code class="language-julia">sg = SliderGrid(fig[1, 1],
    (label = "Amplitude", range = 0:0.1:10, startvalue = 5),
    (label = "Frequency", range = 0:0.5:50, format = "{:.1f}Hz", startvalue = 10),
    (label = "Phase", range = 0:0.01:2pi,
        format = x -&gt; string(round(x/pi, digits = 2), "Ï"))
)</code></pre><p>Working with slider values:</p><pre><code class="language-julia">on(sg.sliders[1].value) do val
    # do something with `val`
end</code></pre><p><strong>Attributes</strong></p><p>(type <code>?SliderGrid.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>halign</code>, <code>height</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>value_column_width</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Sphere"><a href="#Sphere">Sphere</a></div><div class="doc-content"><pre><code>HyperSphere{N, T}</code></pre><p>A <code>HyperSphere</code> is a generalization of a sphere into N-dimensions. A <code>center</code> and radius, <code>r</code>, must be specified.</p></div></div><div class="docstring"><div class="doc-header" id="SpotLight"><a href="#SpotLight">SpotLight</a></div><div class="doc-content"><pre><code>SpotLight(color, position, direction, angles)</code></pre><p>Creates a spot light which illuminates objects in a light cone starting at <code>position</code> pointing in <code>direction</code>. The opening angle is defined by an inner and outer angle given in <code>angles</code>, between which the light intensity drops off.</p><p>Availability:</p><ul><li><p>GLMakie with <code>shading = MultiLightShading</code></p></li><li><p>RPRMakie</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Spy"><a href="#Spy">Spy</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Stairs"><a href="#Stairs">Stairs</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Stem"><a href="#Stem">Stem</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="StepHist"><a href="#StepHist">StepHist</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Stepper"><a href="#Stepper">Stepper</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Stepper</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "Stepper" from Makie:
 [1] Stepper(figlike::Union{Figure, Makie.FigureAxisPlot, Scene}, path::String; kw...)
     @ ~/work/Makie.jl/Makie.jl/src/recording.jl:47
 [2] Stepper(figlike::Union{Figure, Makie.FigureAxisPlot, Scene}, path::String, step::Int64; format, backend, visible, connect, screen_kw...)
     @ ~/work/Makie.jl/Makie.jl/src/recording.jl:38
 [3] Stepper(figlike::Union{Figure, Makie.FigureAxisPlot, Scene}; backend, format, visible, connect, screen_kw...)
     @ ~/work/Makie.jl/Makie.jl/src/recording.jl:29</code></pre></div></div><div class="docstring"><div class="doc-header" id="StreamPlot"><a href="#StreamPlot">StreamPlot</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Surface"><a href="#Surface">Surface</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Text"><a href="#Text">Text</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Textbox"><a href="#Textbox">Textbox</a></div><div class="doc-content"><p><strong><code>Textbox &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Textbox.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>bordercolor</code>, <code>bordercolor_focused</code>, <code>bordercolor_focused_invalid</code>, <code>bordercolor_hover</code>, <code>borderwidth</code>, <code>boxcolor</code>, <code>boxcolor_focused</code>, <code>boxcolor_focused_invalid</code>, <code>boxcolor_hover</code>, <code>cornerradius</code>, <code>cornersegments</code>, <code>cursorcolor</code>, <code>defocus_on_submit</code>, <code>displayed_string</code>, <code>focused</code>, <code>font</code>, <code>fontsize</code>, <code>halign</code>, <code>height</code>, <code>placeholder</code>, <code>reset_on_defocus</code>, <code>restriction</code>, <code>stored_string</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>textcolor</code>, <code>textcolor_placeholder</code>, <code>textpadding</code>, <code>validator</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Theme"><a href="#Theme">Theme</a></div><div class="doc-content"><p>Main structure for holding attributes, for theming plots etc! Will turn all values into observables, so that they can be updated.</p></div></div><div class="docstring"><div class="doc-header" id="TimeSeries"><a href="#TimeSeries">TimeSeries</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Toggle"><a href="#Toggle">Toggle</a></div><div class="doc-content"><p><strong><code>Toggle &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Toggle.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>active</code>, <code>alignmode</code>, <code>buttoncolor</code>, <code>cornersegments</code>, <code>framecolor_active</code>, <code>framecolor_inactive</code>, <code>halign</code>, <code>height</code>, <code>rimfraction</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>toggleduration</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Tooltip"><a href="#Tooltip">Tooltip</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Top"><a href="#Top">Top</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Top</code></pre><h1>Supertype Hierarchy</h1><pre><code>Top &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="TopLeft"><a href="#TopLeft">TopLeft</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct TopLeft</code></pre><h1>Supertype Hierarchy</h1><pre><code>TopLeft &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="TopRight"><a href="#TopRight">TopRight</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct TopRight</code></pre><h1>Supertype Hierarchy</h1><pre><code>TopRight &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Transformation"><a href="#Transformation">Transformation</a></div><div class="doc-content"><p>Holds the transformations for Scenes.</p><h2>Fields</h2><ul><li><p><code>parent::Base.RefValue{Transformation}</code></p></li><li><p><code>translation::Observable{Vec{3, Float32}}</code></p></li><li><p><code>scale::Observable{Vec{3, Float32}}</code></p></li><li><p><code>rotation::Observable{Quaternionf}</code></p></li><li><p><code>model::Observable{StaticArraysCore.SMatrix{4, 4, Float32, 16}}</code></p></li><li><p><code>parent_model::Observable{StaticArraysCore.SMatrix{4, 4, Float32, 16}}</code></p></li><li><p><code>transform_func::Observable{Any}</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Tricontourf"><a href="#Tricontourf">Tricontourf</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Triplot"><a href="#Triplot">Triplot</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Unit"><a href="#Unit">Unit</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type Unit{T}</code></pre><h1>Subtypes</h1><pre><code>Makie.DeviceIndependentPixel{T&lt;:Number}
Makie.Millimeter{T}
Pixel{T}
SceneSpace{T}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Unit{T} &lt;: Number &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VLines"><a href="#VLines">VLines</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="VSpan"><a href="#VSpan">VSpan</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec"><a href="#Vec">Vec</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec2"><a href="#Vec2">Vec2</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec2f"><a href="#Vec2f">Vec2f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec3"><a href="#Vec3">Vec3</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec3f"><a href="#Vec3f">Vec3f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec4"><a href="#Vec4">Vec4</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec4f"><a href="#Vec4f">Vec4f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VecTypes"><a href="#VecTypes">VecTypes</a></div><div class="doc-content"><pre><code>Union{Types...}</code></pre><p>A type union is an abstract type which includes all instances of any of its argument types. The empty union <a href="@ref"><code>Union{}</code></a> is the bottom type of Julia.</p><h1>Examples</h1><pre><code class="language-jldoctest">julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 isa IntOrString
true

julia&gt; "Hello!" isa IntOrString
true

julia&gt; 1.0 isa IntOrString
false</code></pre></div></div><div class="docstring"><div class="doc-header" id="VertexGrid"><a href="#VertexGrid">VertexGrid</a></div><div class="doc-content"><pre><code>VertexGrid() &lt;: GridBased &lt;: ConversionTrait</code></pre><p>Plots with the <code>VertexGrid</code> trait convert their input data to <code>(xs::Vector{Float32}, ys::Vector{Float32}, zs::Matrix{Float32})</code> such that <code>(length(xs), length(ys)) == size(zs)</code>, or <code>(xs::Matrix{Float32}, ys::Matrix{Float32}, zs::Matrix{Float32})</code> such that <code>size(xs) == size(ys) == size(zs)</code>.</p><p>See also: <a href="@ref"><code>CellGrid</code></a>, <a href="@ref"><code>ImageLike</code></a> Used for: Surface</p></div></div><div class="docstring"><div class="doc-header" id="VideoStream"><a href="#VideoStream">VideoStream</a></div><div class="doc-content"><pre><code>VideoStream(fig::FigureLike;
        format="mp4", framerate=24, compression=nothing, profile=nothing, pixel_format=nothing, loop=nothing,
        loglevel="quiet", visible=false, connect=false, backend=current_backend(),
        screen_config...)</code></pre><p>Returns a <code>VideoStream</code> which can pipe new frames into the ffmpeg process with few allocations via <a href="@ref"><code>recordframe!(stream)</code></a>. When done, use <a href="@ref"><code>save(path, stream)</code></a> to write the video out to a file.</p><h1>Arguments</h1><h2>Video options</h2><ul><li><p><code>format = "mkv"</code>: The format of the video. If a path is present, will be inferred from the file extension.   Can be one of the following:</p><ul><li><p><code>"mkv"</code>  (open standard, the default)</p></li><li><p><code>"mp4"</code>  (good for Web, most supported format)</p></li><li><p><code>"webm"</code> (smallest file size)</p></li><li><p><code>"gif"</code>  (largest file size for the same quality)</p></li></ul><p><code>mp4</code> and <code>mk4</code> are marginally bigger than <code>webm</code>. <code>gif</code>s can be significantly (as much as   6x) larger with worse quality (due to the limited color palette) and only should be used   as a last resort, for playing in a context where videos aren't supported.</p></li><li><p><code>framerate = 24</code>: The target framerate.</p></li><li><p><code>compression = 20</code>: Controls the video compression via <code>ffmpeg</code>'s <code>-crf</code> option, with   smaller numbers giving higher quality and larger file sizes (lower compression), and   higher numbers giving lower quality and smaller file sizes (higher compression). The   minimum value is <code>0</code> (lossless encoding).</p><ul><li><p>For <code>mp4</code>, <code>51</code> is the maximum. Note that <code>compression = 0</code> only works with <code>mp4</code> if</p></li></ul><p><code>profile = "high444"</code>.</p><ul><li><p>For <code>webm</code>, <code>63</code> is the maximum.</p></li><li><p><code>compression</code> has no effect on <code>mkv</code> and <code>gif</code> outputs.</p></li></ul></li><li><p><code>profile = "high422"</code>: A ffmpeg compatible profile. Currently only applies to <code>mp4</code>. If</p></li></ul><p>you have issues playing a video, try <code>profile = "high"</code> or <code>profile = "main"</code>.</p><ul><li><p><code>pixel_format = "yuv420p"</code>: A ffmpeg compatible pixel format (<code>-pix_fmt</code>). Currently only</p></li></ul><p>applies to <code>mp4</code>. Defaults to <code>yuv444p</code> for <code>profile = "high444"</code>.</p><ul><li><p><code>loop = 0</code>: Number of times the video is repeated, for a <code>gif</code>. Defaults to <code>0</code>, which</p></li></ul><p>means infinite looping. A value of <code>-1</code> turns off looping, and a value of <code>n &gt; 0</code> and above means <code>n</code> repetitions (i.e. the video is played <code>n+1</code> times).</p><pre><code>!!! warning
`profile` and `pixel_format` are only used when `format` is `"mp4"`; a warning will be issued if `format`
is not `"mp4"` and those two arguments are not `nothing`. Similarly, `compression` is only
valid when `format` is `"mp4"` or `"webm"`, and `loop` is only valid when `format` is `"gif"`.</code></pre><h2>Backend options</h2><ul><li><p><code>backend=current_backend()</code>: backend used to record frames</p></li><li><p><code>visible=false</code>: make window visible or not</p></li><li><p><code>connect=false</code>: connect window events or not</p></li><li><p><code>screen_config...</code>: See <code>?Backend.Screen</code> or <code>Base.doc(Backend.Screen)</code> for applicable options that can be passed and forwarded to the backend.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Violin"><a href="#Violin">Violin</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Volume"><a href="#Volume">Volume</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="VolumeLike"><a href="#VolumeLike">VolumeLike</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct VolumeLike</code></pre><h1>Supertype Hierarchy</h1><pre><code>VolumeLike &lt;: ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VolumeSlices"><a href="#VolumeSlices">VolumeSlices</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Voronoiplot"><a href="#Voronoiplot">Voronoiplot</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="Waterfall"><a href="#Waterfall">Waterfall</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="WilkinsonTicks"><a href="#WilkinsonTicks">WilkinsonTicks</a></div><div class="doc-content"><pre><code>WilkinsonTicks(
    k_ideal::Int;
    k_min = 2, k_max = 10,
    Q = [(1.0, 1.0), (5.0, 0.9), (2.0, 0.7), (2.5, 0.5), (3.0, 0.2)],
    granularity_weight = 1/4,
    simplicity_weight = 1/6,
    coverage_weight = 1/3,
    niceness_weight = 1/4
)</code></pre><p><code>WilkinsonTicks</code> is a thin wrapper over <code>PlotUtils.optimize_ticks</code>, the docstring of which is reproduced below:</p><p>optimize<em>ticks(xmin, xmax; extend</em>ticks::Bool = false,                Q = [(1.0,1.0), (5.0, 0.9), (2.0, 0.7), (2.5, 0.5), (3.0, 0.2)],                k<em>min = 2, k</em>max = 10, k<em>ideal = 5,                granularity</em>weight = 1/4, simplicity<em>weight = 1/6,                coverage</em>weight = 1/3, niceness<em>weight = 1/4,                strict</em>span = true, span_buffer = nothing)</p><p>Find some reasonable values for tick marks.</p><p>This is basically Wilkinson's ad-hoc scoring method that tries to balance tight fit around the data, optimal number of ticks, and simple numbers.</p><h2>Arguments:</h2><ul><li><p><code>xmax</code>:</p><p>The maximum value occurring in the data.</p></li><li><p><code>xmin</code>:</p><p>The minimum value occurring in the data.</p></li><li><p><code>extend_ticks</code>:</p><p>Determines whether to extend tick computation. Defaults to false.</p></li><li><p><code>strict_span</code>:</p><p>True if no ticks should be outside [x<em>min, x</em>max]. Defaults to true.</p></li><li><p><code>Q</code>:</p><p>A distribution of nice numbers from which labellings are sampled. Stored in the form (number, score).</p></li><li><p><code>k_min</code>:</p><p>The minimum number of ticks.</p></li><li><p><code>k_max</code>:</p><p>The maximum number of ticks.</p></li><li><p><code>k_ideal</code>:</p><p>The ideal number of ticks.</p></li><li><p><code>granularity_weight</code>:</p><p>Encourages returning roughly the number of labels requested.</p></li><li><p><code>simplicity_weight</code>:</p><p>Encourages nicer labeling sequences by preferring step sizes that appear earlier in Q.   Also rewards labelings that include 0 as a way to ground the sequence.</p></li><li><p><code>coverage_weight</code>:</p><p>Encourages labelings that do not extend far beyond the range of the data, penalizing unnecessary whitespace.</p></li><li><p><code>niceness_weight</code>:</p><p>Encourages labellings to produce nice ranges.</p></li></ul><h2>Returns:</h2><p><code>(ticklocations::Vector{Float64}, x_min, x_max)</code></p><h2>Mathematical details</h2><p>Wilkinsonâs optimization function is defined as the sum of three components. If the user requests m labels and a possible labeling has k labels, then the components are <code>simplicity</code>, <code>coverage</code> and <code>granularity</code>.</p><p>These components are defined as follows:</p>
:$
<p>\begin{aligned}   &amp;\text{simplicity} = 1 - \frac{i}{|Q|} + \frac{v}{|Q|}\
  &amp;\text{coverage}   = \frac{x<em>{max} - x</em>{min}}{\mathrm{label}<em>{max} - \mathrm{label}</em>{min}}\
  &amp;\text{granularity}= 1 - \frac{\left|k - m\right|}{m} \end{aligned} $</p><p>and the variables here are:</p><ul><li><p><code>q</code>: element of <code>Q</code>.</p></li><li><p><code>i</code>: index of <code>q</code> â <code>Q</code>.</p></li><li><p><code>v</code>: 1 if label range includes 0, 0 otherwise.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Wireframe"><a href="#Wireframe">Wireframe</a></div><div class="doc-content"><pre><code>Plot{PlotFunc}(args::Tuple, kw::Dict{Symbol, Any})</code></pre><p>Creates a Plot corresponding to the recipe function <code>PlotFunc</code>. Each recipe defines an alias for <code>Plot{PlotFunc}</code>. Example:</p><pre><code class="language-julia">const Scatter = Plot{scatter} # defined in the scatter recipe
Plot{scatter}((1:4,), Dict{Symbol, Any}(:color =&gt; :red)) isa Scatter
# Same as:
Scatter((1:4,), Dict{Symbol, Any}(:color =&gt; :red))</code></pre><pre><code>Plot(args::Vararg{&lt;:DataType,N})</code></pre><p>Returns the Plot type that represents the signature of <code>args</code>. Example:</p><pre><code class="language-julia">Plot(Vector{Point2f}) == Plot{plot, Tuple{&lt;:Vector{Point2f}}}</code></pre><p>This can be used to more conveniently create recipes for <code>plot(mytype)</code> without the recipe macro:</p><pre><code class="language-julia">struct MyType ... end

function Makie.plot!(plot::Plot(MyType))
    ...
end

plot(MyType(...))</code></pre></div></div><div class="docstring"><div class="doc-header" id="abline!"><a href="#abline!">abline!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.abline!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "abline!" from Makie:
 [1] abline!(args...; kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/ablines.jl:46</code></pre></div></div><div class="docstring"><div class="doc-header" id="ablines"><a href="#ablines">ablines</a></div><div class="doc-content"><pre><code>ablines(intercepts, slopes; attrs...)</code></pre><p>Creates a line defined by <code>f(x) = slope * x + intercept</code> crossing a whole <code>Scene</code> with 2D projection at its current limits. You can pass one or multiple intercepts or slopes.</p><p>All style attributes are the same as for <code>LineSegments</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ablines!"><a href="#ablines!">ablines!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.ablines!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "ablines!" from Makie:
 [1] ablines!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="activate_interaction!"><a href="#activate_interaction!">activate_interaction!</a></div><div class="doc-content"><pre><code>activate_interaction!(parent, name::Symbol)</code></pre><p>Activate the interaction named <code>name</code> registered in <code>parent</code>.</p></div></div><div class="docstring"><div class="doc-header" id="addmouseevents!"><a href="#addmouseevents!">addmouseevents!</a></div><div class="doc-content"><pre><code>addmouseevents!(scene, elements...)</code></pre><p>Returns a <code>MouseEventHandle</code> with an observable inside which is triggered by all mouse interactions with the <code>scene</code> and optionally restricted to all given plot objects in <code>elements</code>.</p><p>To react to mouse events, use the onmouse... handlers.</p><p>Example:</p><pre><code>mouseevents = addmouseevents!(scene, scatterplot)

onmouseleftclick(mouseevents) do event
    # do something with the mouseevent
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="annotations"><a href="#annotations">annotations</a></div><div class="doc-content"><pre><code>annotations(strings::Vector{String}, positions::Vector{Point})</code></pre><p>Plots an array of texts at each position in <code>positions</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.annotations}</code> are: </p><pre><code>  align             (:left, :bottom)
  alpha             1.0
  color             :black
  colormap          :viridis
  colorrange        MakieCore.Automatic()
  colorscale        identity
  depth_shift       0.0f0
  font              :regular
  fonts             Attributes with 4 entries:
  bold =&gt; TeX Gyre Heros Makie Bold
  bold_italic =&gt; TeX Gyre Heros Makie Bold Italic
  italic =&gt; TeX Gyre Heros Makie Italic
  regular =&gt; TeX Gyre Heros Makie
  fontsize          14
  highclip          MakieCore.Automatic()
  inspectable       true
  justification     MakieCore.Automatic()
  lineheight        1.0
  lowclip           MakieCore.Automatic()
  markerspace       :pixel
  nan_color         :transparent
  offset            (0.0, 0.0)
  overdraw          false
  position          (0.0, 0.0)
  rotation          0.0
  space             :data
  ssao              false
  strokecolor       (:black, 0.0)
  strokewidth       0
  transform_marker  false
  transparency      false
  visible           true
  word_wrap_width   -1</code></pre></div></div><div class="docstring"><div class="doc-header" id="annotations!"><a href="#annotations!">annotations!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.annotations!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "annotations!" from Makie:
 [1] annotations!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="arc"><a href="#arc">arc</a></div><div class="doc-content"><pre><code>arc(origin, radius, start_angle, stop_angle; kwargs...)</code></pre><p>This function plots a circular arc, centered at <code>origin</code> with radius <code>radius</code>, from <code>start_angle</code> to <code>stop_angle</code>. <code>origin</code> must be a coordinate in 2 dimensions (i.e., a <code>Point2</code>); the rest of the arguments must be <code>&lt;: Number</code>.</p><p>Examples:</p><p><code>arc(Point2f(0), 1, 0.0, Ï)</code><code>arc(Point2f(1, 2), 0.3, Ï, -Ï)</code></p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.arc}</code> are: </p><pre><code>  alpha           1.0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  cycle           [:color]
  depth_shift     0.0f0
  highclip        MakieCore.Automatic()
  inspectable     true
  linestyle       "nothing"
  linewidth       1.5
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  resolution      361
  space           :data
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="arc!"><a href="#arc!">arc!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.arc!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "arc!" from Makie:
 [1] arc!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="arrows"><a href="#arrows">arrows</a></div><div class="doc-content"><pre><code>arrows(points, directions; kwargs...)
arrows(x, y, u, v)
arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)
arrows(x, y, z, u, v, w)
arrows(x, y, [z], f::Function)</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each 'row' is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p><p>If a <code>Function</code> is provided in place of <code>u, v, [w]</code>, then it must accept a <code>Point</code> as input, and return an appropriately dimensioned <code>Point</code>, <code>Vec</code>, or other array-like output.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Arrows</code> are: </p><pre><code>  align           :origin
  alpha           1.0
  arrowcolor      MakieCore.Automatic()
  arrowhead       MakieCore.Automatic()
  arrowsize       MakieCore.Automatic()
  arrowtail       MakieCore.Automatic()
  backlight       0.0f0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  depth_shift     0.0f0
  diffuse         1.0
  highclip        MakieCore.Automatic()
  inspectable     true
  lengthscale     1.0f0
  linecolor       MakieCore.Automatic()
  linestyle       "nothing"
  linewidth       MakieCore.Automatic()
  lowclip         MakieCore.Automatic()
  markerspace     :pixel
  nan_color       :transparent
  normalize       false
  overdraw        false
  quality         32
  shading         MakieCore.Automatic()
  shininess       32.0f0
  space           :data
  specular        0.2
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="arrows!"><a href="#arrows!">arrows!</a></div><div class="doc-content"><p>See <a href="@ref"><code>arrows</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="assetpath"><a href="#assetpath">assetpath</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.assetpath</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "assetpath" from Makie:
 [1] assetpath(files...)
     @ ~/work/Makie.jl/Makie.jl/src/Makie.jl:106</code></pre></div></div><div class="docstring"><div class="doc-header" id="attributes"><a href="#attributes">attributes</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.attributes</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "attributes" from MakieCore:
 [1] attributes(x::Attributes)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/attributes.jl:34
 [2] attributes(x::AbstractPlot)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/attributes.jl:35</code></pre></div></div><div class="docstring"><div class="doc-header" id="autolimits!"><a href="#autolimits!">autolimits!</a></div><div class="doc-content"><pre><code>autolimits!()
autolimits!(la::Axis)</code></pre><p>Reset manually specified limits of <code>la</code> to an automatically determined rectangle, that depends on the data limits of all plot objects in the axis, as well as the autolimit margins for x and y axis. The argument <code>la</code> defaults to <code>current_axis()</code>.</p><pre><code>autolimits!(ax::PolarAxis[, unlock_zoom = true])</code></pre><p>Calling this tells the PolarAxis to derive limits freely from the plotted data, which allows rmin &gt; 0 and thetalimits spanning less than a full circle. If <code>unlock_zoom = true</code> this also unlocks zooming in r and theta direction and allows for translations in r direction.</p></div></div><div class="docstring"><div class="doc-header" id="available_gradients"><a href="#available_gradients">available_gradients</a></div><div class="doc-content"><pre><code>available_gradients()</code></pre><p>Prints all available gradient names.</p></div></div><div class="docstring"><div class="doc-header" id="available_marker_symbols"><a href="#available_marker_symbols">available_marker_symbols</a></div><div class="doc-content"><pre><code>available_marker_symbols()</code></pre><p>Displays all available marker symbols.</p></div></div><div class="docstring"><div class="doc-header" id="available_plotting_methods"><a href="#available_plotting_methods">available_plotting_methods</a></div><div class="doc-content"><pre><code>available_plotting_methods()</code></pre><p>Returns an array of all available plotting functions.</p></div></div><div class="docstring"><div class="doc-header" id="axis3d"><a href="#axis3d">axis3d</a></div><div class="doc-content"><pre><code class="language-julia">axis3d(args; kw...)
</code></pre><p>Plots a 3-dimensional OldAxis.</p><h2>Attributes</h2><p>OldAxis attributes and their defaults for <code>Plot{Makie.axis3d}</code> are: </p><pre><code>    showaxis: (true, true, true)
    visible: true
    ticks: 
        rotation: (-0.7071067811865475 + -0.0im + -0.0jm - 0.7071067811865476km, -4.371139e-8 + 0.0im + 0.0jm + 1.0km, -3.090861907263062e-8 + 3.090861907263061e-8im + 0.7071067811865475jm + 0.7071067811865476km)
        font: (:regular, :regular, :regular)
        ranges_labels: (MakieCore.Automatic(), MakieCore.Automatic())
        formatter: plain
        textcolor: (RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0))
        fontsize: (5, 5, 5)
        align: ((:left, :center), (:right, :center), (:right, :center))
        gap: 3
    fonts: 
        bold: TeX Gyre Heros Makie Bold
        italic: TeX Gyre Heros Makie Italic
        bold_italic: TeX Gyre Heros Makie Bold Italic
        regular: TeX Gyre Heros Makie
    names: 
        axisnames: ("x", "y", "z")
        rotation: (-0.7071067811865475 + -0.0im + -0.0jm - 0.7071067811865476km, -4.371139e-8 + 0.0im + 0.0jm + 1.0km, -3.090861907263062e-8 + 3.090861907263061e-8im + 0.7071067811865475jm + 0.7071067811865476km)
        font: (:regular, :regular, :regular)
        textcolor: (:black, :black, :black)
        fontsize: (6.0, 6.0, 6.0)
        align: ((:left, :center), (:right, :center), (:right, :center))
        gap: 3
    scale: Float32[1.0, 1.0, 1.0]
    showgrid: (true, true, true)
    padding: 0.1
    frame: 
        axiscolor: (:black, :black, :black)
        axislinewidth: (1.5, 1.5, 1.5)
        linewidth: (1, 1, 1)
        linecolor: (RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0))
    inspectable: false
    showticks: (true, true, true)</code></pre></div></div><div class="docstring"><div class="doc-header" id="axis3d!"><a href="#axis3d!">axis3d!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.axis3d!</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "axis3d!" from Makie:
 [1] axis3d!(scene::Scene; ...)
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/axis.jl:345
 [2] axis3d!(scene::Scene, lims; kw...)
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/axis.jl:345
 [3] axis3d!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="axislegend"><a href="#axislegend">axislegend</a></div><div class="doc-content"><pre><code>axislegend(ax, args...; position = :rt, kwargs...)
axislegend(ax, args...; position = (1, 1), kwargs...)
axislegend(ax = current_axis(); kwargs...)
axislegend(title::AbstractString; kwargs...)
axislegend(ax, title::AbstractString; kwargs...)</code></pre><p>Create a legend that sits inside an Axis's plot area.</p><p>The position can be a Symbol where the first letter controls the horizontal alignment and can be l, r or c, and the second letter controls the vertical alignment and can be t, b or c. Or it can be a tuple where the first element is set as the Legend's halign and the second element as its valign.</p><p>With the keywords merge and unique you can control how plot objects with the same labels are treated. If merge is true, all plot objects with the same label will be layered on top of each other into one legend entry. If unique is true, all plot objects with the same plot type and label will be reduced to one occurrence.</p></div></div><div class="docstring"><div class="doc-header" id="band"><a href="#band">band</a></div><div class="doc-content"><pre><code>band(x, ylower, yupper; kwargs...)
band(lower, upper; kwargs...)
band(x, lowerupper; kwargs...)</code></pre><p>Plots a band from <code>ylower</code> to <code>yupper</code> along <code>x</code>. The form <code>band(lower, upper)</code> plots a <a href="https://en.wikipedia.org/wiki/Ruled_surface">ruled surface</a> between the points in <code>lower</code> and <code>upper</code>. Both bounds can be passed together as <code>lowerupper</code>, a vector of intervals.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.band}</code> are: </p><pre><code>  alpha           1.0
  backlight       0.0f0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  cycle           [:color =&gt; :patchcolor]
  depth_shift     0.0f0
  diffuse         1.0
  highclip        MakieCore.Automatic()
  inspectable     true
  interpolate     true
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  shading         NoShading
  shininess       32.0f0
  space           :data
  specular        0.2
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="band!"><a href="#band!">band!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.band!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "band!" from Makie:
 [1] band!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="barplot"><a href="#barplot">barplot</a></div><div class="doc-content"><pre><code>barplot(x, y; kwargs...)</code></pre><p>Plots a barplot; <code>y</code> defines the height. <code>x</code> and <code>y</code> should be 1 dimensional. Bar width is determined by the attribute <code>width</code>, shrunk by <code>gap</code> in the following way: <code>width -&gt; width * (1 - gap)</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.barplot}</code> are: </p><pre><code>  alpha                  1.0
  bar_labels             "nothing"
  color                  RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  color_over_background  MakieCore.Automatic()
  color_over_bar         MakieCore.Automatic()
  colormap               :viridis
  colorrange             MakieCore.Automatic()
  colorscale             identity
  cycle                  [:color =&gt; :patchcolor]
  direction              :y
  dodge                  MakieCore.Automatic()
  dodge_gap              0.03
  fillto                 MakieCore.Automatic()
  flip_labels_at         Inf
  gap                    0.2
  highclip               MakieCore.Automatic()
  inspectable            true
  label_align            MakieCore.Automatic()
  label_color            :black
  label_font             :regular
  label_formatter        Makie.bar_label_formatter
  label_offset           5
  label_rotation         0.0
  label_size             14
  lowclip                MakieCore.Automatic()
  marker                 GeometryBasics.HyperRectangle
  n_dodge                MakieCore.Automatic()
  nan_color              :transparent
  offset                 0.0
  stack                  MakieCore.Automatic()
  strokecolor            :black
  strokewidth            0
  transparency           false
  visible                true
  width                  MakieCore.Automatic()</code></pre></div></div><div class="docstring"><div class="doc-header" id="barplot!"><a href="#barplot!">barplot!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.barplot!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "barplot!" from Makie:
 [1] barplot!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="bottom"><a href="#bottom">bottom</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.bottom</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "bottom" from Makie:
 [1] bottom(rect::Rect2)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:4</code></pre></div></div><div class="docstring"><div class="doc-header" id="boundingbox"><a href="#boundingbox">boundingbox</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.boundingbox</code> is a <code>Function</code>.</p><pre><code># 6 methods for generic function "boundingbox" from Makie:
 [1] boundingbox(x::Union{Makie.GlyphCollection, AbstractArray{&lt;:Makie.GlyphCollection}}, args...)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:86
 [2] boundingbox(x, exclude)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:6
 [3] boundingbox(x::MakieCore.Text{&lt;:Tuple{var"#s317"} where var"#s317"&lt;:(AbstractArray{&lt;:Makie.GlyphCollection})})
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:103
 [4] boundingbox(x::MakieCore.Text{&lt;:Tuple{var"#s317"} where var"#s317"&lt;:Makie.GlyphCollection})
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:92
 [5] boundingbox(plot::MakieCore.Text)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:114
 [6] boundingbox(x)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:6</code></pre></div></div><div class="docstring"><div class="doc-header" id="boxplot"><a href="#boxplot">boxplot</a></div><div class="doc-content"><pre><code>boxplot(x, y; kwargs...)</code></pre><p>Draw a Tukey style boxplot. The boxplot has 3 components:</p><ul><li><p>a <code>crossbar</code> spanning the interquartile (IQR) range with a midline marking the   median</p></li><li><p>an <code>errorbar</code> whose whiskers span <code>range * iqr</code></p></li><li><p>points marking outliers, that is, data outside the whiskers</p></li></ul><h1>Arguments</h1><ul><li><p><code>x</code>: positions of the categories</p></li><li><p><code>y</code>: variables within the boxes</p></li></ul><h1>Keywords</h1><ul><li><p><code>weights</code>: vector of statistical weights (length of data). By default, each observation has weight <code>1</code>.</p></li><li><p><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=1</code>: width of the box before shrinking</p></li><li><p><code>gap=0.2</code>: shrinking factor, <code>width -&gt; width * (1 - gap)</code></p></li><li><p><code>show_notch=false</code>: draw the notch</p></li><li><p><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</p></li><li><p><code>show_median=true</code>: show median as midline</p></li><li><p><code>range</code>: multiple of IQR controlling whisker length</p></li><li><p><code>whiskerwidth</code>: multiplier of <code>width</code> for width of T's on whiskers, or   <code>:match</code> to match <code>width</code></p></li><li><p><code>show_outliers</code>: show outliers as points</p></li><li><p><code>dodge</code>: vector of <code>Integer</code> (length of data) of grouping variable to create multiple side-by-side boxes at the same <code>x</code> position</p></li><li><p><code>dodge_gap = 0.03</code>: spacing between dodged boxes</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="boxplot!"><a href="#boxplot!">boxplot!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.boxplot!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "boxplot!" from Makie:
 [1] boxplot!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="bracket"><a href="#bracket">bracket</a></div><div class="doc-content"><pre><code>bracket(x1, y1, x2, y2; kwargs...)
bracket(x1s, y1s, x2s, y2s; kwargs...)
bracket(point1, point2; kwargs...)
bracket(vec_of_point_tuples; kwargs...)</code></pre><p>Draws a bracket between each pair of points (x1, y1) and (x2, y2) with a text label at the midpoint.</p><p>By default each label is rotated parallel to the line between the bracket points.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.bracket}</code> are: </p><pre><code>  align          (:center, :center)
  color          :black
  font           :regular
  fontsize       14
  justification  MakieCore.Automatic()
  linestyle      :solid
  linewidth      1.5
  offset         0
  orientation    :up
  rotation       MakieCore.Automatic()
  style          :curly
  text           ""
  textcolor      :black
  textoffset     MakieCore.Automatic()
  width          15</code></pre></div></div><div class="docstring"><div class="doc-header" id="bracket!"><a href="#bracket!">bracket!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.bracket!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "bracket!" from Makie:
 [1] bracket!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="broadcast_foreach"><a href="#broadcast_foreach">broadcast_foreach</a></div><div class="doc-content"><pre><code>broadcast_foreach(f, args...)</code></pre><p>Like broadcast but for foreach. Doesn't care about shape and treats Tuples &amp;&amp; StaticVectors as scalars. This method is meant for broadcasting across attributes that can either have scalar or vector / array form. An example would be a collection of scatter markers that have different sizes but a single color. The length of an attribute is determined with <code>attr_broadcast_length</code> and elements are accessed with <code>attr_broadcast_getindex</code>.</p></div></div><div class="docstring"><div class="doc-header" id="cam2d"><a href="#cam2d">cam2d</a></div><div class="doc-content"><p>Creates a subscene with a pixel camera</p></div></div><div class="docstring"><div class="doc-header" id="cam2d!"><a href="#cam2d!">cam2d!</a></div><div class="doc-content"><pre><code>cam2d!(scene::SceneLike, kwargs...)</code></pre><p>Creates a 2D camera for the given <code>scene</code>. The camera implements zooming by scrolling and translation using mouse drag. It also implements rectangle selections.</p><h2>Keyword Arguments</h2><ul><li><p><code>zoomspeed = 0.1f0</code> sets the zoom speed.</p></li><li><p><code>zoombutton = true</code> sets a button (combination) which needs to be pressed to enable zooming. By default no button needs to be pressed.</p></li><li><p><code>panbutton = Mouse.right</code> sets the button used to translate the camera. This must include a mouse button.</p></li><li><p><code>selectionbutton = (Keyboard.space, Mouse.left)</code> sets the button used for rectangle selection. This must include a mouse button.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="cam3d!"><a href="#cam3d!">cam3d!</a></div><div class="doc-content"><pre><code>cam3d!(scene[; kwargs...])</code></pre><p>Creates a <code>Camera3D</code> with <code>zoom_shift_lookat = true</code> and <code>fixed_axis = true</code>. For more information, see <a href="@ref"><code>Camera3D</code></a></p></div></div><div class="docstring"><div class="doc-header" id="cam3d_cad!"><a href="#cam3d_cad!">cam3d_cad!</a></div><div class="doc-content"><pre><code>cam3d_cad!(scene[; kwargs...])</code></pre><p>Creates a <code>Camera3D</code> with <code>cad = true</code>, <code>zoom_shift_lookat = false</code> and <code>fixed_axis = false</code>. For more information, see <a href="@ref"><code>Camera3D</code></a></p></div></div><div class="docstring"><div class="doc-header" id="cam_relative!"><a href="#cam_relative!">cam_relative!</a></div><div class="doc-content"><pre><code>cam_relative!(scene)</code></pre><p>Creates a camera for the given <code>scene</code> which maps the scene area to a 0..1 by 0..1 range. This camera does not feature controls.</p></div></div><div class="docstring"><div class="doc-header" id="camera"><a href="#camera">camera</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.camera</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "camera" from Makie:
 [1] camera(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:495
 [2] camera(scene::Union{AbstractScene, MakieCore.ScenePlot})
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:496
 [3] camera(x)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:494</code></pre></div></div><div class="docstring"><div class="doc-header" id="cameracontrols"><a href="#cameracontrols">cameracontrols</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.cameracontrols</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "cameracontrols" from Makie:
 [1] cameracontrols(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:499
 [2] cameracontrols(scene::Union{AbstractScene, MakieCore.ScenePlot})
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:500
 [3] cameracontrols(x)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:498</code></pre></div></div><div class="docstring"><div class="doc-header" id="cameracontrols!"><a href="#cameracontrols!">cameracontrols!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.cameracontrols!</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "cameracontrols!" from Makie:
 [1] cameracontrols!(scene::Scene, cam)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:502
 [2] cameracontrols!(scene::Union{AbstractScene, MakieCore.ScenePlot}, cam)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:506
 [3] cameracontrols!(x, cam)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:507</code></pre></div></div><div class="docstring"><div class="doc-header" id="campixel"><a href="#campixel">campixel</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.campixel</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "campixel" from Makie:
 [1] campixel(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:380</code></pre></div></div><div class="docstring"><div class="doc-header" id="campixel!"><a href="#campixel!">campixel!</a></div><div class="doc-content"><pre><code>campixel!(scene; nearclip=-1000f0, farclip=1000f0)</code></pre><p>Creates a pixel camera for the given <code>scene</code>. This means that the positional data of a plot will be interpreted in pixel units. This camera does not feature controls.</p></div></div><div class="docstring"><div class="doc-header" id="categorical_colors"><a href="#categorical_colors">categorical_colors</a></div><div class="doc-content"><pre><code>categorical_colors(colormaplike, categories::Integer)</code></pre><p>Creates categorical colors and tries to match <code>categories</code>. Will error if color scheme doesn't contain enough categories. Will drop the n last colors, if request less colors than contained in scheme.</p></div></div><div class="docstring"><div class="doc-header" id="center!"><a href="#center!">center!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.center!</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "center!" from Makie:
 [1] center!(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:548
 [2] center!(scene::Scene, padding, exclude)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:548
 [3] center!(scene::Scene, padding)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:548</code></pre></div></div><div class="docstring"><div class="doc-header" id="cgrad"><a href="#cgrad">cgrad</a></div><div class="doc-content"><pre><code>cgrad(colors, [values]; categorical = nothing, scale = nothing, rev = false, alpha = nothing)</code></pre><p>Construct a Colorgradient from <code>colors</code> and <code>values</code>.</p><p><code>colors</code> can be a symbol for ColorSchemes.jl <code>ColorScheme</code>s, a <code>ColorScheme</code>, a vector of colors, a <code>ColorGradient</code> or a <code>ColorPalette</code>. If <code>values</code> is an integer, it specifies the numbers of colors chosen equidistantly from the colorscheme specified by colors. Otherwise vectors are accepted. For continuous color gradients <code>values</code> indicate where between 0 and 1 the colors are positioned. For categorical color gradients <code>values</code> indicate where a color ends and where a new one begins between 0 and 1. 0 and 1 are added to <code>values</code> if not already present.</p><p>If <code>rev</code> is <code>true</code> colors are reversed. <code>scale</code> accepts the symbols <code>:log</code>, <code>:log10</code>, <code>:log2</code>, <code>:ln</code>, <code>:exp</code>, <code>:exp10</code> or functions. If <code>alpha</code> is set, it is applied to all colors.</p></div></div><div class="docstring"><div class="doc-header" id="colgap!"><a href="#colgap!">colgap!</a></div><div class="doc-content"><pre><code>colgap!(gl::GridLayout, i::Integer, s::Union{Fixed, Relative, Real})
colgap!(gl::GridLayout, s::Union{Fixed, Relative, Real})</code></pre><p>Set the gap between columns in <code>gl</code>.  The two-argument version sets all column gaps in <code>gl</code>.  The three-argument version sets the gap between columns <code>i</code> and <code>i+1</code>. Passing a real number to <code>s</code> has the same behaviour as passing <code>Fixed(s)</code>.</p><p>See also <a href="@ref">Fixed</a> and <a href="@ref">Relative</a>.</p></div></div><div class="docstring"><div class="doc-header" id="colorbuffer"><a href="#colorbuffer">colorbuffer</a></div><div class="doc-content"><pre><code>colorbuffer(scene, format::ImageStorageFormat = JuliaNative; update=true, backend=current_backend(), screen_config...)</code></pre><p>Returns the content of the given scene or screen rasterised to a Matrix of Colors. The return type is backend-dependent, but will be some form of RGB or RGBA.</p><ul><li><p><code>backend::Module</code>: A module which is a Makie backend.  For example, <code>backend = GLMakie</code>, <code>backend = CairoMakie</code>, etc.</p></li><li><p><code>format = JuliaNative</code> : Returns a buffer in the format of standard julia images (dims permuted and one reversed)</p></li><li><p><code>format = GLNative</code> : Returns a more efficient format buffer for GLMakie which can be directly                       used in FFMPEG without conversion</p></li><li><p><code>screen_config</code>: Backend dependent, look up via <code>?Backend.Screen</code>/<code>Base.doc(Backend.Screen)</code></p></li><li><p><code>update=true</code>: resets/updates limits. Set to false, if you want to preserver camera movements.</p></li></ul><pre><code>colorbuffer(ax::Axis; include_decorations=true, colorbuffer_kws...)</code></pre><p>Gets the colorbuffer of the <code>Axis</code> in <code>JuliaNative</code> image format. If <code>include_decorations=false</code>, only the inside of the axis is fetched.</p></div></div><div class="docstring"><div class="doc-header" id="colsize!"><a href="#colsize!">colsize!</a></div><div class="doc-content"><pre><code>colsize!(gl::GridLayout, i::Integer, s::Union{Aspect, Auto, Fixed, Relative, Real})</code></pre><p>Set the size of the <code>i</code>th column in <code>gl</code>, i.e., <code>gl[:, i]</code>. Passing a real number to <code>s</code> has the same behaviour as passing <code>Fixed(s)</code>.</p><p>See also <a href="@ref">Aspect</a>, <a href="@ref">Auto</a>, <a href="@ref">Fixed</a>, and <a href="@ref">Relative</a>.</p></div></div><div class="docstring"><div class="doc-header" id="connect!"><a href="#connect!">connect!</a></div><div class="doc-content"><pre><code>connect!(o1::AbstractObservable, o2::AbstractObservable)</code></pre><p>Forwards all updates from <code>o2</code> to <code>o1</code>.</p><p>See also <a href="@ref"><code>Observables.ObservablePair</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="connect_screen"><a href="#connect_screen">connect_screen</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.connect_screen</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "connect_screen" from Makie:
 [1] connect_screen(scene::Scene, screen)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/events.jl:14</code></pre></div></div><div class="docstring"><div class="doc-header" id="content"><a href="#content">content</a></div><div class="doc-content"><pre><code>content(g::Union{GridPosition,GridSubposition})</code></pre><p>Return the one object placed in the <code>GridLayout</code> at the <code>Span</code> and <code>Side</code> stored in the <code>GridPosition</code><code>g</code>. If there is more than one object at that position, throw an error.</p><p>See also <code>contents</code>.</p></div></div><div class="docstring"><div class="doc-header" id="contents"><a href="#contents">contents</a></div><div class="doc-content"><pre><code>contents(gp::GridPosition; exact::Bool = false)</code></pre><p>Retrieve all objects placed in the <code>GridLayout</code> at the <code>Span</code> and <code>Side</code> stored in the <code>GridPosition</code><code>gp</code>. If <code>exact == true</code>, elements are only included if they match the <code>Span</code> exactly, otherwise they can also be contained within the spanned layout area.</p><pre><code>contents(g::GridLayout)</code></pre><p>Retrieve all objects placed in the <code>GridLayout</code><code>g</code>, in the order they are stored, extracted from their containing <code>GridContent</code>s.</p></div></div><div class="docstring"><div class="doc-header" id="contour"><a href="#contour">contour</a></div><div class="doc-content"><pre><code>contour(x, y, z)
contour(z::Matrix)</code></pre><p>Creates a contour plot of the plane spanning <code>x::Vector</code>, <code>y::Vector</code>, <code>z::Matrix</code>. If only <code>z::Matrix</code> is supplied, the indices of the elements in <code>z</code> will be used as the <code>x</code> and <code>y</code> locations when plotting the contour.</p><p>The attribute levels can be either</p><pre><code>an Int that produces n equally wide levels or bands

an AbstractVector{&lt;:Real} that lists n consecutive edges from low to high, which result in n-1 levels or bands</code></pre><p>To add contour labels, use <code>labels = true</code>, and pass additional label attributes such as <code>labelcolor</code>, <code>labelsize</code>, <code>labelfont</code> or <code>labelformatter</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.contour}</code> are: </p><pre><code>  alpha           1.0
  color           "nothing"
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  depth_shift     0.0f0
  enable_depth    true
  highclip        MakieCore.Automatic()
  inspectable     true
  labelcolor      "nothing"
  labelfont       :regular
  labelformatter  Makie.contour_label_formatter
  labels          false
  labelsize       10
  levels          5
  linestyle       "nothing"
  linewidth       1.0
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  space           :data
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="contour!"><a href="#contour!">contour!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.contour!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "contour!" from Makie:
 [1] contour!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="contour3d"><a href="#contour3d">contour3d</a></div><div class="doc-content"><pre><code>contour3d(x, y, z)</code></pre><p>Creates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.contour3d}</code> are: </p><pre><code>  alpha           1.0
  color           "nothing"
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  depth_shift     0.0f0
  enable_depth    true
  highclip        MakieCore.Automatic()
  inspectable     true
  labelcolor      "nothing"
  labelfont       :regular
  labelformatter  Makie.contour_label_formatter
  labels          false
  labelsize       10
  levels          5
  linestyle       "nothing"
  linewidth       1.0
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  space           :data
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="contour3d!"><a href="#contour3d!">contour3d!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.contour3d!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "contour3d!" from Makie:
 [1] contour3d!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="contourf"><a href="#contourf">contourf</a></div><div class="doc-content"><pre><code>contourf(xs, ys, zs; kwargs...)</code></pre><p>Plots a filled contour of the height information in <code>zs</code> at horizontal grid positions <code>xs</code> and vertical grid positions <code>ys</code>.</p><p>The attribute <code>levels</code> can be either</p><ul><li><p>an <code>Int</code> that produces n equally wide levels or bands</p></li><li><p>an <code>AbstractVector{&lt;:Real}</code> that lists n consecutive edges from low to high, which result in n-1 levels or bands</p></li></ul><p>You can also set the <code>mode</code> attribute to <code>:relative</code>. In this mode you specify edges by the fraction between minimum and maximum value of <code>zs</code>. This can be used for example to draw bands for the upper 90% while excluding the lower 10% with <code>levels = 0.1:0.1:1.0, mode = :relative</code>.</p><p>In :normal mode, if you want to show a band from <code>-Inf</code> to the low edge, set <code>extendlow</code> to <code>:auto</code> for the same color as the first level, or specify a different color (default <code>nothing</code> means no extended band) If you want to show a band from the high edge to <code>Inf</code>, set <code>extendhigh</code> to <code>:auto</code> for the same color as the last level, or specify a different color (default <code>nothing</code> means no extended band).</p><p>If <code>levels</code> is an <code>Int</code>, the contour plot will be rectangular as all <code>zs</code> will be covered. This is why <code>Axis</code> defaults to tight limits for such contourf plots. If you specify <code>levels</code> as an <code>AbstractVector{&lt;:Real}</code>, however, note that the axis limits include the default margins because the contourf plot can have an irregular shape. You can use <code>tightlimits!(ax)</code> to tighten the limits similar to the <code>Int</code> behavior.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.contourf}</code> are: </p><pre><code>  colormap      :viridis
  colorscale    identity
  extendhigh    "nothing"
  extendlow     "nothing"
  inspectable   true
  levels        10
  mode          :normal
  nan_color     :transparent
  transparency  false</code></pre></div></div><div class="docstring"><div class="doc-header" id="contourf!"><a href="#contourf!">contourf!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.contourf!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "contourf!" from Makie:
 [1] contourf!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="convert_arguments"><a href="#convert_arguments">convert_arguments</a></div><div class="doc-content"><p>Wrap a single point or equivalent object in a single-element array.</p><p>Enables to use scatter like a surface plot with x::Vector, y::Vector, z::Matrix spanning z over the grid spanned by x y</p><pre><code>convert_arguments(P, x, y, z)::(Vector)</code></pre><p>Takes vectors <code>x</code>, <code>y</code>, and <code>z</code> and turns it into a vector of 3D points of the values from <code>x</code>, <code>y</code>, and <code>z</code>. <code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input GeometryPrimitive <code>x</code> and decomposes it to points. <code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, y)::Vector</code></pre><p>Takes vector <code>y</code> and generates a range from 1 to the length of <code>y</code>, for plotting on an arbitrary <code>x</code> axis.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x, y)::(Vector)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and turns it into a vector of 2D points of the values from <code>x</code> and <code>y</code>.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input <code>Rect</code><code>x</code> and decomposes it to points.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(PB, LineString)</code></pre><p>Takes an input <code>LineString</code> and decomposes it to points.</p><pre><code>convert_arguments(PB, Union{Array{&lt;:LineString}, MultiLineString})</code></pre><p>Takes an input <code>Array{LineString}</code> or a <code>MultiLineString</code> and decomposes it to points.</p><pre><code>convert_arguments(PB, Polygon)</code></pre><p>Takes an input <code>Polygon</code> and decomposes it to points.</p><pre><code>convert_arguments(PB, Union{Array{&lt;:Polygon}, MultiPolygon})</code></pre><p>Takes an input <code>Array{Polygon}</code> or a <code>MultiPolygon</code> and decomposes it to points.</p><pre><code>convert_arguments(ct::GridBased, x::VecOrMat, y::VecOrMat, z::Matrix)</code></pre><p>If <code>ct</code> is <code>Heatmap</code> and <code>x</code> and <code>y</code> are vectors, infer from length of <code>x</code> and <code>y</code> whether they represent edges or centers of the heatmap bins. If they are centers, convert to edges. Convert eltypes to <code>Float32</code> and return outputs as a <code>Tuple</code>.</p><pre><code>convert_arguments(P, x::RangeLike, y::RangeLike, z::AbstractMatrix)</code></pre><p>Takes one or two ClosedIntervals <code>x</code> and <code>y</code> and converts them to closed ranges with size(z, 1/2).</p><pre><code>convert_arguments(::ImageLike, mat::AbstractMatrix)</code></pre><p>Generates <code>ClosedInterval</code>s of size <code>0 .. size(mat, 1/2)</code> as x and y values.</p><pre><code>convert_arguments(P, x, y, f)::(Vector, Vector, Matrix)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and the function <code>f</code>, and applies <code>f</code> on the grid that <code>x</code> and <code>y</code> span. This is equivalent to <code>f.(x, y')</code>. <code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an array of <code>{T, 3} where T</code>, converts the dimensions <code>n</code>, <code>m</code> and <code>k</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code>, <code>m</code> and <code>k</code>, plus the original array in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x, y, z, i)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes 3 <code>AbstractVector</code><code>x</code>, <code>y</code>, and <code>z</code> and the <code>AbstractMatrix</code><code>i</code>, and puts everything in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p><p>Accepts a Vector of Pair of Points (e.g. <code>[Point(0, 0) =&gt; Point(1, 1), ...]</code>) to encode e.g. linesegments or directions.</p><pre><code>convert_arguments(Mesh, x, y, z)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a mesh out of those, under the assumption that every 3 points form a triangle.</p><pre><code>convert_arguments(Mesh, xyz::AbstractVector)::GLNormalMesh</code></pre><p>Takes an input mesh and a vector <code>xyz</code> representing the vertices of the mesh, and creates indices under the assumption, that each triplet in <code>xyz</code> forms a triangle.</p><pre><code>convert_arguments(Mesh, x, y, z, indices)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a triangle mesh out of those, using the faces in <code>indices</code>, which can be integers (every 3 -&gt; one triangle), or GeometryBasics.NgonFace{N, &lt;: Integer}.</p><pre><code>convert_arguments(Mesh, vertices, indices)::GLNormalMesh</code></pre><p>Takes <code>vertices</code> and <code>indices</code>, and creates a triangle mesh out of those. See <a href="@ref"><code>to_vertices</code></a> and <a href="@ref"><code>to_triangles</code></a> for more information about accepted types.</p><pre><code>convert_arguments(P, x, y, z, f)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes <code>AbstractVector</code><code>x</code>, <code>y</code>, and <code>z</code> and the function <code>f</code>, evaluates <code>f</code> on the volume spanned by <code>x</code>, <code>y</code> and <code>z</code>, and puts <code>x</code>, <code>y</code>, <code>z</code> and <code>f(x,y,z)</code> in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p></div></div><div class="docstring"><div class="doc-header" id="convert_attribute"><a href="#convert_attribute">convert_attribute</a></div><div class="doc-content"><pre><code>convert_attribute(value, attribute::Key[, plottype::Key])</code></pre><p>Convert <code>value</code> into a suitable domain for use as <code>attribute</code>.</p><h1>Example</h1><pre><code class="language-jldoctest">julia&gt; using Makie

julia&gt; Makie.convert_attribute(:black, key"color"())
RGBA{Float32}(0.0f0,0.0f0,0.0f0,1.0f0)</code></pre></div></div><div class="docstring"><div class="doc-header" id="crossbar"><a href="#crossbar">crossbar</a></div><div class="doc-content"><pre><code>crossbar(x, y, ymin, ymax; kwargs...)</code></pre><p>Draw a crossbar. A crossbar represents a range with a (potentially notched) box. It is most commonly used as part of the <code>boxplot</code>.</p><h1>Arguments</h1><ul><li><p><code>x</code>: position of the box</p></li><li><p><code>y</code>: position of the midline within the box</p></li><li><p><code>ymin</code>: lower limit of the box</p></li><li><p><code>ymax</code>: upper limit of the box</p></li></ul><h1>Keywords</h1><ul><li><p><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=1</code>: width of the box before shrinking</p></li><li><p><code>gap=0.2</code>: shrinking factor, <code>width -&gt; width * (1 - gap)</code></p></li><li><p><code>show_notch=false</code>: draw the notch</p></li><li><p><code>notchmin=automatic</code>: lower limit of the notch</p></li><li><p><code>notchmax=automatic</code>: upper limit of the notch</p></li><li><p><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</p></li><li><p><code>show_midline=true</code>: show midline</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="crossbar!"><a href="#crossbar!">crossbar!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.crossbar!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "crossbar!" from Makie:
 [1] crossbar!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="current_axis"><a href="#current_axis">current_axis</a></div><div class="doc-content"><pre><code>current_axis()</code></pre><p>Returns the current active axis (or the last axis created). Returns <code>nothing</code> if there is no current active axis.</p></div></div><div class="docstring"><div class="doc-header" id="current_axis!"><a href="#current_axis!">current_axis!</a></div><div class="doc-content"><pre><code>current_axis!(fig::Figure, ax)</code></pre><p>Set <code>ax</code> as the current active axis in <code>fig</code>.</p><pre><code>current_axis!(ax)</code></pre><p>Set an axis <code>ax</code>, which must be part of a figure, as the figure's current active axis.</p></div></div><div class="docstring"><div class="doc-header" id="current_figure"><a href="#current_figure">current_figure</a></div><div class="doc-content"><pre><code>current_figure()</code></pre><p>Returns the current active figure (or the last figure created). Returns <code>nothing</code> if there is no current active figure.</p></div></div><div class="docstring"><div class="doc-header" id="current_figure!"><a href="#current_figure!">current_figure!</a></div><div class="doc-content"><pre><code>current_figure!(fig)</code></pre><p>Set <code>fig</code> as the current active figure.</p></div></div><div class="docstring"><div class="doc-header" id="data_limits"><a href="#data_limits">data_limits</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.data_limits</code> is a <code>Function</code>.</p><pre><code># 19 methods for generic function "data_limits" from Makie:
  [1] data_limits(hb::Plot{Makie.hexbin})
     @ ~/work/Makie.jl/Makie.jl/src/stats/hexbin.jl:65
  [2] data_limits(plot::MeshScatter)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:253
  [3] data_limits(plot::Image)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:246
  [4] data_limits(plot::Heatmap)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:239
  [5] data_limits(plot::Surface)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:232
  [6] data_limits(text::MakieCore.Text{&lt;:Tuple{var"#s317"} where var"#s317"&lt;:Union{Makie.GlyphCollection, AbstractVector{Makie.GlyphCollection}}})
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:43
  [7] data_limits(text::MakieCore.Text)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:56
  [8] data_limits(p::Plot{Makie.voronoiplot, &lt;:Tuple{var"#s317"} where var"#s317"&lt;:(Vector{&lt;:Point{N}})}) where N
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/voronoiplot.jl:170
  [9] data_limits(p::Plot{Makie.triplot, &lt;:Tuple{var"#s317"} where var"#s317"&lt;:(Vector{&lt;:Point})})
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/triplot.jl:244
 [10] data_limits(p::Plot{Makie.vspan})
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/hvspan.jl:107
 [11] data_limits(p::Plot{Makie.hspan})
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/hvspan.jl:97
 [12] data_limits(p::Plot{Makie.vlines})
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/hvlines.jl:100
 [13] data_limits(p::Plot{Makie.hlines})
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/hvlines.jl:91
 [14] data_limits(bars::Union{Plot{Makie.errorbars}, Plot{Makie.rangebars}})
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/error_and_rangebars.jl:296
 [15] data_limits(p::Plot{Makie.datashader})
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/datashader.jl:469
 [16] data_limits(pl::Plot{Makie.bracket})
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/bracket.jl:114
 [17] data_limits(plot::AbstractPlot)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:170
 [18] data_limits(scenelike, exclude)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:221
 [19] data_limits(scenelike)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:221</code></pre></div></div><div class="docstring"><div class="doc-header" id="datashader"><a href="#datashader">datashader</a></div><div class="doc-content"><pre><code>datashader(points::AbstractVector{&lt;: Point})</code></pre><div class="admonition warning"><p class="admonition-title">Warning</p><p>This feature might change outside breaking releases, since the API is not yet finalized. Please be vary of bugs in the implementation and open issues if you encounter odd behaviour.</p></div><p>Points can be any array type supporting iteration &amp; getindex, including memory mapped arrays. If you have separate arrays for x and y coordinates and want to avoid conversion and copy, consider using:</p><pre><code class="language-Julia">using Makie.StructArrays
points = StructArray{Point2f}((x, y))
datashader(points)</code></pre><p>Do pay attention though, that if x and y don't have a fast iteration/getindex implemented, this might be slower then just copying it into a new array.</p><p>For best performance, use <code>method=Makie.AggThreads()</code> and make sure to start julia with <code>julia -tauto</code> or have the environment variable <code>JULIA_NUM_THREADS</code> set to the number of cores you have.</p><h2>Attributes</h2><h3>Specific to <code>DataShader</code></h3><ul><li><p><code>agg = AggCount()</code> can be <code>AggCount()</code>, <code>AggAny()</code> or <code>AggMean()</code>. User extendable by overloading:</p></li></ul><pre><code>```Julia
    struct MyAgg{T} &lt;: Makie.AggOp end
    MyAgg() = MyAgg{Float64}()
    Makie.Aggregation.null(::MyAgg{T}) where {T} = zero(T)
    Makie.Aggregation.embed(::MyAgg{T}, x) where {T} = convert(T, x)
    Makie.Aggregation.merge(::MyAgg{T}, x::T, y::T) where {T} = x + y
    Makie.Aggregation.value(::MyAgg{T}, x::T) where {T} = x
```</code></pre><ul><li><p><code>method = AggThreads()</code> can be <code>AggThreads()</code> or <code>AggSerial()</code>.</p></li><li><p><code>async::Bool = true</code> will calculate get_aggregation in a task, and skip any zoom/pan updates while busy. Great for interaction, but must be disabled for saving to e.g. png or when inlining in documenter.</p></li><li><p><code>operation::Function = automatic</code> Defaults to <code>Makie.equalize_histogram</code> function which gets called on the whole get<em>aggregation array before display (`operation(final</em>aggregation_result)`).</p></li><li><p><code>local_operation::Function = identity</code> function which gets call on each element after the aggregation (<code>map!(x-&gt; local_operation(x), final_aggregation_result)</code>).</p></li><li><p><code>point_transform::Function = identity</code> function which gets applied to every point before aggregating it.</p></li><li><p><code>binsize::Number = 1</code> factor defining how many bins one wants per screen pixel. Set to n &gt; 1 if you want a corser image.</p></li><li><p><code>show_timings::Bool = false</code> show how long it takes to aggregate each frame.</p></li><li><p><code>interpolate::Bool = true</code> If the resulting image should be displayed interpolated.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="datashader!"><a href="#datashader!">datashader!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.datashader!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "datashader!" from Makie:
 [1] datashader!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="deactivate_interaction!"><a href="#deactivate_interaction!">deactivate_interaction!</a></div><div class="doc-content"><pre><code>deactivate_interaction!(parent, name::Symbol)</code></pre><p>Deactivate the interaction named <code>name</code> registered in <code>parent</code>. It can be reactivated with <code>activate_interaction!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="decompose"><a href="#decompose">decompose</a></div><div class="doc-content"><pre><code>decompose(facetype, contour::AbstractArray{&lt;:AbstractPoint})</code></pre><p>Triangulate a Polygon without hole.</p><p>Returns a Vector{<code>facetype</code>} defining indexes into <code>contour</code>.</p></div></div><div class="docstring"><div class="doc-header" id="default_theme"><a href="#default_theme">default_theme</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.default_theme</code> is a <code>Function</code>.</p><pre><code># 60 methods for generic function "default_theme" from MakieCore:
  [1] default_theme(scene, ::Type{&lt;:Plot{Main.FD_SANDBOX_12283929528957551597.stockchart}})
     @ Main.FD_SANDBOX_12283929528957551597 ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
  [2] default_theme(scene, ::Type{&lt;:Plot{RPRMakie.matball}})
     @ RPRMakie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
  [3] default_theme(scene, ::Type{&lt;:Plot{Makie.ablines}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
  [4] default_theme(scene, ::Type{&lt;:Plot{Makie.annotations}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
  [5] default_theme(scene, ::Type{&lt;:Plot{Makie.arc}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
  [6] default_theme(scene, ::Type{&lt;:Plot{Makie.axis3d}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
  [7] default_theme(scene, ::Type{&lt;:Plot{Makie.band}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
  [8] default_theme(scene, ::Type{&lt;:Plot{Makie.barplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
  [9] default_theme(scene, ::Type{&lt;:Plot{Makie.bracket}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [10] default_theme(scene, ::Type{&lt;:Plot{Makie.contour}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [11] default_theme(scene, ::Type{&lt;:Plot{Makie.contour3d}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [12] default_theme(scene, ::Type{&lt;:Plot{Makie.contourf}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [13] default_theme(scene, ::Type{&lt;:Plot{Makie.datashader}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [14] default_theme(scene, ::Type{&lt;:Plot{Makie.errorbars}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [15] default_theme(scene, ::Type{&lt;:Plot{Makie.rangebars}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [16] default_theme(scene, ::Type{&lt;:Plot{Makie.hlines}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [17] default_theme(scene, ::Type{&lt;:Plot{Makie.vlines}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [18] default_theme(scene, ::Type{&lt;:Plot{Makie.hspan}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [19] default_theme(scene, ::Type{&lt;:Plot{Makie.vspan}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [20] default_theme(scene, ::Type{&lt;:Plot{Makie.pie}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [21] default_theme(scene, ::Type{&lt;:Plot{Makie.scatterlines}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [22] default_theme(scene, ::Type{&lt;:Plot{Makie.spy}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [23] default_theme(scene, ::Type{&lt;:Plot{Makie.stairs}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [24] default_theme(scene, ::Type{&lt;:Plot{Makie.stem}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [25] default_theme(scene, ::Type{&lt;:Plot{Makie.streamplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [26] default_theme(scene, ::Type{&lt;:Plot{Makie.timeseries}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [27] default_theme(scene, ::Type{&lt;:Plot{Makie.tricontourf}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [28] default_theme(scene, ::Type{&lt;:Plot{Makie.triplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [29] default_theme(scene, ::Type{&lt;:Plot{Makie.volumeslices}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [30] default_theme(scene, ::Type{&lt;:Plot{Makie.voronoiplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [31] default_theme(scene, ::Type{&lt;:Plot{Makie.waterfall}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [32] default_theme(scene, ::Type{&lt;:Plot{Makie.tooltip}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [33] default_theme(scene, ::Type{&lt;:Plot{Makie.plotlist}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [34] default_theme(scene, ::Type{&lt;:Plot{Makie.stephist}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [35] default_theme(scene, ::Type{&lt;:Plot{Makie.hist}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [36] default_theme(scene, ::Type{&lt;:Plot{Makie.density}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [37] default_theme(scene, ::Type{&lt;:Plot{Makie.ecdfplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [38] default_theme(scene, ::Type{&lt;:Plot{Makie.qqplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [39] default_theme(scene, ::Type{&lt;:Plot{Makie.qqnorm}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [40] default_theme(scene, ::Type{&lt;:Plot{Makie.crossbar}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [41] default_theme(scene, ::Type{&lt;:Plot{Makie.boxplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [42] default_theme(scene, ::Type{&lt;:Plot{Makie.violin}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [43] default_theme(scene, ::Type{&lt;:Plot{Makie.hexbin}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [44] default_theme(scene, ::Type{&lt;:Plot{Makie.series}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [45] default_theme(scene, ::Type{&lt;:Plot{Makie.rainclouds}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [46] default_theme(scene, ::Type{&lt;:Arrows})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [47] default_theme(scene, ::Type{&lt;:Wireframe})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [48] default_theme(scene, ::Type{&lt;:Poly})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [49] default_theme(scene, ::Type{&lt;:MakieCore.Text})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [50] default_theme(scene, ::Type{&lt;:MeshScatter})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [51] default_theme(scene, ::Type{&lt;:Scatter})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [52] default_theme(scene, ::Type{&lt;:Image})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [53] default_theme(scene, ::Type{&lt;:Heatmap})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [54] default_theme(scene, ::Type{&lt;:Volume})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [55] default_theme(scene, ::Type{&lt;:Surface})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [56] default_theme(scene, ::Type{&lt;:Lines})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [57] default_theme(scene, ::Type{&lt;:LineSegments})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [58] default_theme(scene, ::Type{&lt;:Mesh})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:177
 [59] default_theme(scene)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/basic_plots.jl:1
 [60] default_theme(scene, T)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:62</code></pre></div></div><div class="docstring"><div class="doc-header" id="density"><a href="#density">density</a></div><div class="doc-content"><pre><code>density(values; npoints = 200, offset = 0.0, direction = :x)</code></pre><p>Plot a kernel density estimate of <code>values</code>. <code>npoints</code> controls the resolution of the estimate, the baseline can be shifted with <code>offset</code> and the <code>direction</code> set to <code>:x</code> or <code>:y</code>. <code>bandwidth</code> and <code>boundary</code> are determined automatically by default.</p><p>Statistical weights can be provided via the <code>weights</code> keyword argument.</p><p><code>color</code> is usually set to a single color, but can also be set to <code>:x</code> or <code>:y</code> to color with a gradient. If you use <code>:y</code> when <code>direction = :x</code> (or vice versa), note that only 2-element colormaps can work correctly.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.density}</code> are: </p><pre><code>  bandwidth     MakieCore.Automatic()
  boundary      MakieCore.Automatic()
  color         RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  colormap      :viridis
  colorrange    MakieCore.Automatic()
  colorscale    identity
  cycle         [:color =&gt; :patchcolor]
  direction     :x
  inspectable   true
  linestyle     "nothing"
  npoints       200
  offset        0.0
  strokearound  false
  strokecolor   :black
  strokewidth   0
  weights       MakieCore.Automatic()</code></pre></div></div><div class="docstring"><div class="doc-header" id="density!"><a href="#density!">density!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.density!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "density!" from Makie:
 [1] density!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="deregister_interaction!"><a href="#deregister_interaction!">deregister_interaction!</a></div><div class="doc-content"><pre><code>deregister_interaction!(parent, name::Symbol)</code></pre><p>Deregister the interaction named <code>name</code> registered in <code>parent</code>.</p></div></div><div class="docstring"><div class="doc-header" id="disconnect!"><a href="#disconnect!">disconnect!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.disconnect!</code> is a <code>Function</code>.</p><pre><code># 16 methods for generic function "disconnect!" from Makie:
  [1] disconnect!(window::GLFW.Window, ::typeof(unicode_input))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:167
  [2] disconnect!(window::GLFW.Window, ::typeof(hasfocus))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:272
  [3] disconnect!(window::GLFW.Window, ::typeof(mouse_position))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:218
  [4] disconnect!(::GLFW.Window, ::typeof(window_area))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:86
  [5] disconnect!(window::GLFW.Window, ::typeof(mouse_buttons))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:108
  [6] disconnect!(window::GLFW.Window, ::typeof(scroll))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:249
  [7] disconnect!(window::GLFW.Window, ::typeof(entered_window))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:294
  [8] disconnect!(window::GLFW.Window, ::typeof(dropped_files))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:144
  [9] disconnect!(window::GLFW.Window, ::typeof(keyboard_buttons))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:123
 [10] disconnect!(window::GLFW.Window, ::typeof(window_open))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:36
 [11] disconnect!(c::Camera)
     @ ~/work/Makie.jl/Makie.jl/src/camera/camera.jl:25
 [12] disconnect!(c::EmptyCamera)
     @ ~/work/Makie.jl/Makie.jl/src/camera/camera.jl:33
 [13] disconnect!(observables::Vector)
     @ ~/work/Makie.jl/Makie.jl/src/camera/camera.jl:37
 [14] disconnect!(screen::GLMakie.Screen, ::typeof(window_area))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:80
 [15] disconnect!(screen::GLMakie.Screen, ::typeof(mouse_position))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:214
 [16] disconnect!(window::MakieScreen, signal)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/events.jl:35</code></pre></div></div><div class="docstring"><div class="doc-header" id="dropped_files"><a href="#dropped_files">dropped_files</a></div><div class="doc-content"><p>Registers a callback for drag and drop of files. returns <code>Observable{Vector{String}}</code>, which are absolute file paths <a href="http://www.glfw.org/docs/latest/group__input.html#gacc95e259ad21d4f666faa6280d4018fd">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="ecdfplot"><a href="#ecdfplot">ecdfplot</a></div><div class="doc-content"><pre><code>ecdfplot(values; npoints=10_000[, weights])</code></pre><p>Plot the empirical cumulative distribution function (ECDF) of <code>values</code>.</p><p><code>npoints</code> controls the resolution of the plot. If <code>weights</code> for the values are provided, a weighted ECDF is plotted.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.ecdfplot}</code> are: </p><pre><code>  alpha           1.0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  cycle           [:color]
  depth_shift     0.0f0
  highclip        MakieCore.Automatic()
  inspectable     true
  linestyle       "nothing"
  linewidth       1.5
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  space           :data
  ssao            false
  step            :pre
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="ecdfplot!"><a href="#ecdfplot!">ecdfplot!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.ecdfplot!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "ecdfplot!" from Makie:
 [1] ecdfplot!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="entered_window"><a href="#entered_window">entered_window</a></div><div class="doc-content"><p>Registers a callback for if the mouse has entered the window. returns an <code>Observable{Bool}</code>, which is true whenever the cursor enters the window. <a href="http://www.glfw.org/docs/latest/group__input.html#ga762d898d9b0241d7e3e3b767c6cf318f">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="errorbars"><a href="#errorbars">errorbars</a></div><div class="doc-content"><pre><code>errorbars(x, y, error_both; kwargs...)
errorbars(x, y, error_low, error_high; kwargs...)
errorbars(x, y, error_low_high; kwargs...)

errorbars(xy, error_both; kwargs...)
errorbars(xy, error_low, error_high; kwargs...)
errorbars(xy, error_low_high; kwargs...)

errorbars(xy_error_both; kwargs...)
errorbars(xy_error_low_high; kwargs...)</code></pre><p>Plots errorbars at xy positions, extending by errors in the given <code>direction</code>.</p><p>If you want to plot intervals from low to high values instead of relative errors, use <code>rangebars</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.errorbars}</code> are: </p><pre><code>  color         :black
  colormap      :viridis
  colorrange    MakieCore.Automatic()
  colorscale    identity
  cycle         [:color]
  direction     :y
  inspectable   true
  linewidth     1.5
  transparency  false
  visible       true
  whiskerwidth  0</code></pre></div></div><div class="docstring"><div class="doc-header" id="errorbars!"><a href="#errorbars!">errorbars!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.errorbars!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "errorbars!" from Makie:
 [1] errorbars!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="events"><a href="#events">events</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.events</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "events" from Makie:
 [1] events(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:491
 [2] events(scene::Union{AbstractScene, MakieCore.ScenePlot})
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:492
 [3] events(x)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:490</code></pre></div></div><div class="docstring"><div class="doc-header" id="fill_between!"><a href="#fill_between!">fill_between!</a></div><div class="doc-content"><pre><code>fill_between!(scenelike, x, y1, y2; where = nothing, kw_args...)</code></pre><p>fill the section between 2 lines with the condition <code>where</code></p></div></div><div class="docstring"><div class="doc-header" id="grid!"><a href="#grid!">grid!</a></div><div class="doc-content"><pre><code>grid!(content::Vararg{Pair}; kwargs...)</code></pre><p>Creates a GridLayout with all pairs contained in <code>content</code>. Each pair consists of an iterable with row and column spans, and a content object. Each content object is then placed in the GridLayout at the span from its pair.</p><p>Example:</p><p>grid!(     [1, 1] =&gt; obj1,     [1, 2] =&gt; obj2,     [2, :] =&gt; obj3, )</p><pre><code>grid!(content::AbstractMatrix; kwargs...)</code></pre><p>Creates a GridLayout filled with matrix-like content. The size of the grid will be the size of the matrix.</p></div></div><div class="docstring"><div class="doc-header" id="gridnest!"><a href="#gridnest!">gridnest!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.gridnest!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "gridnest!" from GridLayoutBase:
 [1] gridnest!(gl::GridLayout, rows::Union{Colon, Int64, UnitRange}, cols::Union{Colon, Int64, UnitRange})
     @ ~/.julia/packages/GridLayoutBase/Ld41D/src/gridlayout.jl:594</code></pre></div></div><div class="docstring"><div class="doc-header" id="hasfocus"><a href="#hasfocus">hasfocus</a></div><div class="doc-content"><p>Registers a callback for the focus of a window. returns an <code>Observable{Bool}</code>, which is true whenever the window has focus. <a href="http://www.glfw.org/docs/latest/group__window.html#ga6b5f973531ea91663ad707ba4f2ac104">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="heatmap"><a href="#heatmap">heatmap</a></div><div class="doc-content"><pre><code>heatmap(x, y, matrix)
heatmap(x, y, func)
heatmap(matrix)
heatmap(xvector, yvector, zvector)</code></pre><p>Plots a heatmap as a collection of rectangles. <code>x</code> and <code>y</code> can either be of length <code>i</code> and <code>j</code> where <code>(i, j)</code> is <code>size(matrix)</code>, in this case the rectangles will be placed around these grid points like voronoi cells. Note that for irregularly spaced <code>x</code> and <code>y</code>, the points specified by them are not centered within the resulting rectangles.</p><p><code>x</code> and <code>y</code> can also be of length <code>i+1</code> and <code>j+1</code>, in this case they are interpreted as the edges of the rectangles.</p><p>Colors of the rectangles are derived from <code>matrix[i, j]</code>. The third argument may also be a <code>Function</code> (i, j) -&gt; v which is then evaluated over the grid spanned by <code>x</code> and <code>y</code>.</p><p>Another allowed form is using three vectors <code>xvector</code>, <code>yvector</code> and <code>zvector</code>. In this case it is assumed that no pair of elements <code>x</code> and <code>y</code> exists twice. Pairs that are missing from the resulting grid will be treated as if <code>zvector</code> had a <code>NaN</code>     element at that position.</p><p>If <code>x</code> and <code>y</code> are omitted with a matrix argument, they default to <code>x, y = axes(matrix)</code>.</p><p>Note that <code>heatmap</code> is slower to render than <code>image</code> so <code>image</code> should be preferred for large, regularly spaced grids.</p><h2>Attributes</h2><h3>Specific to <code>Heatmap</code></h3><ul><li><p><code>interpolate::Bool = false</code> sets whether colors should be interpolated.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="heatmap!"><a href="#heatmap!">heatmap!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.heatmap!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "heatmap!" from MakieCore:
 [1] heatmap!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="height"><a href="#height">height</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.height</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "height" from GeometryBasics:
 [1] height(c::GeometryBasics.Cylinder{N, T}) where {N, T}
     @ ~/.julia/packages/GeometryBasics/ebXl0/src/primitives/cylinders.jl:26
 [2] height(prim::GeometryBasics.HyperRectangle)
     @ ~/.julia/packages/GeometryBasics/ebXl0/src/primitives/rectangles.jl:187</code></pre></div></div><div class="docstring"><div class="doc-header" id="help"><a href="#help">help</a></div><div class="doc-content"><pre><code>help(func[; extended = false])</code></pre><p>Welcome to the main help function of <code>Makie.jl</code> / <code>Makie.jl</code>.</p><p>For help on a specific function's arguments, type <code>help_arguments(function_name)</code>.</p><p>For help on a specific function's attributes, type <code>help_attributes(plot_Type)</code>.</p><p>Use the optional <code>extended = true</code> keyword argument to see more details.</p></div></div><div class="docstring"><div class="doc-header" id="help_arguments"><a href="#help_arguments">help_arguments</a></div><div class="doc-content"><pre><code>help_arguments([io], func)</code></pre><p>Returns a list of signatures for function <code>func</code>.</p></div></div><div class="docstring"><div class="doc-header" id="help_attributes"><a href="#help_attributes">help_attributes</a></div><div class="doc-content"><pre><code>help_attributes([io], Union{PlotType, PlotFunction}; extended = false)</code></pre><p>Returns a list of attributes for the plot type <code>Typ</code>. The attributes returned extend those attributes found in the <code>default_theme</code>.</p><p>Use the optional keyword argument <code>extended</code> (default = <code>false</code>) to show in addition the default values of each attribute. usage:</p><pre><code class="language-julia">&gt;help_attributes(scatter)
    alpha
    color
    colormap
    colorrange
    distancefield
    glowcolor
    glowwidth
    linewidth
    marker
    marker_offset
    markersize
    overdraw
    rotations
    strokecolor
    strokewidth
    transform_marker
    transparency
    uv_offset_width
    visible</code></pre></div></div><div class="docstring"><div class="doc-header" id="hexbin"><a href="#hexbin">hexbin</a></div><div class="doc-content"><pre><code>hexbin(xs, ys; kwargs...)</code></pre><p>Plots a heatmap with hexagonal bins for the observations <code>xs</code> and <code>ys</code>.</p><h2>Attributes</h2><h3>Specific to <code>Hexbin</code></h3><ul><li><p><code>weights = nothing</code>: Weights for each observation.  Can be <code>nothing</code> (each observation carries weight 1) or any <code>AbstractVector{&lt;: Real}</code> or <code>StatsBase.AbstractWeights</code>.</p></li><li><p><code>bins = 20</code>: If an <code>Int</code>, sets the number of bins in x and y direction. If a <code>Tuple{Int, Int}</code>, sets the number of bins for x and y separately.</p></li><li><p><code>cellsize = nothing</code>: If a <code>Real</code>, makes equally-sided hexagons with width <code>cellsize</code>. If a <code>Tuple{Real, Real}</code> specifies hexagon width and height separately.</p></li><li><p><code>threshold::Int = 1</code>: The minimal number of observations in the bin to be shown. If 0, all zero-count hexagons fitting into the data limits will be shown.</p></li><li><p><code>colorscale = identity</code>: A function to scale the number of observations in a bin, eg. log10.</p></li></ul><h3>Generic</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code></p></li><li><p><code>colorrange::Tuple(&lt;:Real,&lt;:Real} = Makie.automatic</code>  sets the values representing the start and end points of <code>colormap</code>.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="hexbin!"><a href="#hexbin!">hexbin!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.hexbin!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "hexbin!" from Makie:
 [1] hexbin!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="hgrid!"><a href="#hgrid!">hgrid!</a></div><div class="doc-content"><pre><code>hbox!(content::Vararg; kwargs...)</code></pre><p>Creates a single-row GridLayout with all elements contained in <code>content</code> placed from left to right.</p></div></div><div class="docstring"><div class="doc-header" id="hidedecorations!"><a href="#hidedecorations!">hidedecorations!</a></div><div class="doc-content"><pre><code>hidedecorations!(la::Axis; label = true, ticklabels = true, ticks = true,
                 grid = true, minorgrid = true, minorticks = true)</code></pre><p>Hide decorations of both x and y-axis: label, ticklabels, ticks and grid. Keyword arguments can be used to disable hiding of certain types of decorations.</p><p>See also [<code>hidexdecorations!</code>], [<code>hideydecorations!</code>], [<code>hidezdecorations!</code>]</p><pre><code>hidedecorations!(ax::PolarAxis; ticklabels = true, grid = true, minorgrid = true)</code></pre><p>Hide decorations of both r and theta-axis: label, ticklabels, ticks and grid. Keyword arguments can be used to disable hiding of certain types of decorations.</p><p>See also [<code>hiderdecorations!</code>], [<code>hidethetadecorations!</code>], [<code>hidezdecorations!</code>]</p></div></div><div class="docstring"><div class="doc-header" id="hiderdecorations!"><a href="#hiderdecorations!">hiderdecorations!</a></div><div class="doc-content"><pre><code>hiderdecorations!(ax::PolarAxis; ticklabels = true, grid = true, minorgrid = true)</code></pre><p>Hide decorations of the r-axis: label, ticklabels, ticks and grid. Keyword arguments can be used to disable hiding of certain types of decorations.</p></div></div><div class="docstring"><div class="doc-header" id="hidespines!"><a href="#hidespines!">hidespines!</a></div><div class="doc-content"><pre><code>hidespines!(la::Axis, spines::Symbol... = (:l, :r, :b, :t)...)</code></pre><p>Hide all specified axis spines. Hides all spines by default, otherwise choose which sides to hide with the symbols :l (left), :r (right), :b (bottom) and :t (top).</p></div></div><div class="docstring"><div class="doc-header" id="hidethetadecorations!"><a href="#hidethetadecorations!">hidethetadecorations!</a></div><div class="doc-content"><pre><code>hidethetadecorations!(ax::PolarAxis; ticklabels = true, grid = true, minorgrid = true)</code></pre><p>Hide decorations of the theta-axis: label, ticklabels, ticks and grid. Keyword arguments can be used to disable hiding of certain types of decorations.</p></div></div><div class="docstring"><div class="doc-header" id="hidexdecorations!"><a href="#hidexdecorations!">hidexdecorations!</a></div><div class="doc-content"><pre><code>hidexdecorations!(la::Axis; label = true, ticklabels = true, ticks = true, grid = true,
    minorgrid = true, minorticks = true)</code></pre><p>Hide decorations of the x-axis: label, ticklabels, ticks and grid. Keyword arguments can be used to disable hiding of certain types of decorations.</p></div></div><div class="docstring"><div class="doc-header" id="hideydecorations!"><a href="#hideydecorations!">hideydecorations!</a></div><div class="doc-content"><pre><code>hideydecorations!(la::Axis; label = true, ticklabels = true, ticks = true, grid = true,
    minorgrid = true, minorticks = true)</code></pre><p>Hide decorations of the y-axis: label, ticklabels, ticks and grid. Keyword arguments can be used to disable hiding of certain types of decorations.</p></div></div><div class="docstring"><div class="doc-header" id="hidezdecorations!"><a href="#hidezdecorations!">hidezdecorations!</a></div><div class="doc-content"><pre><code>hidezdecorations!(ax::Axis3; label = true, ticklabels = true, ticks = true, grid = true)</code></pre><p>Hide decorations of the z-axis: label, ticklabels, ticks and grid. Keyword arguments can be used to disable hiding of certain types of decorations.</p></div></div><div class="docstring"><div class="doc-header" id="hist"><a href="#hist">hist</a></div><div class="doc-content"><pre><code>hist(values; bins = 15, normalization = :none)</code></pre><p>Plot a histogram of <code>values</code>. <code>bins</code> can be an <code>Int</code> to create that number of equal-width bins over the range of <code>values</code>. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting <code>normalization</code>. Possible values are:</p><ul><li><p><code>:pdf</code>: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.</p></li><li><p><code>:density</code>: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1. Will not modify the  histogram if it already represents a density (<code>h.isdensity == 1</code>).</p></li><li><p><code>:probability</code>: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.</p></li><li><p><code>:none</code>: Do not normalize.</p></li></ul><p>Statistical weights can be provided via the <code>weights</code> keyword argument.</p><p>The following attributes can move the histogram around, which comes in handy when placing multiple histograms into one plot:</p><ul><li><p><code>offset = 0.0</code>: adds an offset to every value</p></li><li><p><code>fillto = 0.0</code>: defines where the bar starts</p></li><li><p><code>scale_to = nothing</code>: allows to scale all values to a certain height. This</p></li></ul><p>can also be set to <code>:flip</code> to flip the direction of histogram bars without scaling them to a common height.</p><p>Color can either be:</p><ul><li><p>a vector of <code>bins</code> colors</p></li><li><p>a single color</p></li><li><p><code>:values</code>, to color the bars with the values from the histogram</p></li></ul><p>You can also draw a histogram in x-direction rather than y-direction by setting <code>direction = :x</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.hist}</code> are: </p><pre><code>  bar_labels             "nothing"
  bins                   15
  color                  RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  cycle                  [:color =&gt; :patchcolor]
  fillto                 MakieCore.Automatic()
  flip_labels_at         Inf
  label_color            :black
  label_font             :regular
  label_formatter        Makie.bar_label_formatter
  label_offset           5
  label_size             20
  normalization          :none
  offset                 0.0
  over_background_color  MakieCore.Automatic()
  over_bar_color         MakieCore.Automatic()
  scale_to               "nothing"
  weights                MakieCore.Automatic()</code></pre></div></div><div class="docstring"><div class="doc-header" id="hist!"><a href="#hist!">hist!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.hist!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "hist!" from Makie:
 [1] hist!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="hlines"><a href="#hlines">hlines</a></div><div class="doc-content"><pre><code>hlines(ys; xmin = 0.0, xmax = 1.0, attrs...)</code></pre><p>Create horizontal lines across a <code>Scene</code> with 2D projection. The lines will be placed at <code>ys</code> in data coordinates and <code>xmin</code> to <code>xmax</code> in scene coordinates (0 to 1). All three of these can have single or multiple values because they are broadcast to calculate the final line segments.</p><p>All style attributes are the same as for <code>LineSegments</code>.</p></div></div><div class="docstring"><div class="doc-header" id="hlines!"><a href="#hlines!">hlines!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.hlines!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "hlines!" from Makie:
 [1] hlines!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="hovered_scene"><a href="#hovered_scene">hovered_scene</a></div><div class="doc-content"><pre><code>hovered_scene()</code></pre><p>Returns the <code>scene</code> that the mouse is currently hovering over.</p><p>Properly identifies the scene for a plot with multiple sub-plots.</p></div></div><div class="docstring"><div class="doc-header" id="hspan"><a href="#hspan">hspan</a></div><div class="doc-content"><pre><code>hspan(ys_low, ys_high; xmin = 0.0, xmax = 1.0, attrs...)
hspan(ys_lowhigh; xmin = 0.0, xmax = 1.0, attrs...)</code></pre><p>Create horizontal bands spanning across a <code>Scene</code> with 2D projection. The bands will be placed from <code>ys_low</code> to <code>ys_high</code> in data coordinates and <code>xmin</code> to <code>xmax</code> in scene coordinates (0 to 1). All four of these can have single or multiple values because they are broadcast to calculate the final spans. Both bounds can be passed together as an interval <code>ys_lowhigh</code>.</p><p>All style attributes are the same as for <code>Poly</code>.</p></div></div><div class="docstring"><div class="doc-header" id="hspan!"><a href="#hspan!">hspan!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.hspan!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "hspan!" from Makie:
 [1] hspan!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="image"><a href="#image">image</a></div><div class="doc-content"><pre><code>image(x, y, image)
image(image)</code></pre><p>Plots an image on a rectangle bounded by <code>x</code> and <code>y</code> (defaults to size of image).</p><h2>Attributes</h2><h3>Specific to <code>Image</code></h3><ul><li><p><code>interpolate::Bool = true</code> sets whether colors should be interpolated.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="image!"><a href="#image!">image!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.image!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "image!" from MakieCore:
 [1] image!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="insertplots!"><a href="#insertplots!">insertplots!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.insertplots!</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "insertplots!" from Makie:
 [1] insertplots!(screen::GLMakie.Screen, scene::Scene)
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/screen.jl:462
 [2] insertplots!(screen::AbstractDisplay, scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:534</code></pre></div></div><div class="docstring"><div class="doc-header" id="interactions"><a href="#interactions">interactions</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.interactions</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "interactions" from Makie:
 [1] interactions(ax3::Axis3)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/interactions.jl:5
 [2] interactions(ax::Axis)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/interactions.jl:4</code></pre></div></div><div class="docstring"><div class="doc-header" id="is_mouseinside"><a href="#is_mouseinside">is_mouseinside</a></div><div class="doc-content"><pre><code>is_mouseinside(scene)</code></pre><p>Returns true if the current mouseposition is inside the given scene.</p></div></div><div class="docstring"><div class="doc-header" id="ispressed"><a href="#ispressed">ispressed</a></div><div class="doc-content"><p>ispressed(parent, result::Bool[, waspressed = nothing]) ispressed(parent, button::Union{Mouse.Button, Keyboard.Button[, waspressed = nothing])     ispressed(parent, collection::Union{Set, Vector, Tuple}[, waspressed = nothing])     ispressed(parent, op::BooleanOperator[, waspressed = nothing])</p><p>This function checks if a button or combination of buttons is pressed.</p><p>If given a true or false, <code>ispressed</code> will return true or false respectively. This provides a way to turn an interaction "always on" or "always off" from the outside.</p><p>Passing a button or collection of buttons such as <code>Keyboard.enter</code> or <code>Mouse.left</code> will return true if all of the given buttons are pressed.</p><p>Parent can be any object that has <code>get_scene</code> method implemented, which includes e.g. Figure, Axis, Axis3, Lscene, FigureAxisPlot, and AxisPlot.</p><p>For more complicated combinations of buttons they can be combined into boolean expression with <code>&amp;</code>, <code>|</code> and <code>!</code>. For example, you can have <code>ispressed(parent, !Keyboard.left_control &amp; Keyboard.c))</code> and <code>ispressed(parent, Keyboard.left_control &amp; Keyboard.c)</code> to avoid triggering both cases at the same time.</p><p>Furthermore you can also make any button, button collection or boolean expression exclusive by wrapping it in <code>Exclusively(...)</code>. With that <code>ispressed</code> will only return true if the currently pressed buttons match the request exactly.</p><p>For cases where you want to react to a release event you can optionally add a key or mousebutton <code>waspressed</code> which is then assumed to be pressed regardless of it's current state. For example, when reacting to a mousebutton event, you can pass <code>event.button</code> so that a key combination including that button still evaluates as true.</p><p>See also: <a href="@ref"><code>waspressed</code></a><a href="@ref"><code>And</code></a>, <a href="@ref"><code>Or</code></a>, <a href="@ref"><code>Not</code></a>, <a href="@ref"><code>Exclusively</code></a>, <a href="@ref"><code>&amp;</code></a>, <a href="@ref"><code>|</code></a>, <a href="@ref"><code>!</code></a></p></div></div><div class="docstring"><div class="doc-header" id="keyboard_buttons"><a href="#keyboard_buttons">keyboard_buttons</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.keyboard_buttons</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "keyboard_buttons" from Makie:
 [1] keyboard_buttons(scene::Scene, window::GLFW.Window)
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:112
 [2] keyboard_buttons(scene::Scene, screen)
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:111
 [3] keyboard_buttons(scene, native_window)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/events.jl:8</code></pre></div></div><div class="docstring"><div class="doc-header" id="labelslider!"><a href="#labelslider!">labelslider!</a></div><div class="doc-content"><pre><code>labelslider!(scene, label, range; format = string, sliderkw = Dict(),
labelkw = Dict(), valuekw = Dict(), value_column_width = automatic, layoutkw...)</code></pre><p><strong><code>labelslider!</code> is deprecated, use <code>SliderGrid</code> instead</strong></p><p>Construct a horizontal GridLayout with a label, a slider and a value label in <code>scene</code>.</p><p>Returns a <code>NamedTuple</code>:</p><p><code>(slider = slider, label = label, valuelabel = valuelabel, layout = layout)</code></p><p>Specify a format function for the value label with the <code>format</code> keyword or pass a format string used by <code>Format.format</code>. The slider is forwarded the keywords from <code>sliderkw</code>. The label is forwarded the keywords from <code>labelkw</code>. The value label is forwarded the keywords from <code>valuekw</code>. You can set the column width for the value label column with the keyword <code>value_column_width</code>. By default, the width is determined heuristically by sampling a few values from the slider range. All other keywords are forwarded to the <code>GridLayout</code>.</p><p>Example:</p><pre><code>ls = labelslider!(scene, "Voltage:", 0:10; format = x -&gt; "$(x)V")
layout[1, 1] = ls.layout</code></pre></div></div><div class="docstring"><div class="doc-header" id="labelslidergrid!"><a href="#labelslidergrid!">labelslidergrid!</a></div><div class="doc-content"><pre><code>labelslidergrid!(scene, labels, ranges; formats = [string],
    sliderkw = Dict(), labelkw = Dict(), valuekw = Dict(),
    value_column_width = automatic, layoutkw...)</code></pre><p><strong><code>labelslidergrid!</code> is deprecated, use <code>SliderGrid</code> instead</strong></p><p>Construct a GridLayout with a column of label, a column of sliders and a column of value labels in <code>scene</code>. The argument values are broadcast, so you can use scalars if you want to keep labels, ranges or formats constant across rows.</p><p>Returns a <code>NamedTuple</code>:</p><p><code>(sliders = sliders, labels = labels, valuelabels = valuelabels, layout = layout)</code></p><p>Specify format functions for the value labels with the <code>formats</code> keyword or pass format strings used by <code>Format.format</code>. The sliders are forwarded the keywords from <code>sliderkw</code>. The labels are forwarded the keywords from <code>labelkw</code>. The value labels are forwarded the keywords from <code>valuekw</code>. You can set the column width for the value label column with the keyword <code>value_column_width</code>. By default, the width is determined heuristically by sampling a few values from the slider ranges. All other keywords are forwarded to the <code>GridLayout</code>.</p><p>Example:</p><pre><code>ls = labelslidergrid!(scene, ["Voltage", "Ampere"], Ref(0:0.1:100); format = x -&gt; "$(x)V")
layout[1, 1] = ls.layout</code></pre></div></div><div class="docstring"><div class="doc-header" id="left"><a href="#left">left</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.left</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "left" from Makie:
 [1] left(rect::Rect2)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:2</code></pre></div></div><div class="docstring"><div class="doc-header" id="lift"><a href="#lift">lift</a></div><div class="doc-content"><pre><code>map(f, c...) -&gt; collection</code></pre><p>Transform collection <code>c</code> by applying <code>f</code> to each element. For multiple collection arguments, apply <code>f</code> elementwise, and stop when any of them is exhausted.</p><p>See also <a href="@ref"><code>map!</code></a>, <a href="@ref"><code>foreach</code></a>, <a href="@ref"><code>mapreduce</code></a>, <a href="@ref"><code>mapslices</code></a>, <a href="@ref"><code>zip</code></a>, <a href="@ref"><code>Iterators.map</code></a>.</p><h1>Examples</h1><pre><code class="language-jldoctest">julia&gt; map(x -&gt; x * 2, [1, 2, 3])
3-element Vector{Int64}:
 2
 4
 6

julia&gt; map(+, [1, 2, 3], [10, 20, 30, 400, 5000])
3-element Vector{Int64}:
 11
 22
 33</code></pre><pre><code>map(f, A::AbstractArray...) -&gt; N-array</code></pre><p>When acting on multi-dimensional arrays of the same <a href="@ref"><code>ndims</code></a>, they must all have the same <a href="@ref"><code>axes</code></a>, and the answer will too.</p><p>See also <a href="@ref"><code>broadcast</code></a>, which allows mismatched sizes.</p><h1>Examples</h1><pre><code>julia&gt; map(//, [1 2; 3 4], [4 3; 2 1])
2Ã2 Matrix{Rational{Int64}}:
 1//4  2//3
 3//2  4//1

julia&gt; map(+, [1 2; 3 4], zeros(2,1))
ERROR: DimensionMismatch

julia&gt; map(+, [1 2; 3 4], [1,10,100,1000], zeros(3,1))  # iterates until 3rd is exhausted
3-element Vector{Float64}:
   2.0
  13.0
 102.0</code></pre><pre><code>obs = map(f, arg1::AbstractObservable, args...; ignore_equal_values=false)</code></pre><p>Creates a new observable <code>obs</code> which contains the result of <code>f</code> applied to values extracted from <code>arg1</code> and <code>args</code> (i.e., <code>f(arg1[], ...)</code>. <code>arg1</code> must be an observable for dispatch reasons. <code>args</code> may contain any number of <code>Observable</code> objects. <code>f</code> will be passed the values contained in the observables as the respective argument. All other objects in <code>args</code> are passed as-is.</p><p>If you don't need the value of <code>obs</code>, and just want to run <code>f</code> whenever the arguments update, use <a href="@ref"><code>on</code></a> or <a href="@ref"><code>onany</code></a> instead.</p><h1>Example</h1><pre><code class="language-jldoctest; setup=:(using Observables)">julia&gt; obs = Observable([1,2,3]);

julia&gt; map(length, obs)
Observable(3)</code></pre></div></div><div class="docstring"><div class="doc-header" id="limits!"><a href="#limits!">limits!</a></div><div class="doc-content"><pre><code>limits!(ax::Axis, xlims, ylims)</code></pre><p>Set the axis limits to <code>xlims</code> and <code>ylims</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis, x1, x2, y1, y2)</code></pre><p>Set the axis x-limits to <code>x1</code> and <code>x2</code> and the y-limits to <code>y1</code> and <code>y2</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis, rect::Rect2)</code></pre><p>Set the axis limits to <code>rect</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis3, xlims, ylims, zlims)</code></pre><p>Set the axis limits to <code>xlims</code>, <code>ylims</code>, and <code>zlims</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis3, x1, x2, y1, y2, z1, z2)</code></pre><p>Set the axis x-limits to <code>x1</code> and <code>x2</code>, the y-limits to <code>y1</code> and <code>y2</code>, and the z-limits to <code>z1</code> and <code>z2</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis3, rect::Rect3)</code></pre><p>Set the axis limits to <code>rect</code>. If limits are ordered high-low, this reverses the axis orientation.</p></div></div><div class="docstring"><div class="doc-header" id="lines"><a href="#lines">lines</a></div><div class="doc-content"><pre><code>lines(positions)
lines(x, y)
lines(x, y, z)</code></pre><p>Creates a connected line plot for each element in <code>(x, y, z)</code>, <code>(x, y)</code> or <code>positions</code>.</p><p><code>NaN</code> values are displayed as gaps in the line.</p><h2>Attributes</h2><h3>Specific to <code>Lines</code></h3><ul><li><p><code>color=theme(scene, :linecolor)</code> sets the color of the line. If no color is set, multiple calls to <code>line!</code> will cycle through the axis color palette. Otherwise, one can set one color per line point by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole line. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>linestyle::Union{Nothing, Symbol, Linestyle} = nothing</code> sets the pattern of the line e.g. <code>:solid</code>, <code>:dot</code>, <code>:dashdot</code>. For custom patterns look at <code>Linestyle(Number[...])</code>.</p></li><li><p><code>linewidth::Union{Real, Vector} = 1.5</code> sets the width of the line in pixel units.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="lines!"><a href="#lines!">lines!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.lines!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "lines!" from MakieCore:
 [1] lines!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="linesegments"><a href="#linesegments">linesegments</a></div><div class="doc-content"><pre><code>linesegments(positions)
linesegments(vector_of_2tuples_of_points)
linesegments(x, y)
linesegments(x, y, z)</code></pre><p>Plots a line for each pair of points in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><h2>Attributes</h2><h3>Specific to <code>LineSegments</code></h3><ul><li><p><code>color=theme(scene, :linecolor)</code> sets the color of the linesegments. If no color is set, multiple calls to <code>linesegments!</code> will cycle through the axis color palette. Otherwise, one can set one color per line point or one color per linesegment by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole line. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>linestyle::Union{Nothing, Symbol, Vector} = nothing</code> sets the pattern of the line (e.g. <code>:solid</code>, <code>:dot</code>, <code>:dashdot</code>)</p></li><li><p><code>linewidth::Union{Real, Vector} = 1.5</code> sets the width of the line in pixel units.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="linesegments!"><a href="#linesegments!">linesegments!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.linesegments!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "linesegments!" from MakieCore:
 [1] linesegments!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="linkaxes!"><a href="#linkaxes!">linkaxes!</a></div><div class="doc-content"><pre><code>linkaxes!(a::Axis, others...)</code></pre><p>Link both x and y axes of all given <code>Axis</code> so that they stay synchronized.</p></div></div><div class="docstring"><div class="doc-header" id="linkxaxes!"><a href="#linkxaxes!">linkxaxes!</a></div><div class="doc-content"><pre><code>linkxaxes!(a::Axis, others...)</code></pre><p>Link the x axes of all given <code>Axis</code> so that they stay synchronized.</p></div></div><div class="docstring"><div class="doc-header" id="linkyaxes!"><a href="#linkyaxes!">linkyaxes!</a></div><div class="doc-content"><pre><code>linkyaxes!(a::Axis, others...)</code></pre><p>Link the y axes of all given <code>Axis</code> so that they stay synchronized.</p></div></div><div class="docstring"><div class="doc-header" id="mesh"><a href="#mesh">mesh</a></div><div class="doc-content"><pre><code>mesh(x, y, z)
mesh(mesh_object)
mesh(x, y, z, faces)
mesh(xyz, faces)</code></pre><p>Plots a 3D or 2D mesh. Supported <code>mesh_object</code>s include <code>Mesh</code> types from <a href="https://github.com/JuliaGeometry/GeometryBasics.jl">GeometryBasics.jl</a>.</p><h2>Attributes</h2><h3>Specific to <code>Mesh</code></h3><ul><li><p><code>color=theme(scene, :patchcolor)</code> sets the color of the mesh. Can be a <code>Vector{&lt;:Colorant}</code> for per vertex colors or a single <code>Colorant</code>.  A <code>Matrix{&lt;:Colorant}</code> can be used to color the mesh with a texture, which requires the mesh to contain texture coordinates.  Vector or Matrices of numbers can be used as well, which will use the colormap arguments to map the numbers to colors.</p></li><li><p><code>interpolate::Bool = false</code> sets whether colors should be interpolated.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = Makie.automatic</code> sets the lighting algorithm used. Options are <code>NoShading</code> (no lighting), <code>FastShading</code> (AmbientLight + PointLight) or <code>MultiLightShading</code> (Multiple lights, GLMakie only). Note that this does not affect RPRMakie.</p></li><li><p><code>diffuse::Vec3f = Vec3f(1.0)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.4)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>backlight::Float32 = 0f0</code> sets a weight for secondary light calculation with inverted normals.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="mesh!"><a href="#mesh!">mesh!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.mesh!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "mesh!" from MakieCore:
 [1] mesh!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="meshscatter"><a href="#meshscatter">meshscatter</a></div><div class="doc-content"><pre><code>meshscatter(positions)
meshscatter(x, y)
meshscatter(x, y, z)</code></pre><p>Plots a mesh for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code> (similar to <code>scatter</code>). <code>markersize</code> is a scaling applied to the primitive passed as <code>marker</code>.</p><h2>Attributes</h2><h3>Specific to <code>MeshScatter</code></h3><ul><li><p><code>color = theme(scene, :markercolor)</code> sets the color of the marker. If no color is set, multiple calls to <code>meshscatter!</code> will cycle through the axis color palette. Otherwise, one can set one color per point by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole meshscatterplot. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>marker::Union{Symbol, GeometryBasics.GeometryPrimitive, GeometryBasics.Mesh}</code> sets the scattered mesh.</p></li><li><p><code>markersize::Union{&lt;:Real, Vec3f} = 0.1</code> sets the scale of the mesh. This can be given as a Vector to apply to each scattered mesh individually.</p></li><li><p><code>rotations::Union{Real, Vec3f, Quaternion} = 0</code> sets the rotation of the mesh. A numeric rotation is around the z-axis, a <code>Vec3f</code> causes the mesh to rotate such that the the z-axis is now that vector, and a quaternion describes a general rotation. This can be given as a Vector to apply to each scattered mesh individually.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = Makie.automatic</code> sets the lighting algorithm used. Options are <code>NoShading</code> (no lighting), <code>FastShading</code> (AmbientLight + PointLight) or <code>MultiLightShading</code> (Multiple lights, GLMakie only). Note that this does not affect RPRMakie.</p></li><li><p><code>diffuse::Vec3f = Vec3f(1.0)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.4)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>backlight::Float32 = 0f0</code> sets a weight for secondary light calculation with inverted normals.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="meshscatter!"><a href="#meshscatter!">meshscatter!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.meshscatter!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "meshscatter!" from MakieCore:
 [1] meshscatter!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="mouse_buttons"><a href="#mouse_buttons">mouse_buttons</a></div><div class="doc-content"><p>Registers a callback for the mouse buttons + modifiers returns <code>Observable{NTuple{4, Int}}</code><a href="http://www.glfw.org/docs/latest/group__input.html#ga1e008c7a8751cea648c8f42cc91104cf">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="mouse_position"><a href="#mouse_position">mouse_position</a></div><div class="doc-content"><p>Registers a callback for the mouse cursor position. returns an <code>Observable{Vec{2, Float64}}</code>, which is not in scene coordinates, with the upper left window corner being 0 <a href="http://www.glfw.org/docs/latest/group__input.html#ga1e008c7a8751cea648c8f42cc91104cf">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="mouseover"><a href="#mouseover">mouseover</a></div><div class="doc-content"><pre><code>mouseover(fig/ax/scene, plots::AbstractPlot...)</code></pre><p>Returns true if the mouse currently hovers any of <code>plots</code>.</p></div></div><div class="docstring"><div class="doc-header" id="mouseposition"><a href="#mouseposition">mouseposition</a></div><div class="doc-content"><pre><code>mouseposition(scene = hovered_scene())</code></pre><p>Return the current position of the mouse in <em>data coordinates</em> of the given <code>scene</code>.</p><p>By default uses the <code>scene</code> that the mouse is currently hovering over.</p></div></div><div class="docstring"><div class="doc-header" id="mouseposition_px"><a href="#mouseposition_px">mouseposition_px</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.mouseposition_px</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "mouseposition_px" from Makie:
 [1] mouseposition_px(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/interactive_api.jl:194
 [2] mouseposition_px()
     @ ~/work/Makie.jl/Makie.jl/src/interaction/interactive_api.jl:194
 [3] mouseposition_px(x)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/interactive_api.jl:193</code></pre></div></div><div class="docstring"><div class="doc-header" id="ncols"><a href="#ncols">ncols</a></div><div class="doc-content"><pre><code>ncols(g::GridLayout)</code></pre><p>Return the number of columns in <code>g</code>.</p></div></div><div class="docstring"><div class="doc-header" id="nrows"><a href="#nrows">nrows</a></div><div class="doc-content"><pre><code>nrows(g::GridLayout)</code></pre><p>Return the number of rows in <code>g</code>.</p></div></div><div class="docstring"><div class="doc-header" id="off"><a href="#off">off</a></div><div class="doc-content"><pre><code>off(observable::AbstractObservable, f)</code></pre><p>Removes <code>f</code> from listeners of <code>observable</code>.</p><p>Returns <code>true</code> if <code>f</code> could be removed, otherwise <code>false</code>.</p><pre><code>off(obsfunc::ObserverFunction)</code></pre><p>Remove the listener function <code>obsfunc.f</code> from the listeners of <code>obsfunc.observable</code>. Once <code>obsfunc</code> goes out of scope, this should allow <code>obsfunc.f</code> and all the values it might have closed over to be garbage collected (unless there are other references to it).</p></div></div><div class="docstring"><div class="doc-header" id="old_cam3d!"><a href="#old_cam3d!">old_cam3d!</a></div><div class="doc-content"><pre><code>old_cam3d!(scene; kwargs...)</code></pre><p>An alias to <a href="@ref"><code>old_cam3d_turntable!</code></a>. Creates a 3D camera for <code>scene</code>, which rotates around the plot's axis.</p></div></div><div class="docstring"><div class="doc-header" id="old_cam3d_cad!"><a href="#old_cam3d_cad!">old_cam3d_cad!</a></div><div class="doc-content"><pre><code>old_cam3d_cad!(scene; kw_args...)</code></pre><p>Creates a 3D camera for <code>scene</code> which rotates around the <em>viewer</em>'s "up" axis - similarly to how it's done in CAD software cameras.</p></div></div><div class="docstring"><div class="doc-header" id="old_cam3d_turntable!"><a href="#old_cam3d_turntable!">old_cam3d_turntable!</a></div><div class="doc-content"><pre><code>old_cam3d_turntable!(scene; kw_args...)</code></pre><p>Creates a 3D camera for <code>scene</code>, which rotates around the plot's axis.</p></div></div><div class="docstring"><div class="doc-header" id="on"><a href="#on">on</a></div><div class="doc-content"><pre><code>on(f, observable::AbstractObservable; weak = false, priority=0, update=false)::ObserverFunction</code></pre><p>Adds function <code>f</code> as listener to <code>observable</code>. Whenever <code>observable</code>'s value is set via <code>observable[] = val</code>, <code>f</code> is called with <code>val</code>.</p><p>Returns an <a href="@ref"><code>ObserverFunction</code></a> that wraps <code>f</code> and <code>observable</code> and allows to disconnect easily by calling <code>off(observerfunction)</code> instead of <code>off(f, observable)</code>. If instead you want to compute a new <code>Observable</code> from an old one, use <a href="@ref"><code>map(f, ::Observable)</code></a>.</p><p>If <code>weak = true</code> is set, the new connection will be removed as soon as the returned <code>ObserverFunction</code> is not referenced anywhere and is garbage collected. This is useful if some parent object makes connections to outside observables and stores the resulting <code>ObserverFunction</code> instances. Then, once that parent object is garbage collected, the weak observable connections are removed automatically.</p><h1>Example</h1><pre><code class="language-julia">julia&gt; obs = Observable(0)
Observable(0)

julia&gt; on(obs) do val
           println("current value is ", val)
       end
ObserverFunction defined at REPL[17]:2 operating on Observable(0)
julia&gt; obs[] = 5;
current value is 5</code></pre><p>One can also give the callback a priority, to enable always calling a specific callback before/after others, independent of the order of registration. The callback with the highest priority gets called first, the default is zero, and the whole range of Int can be used. So one can do:</p><pre><code class="language-julia">julia&gt; obs = Observable(0)
julia&gt; on(obs; priority=-1) do x
           println("Hi from first added")
       end
julia&gt; on(obs) do x
           println("Hi from second added")
       end
julia&gt; obs[] = 2
Hi from second added
Hi from first added</code></pre><p>If you set <code>update=true</code>, on will call f(obs[]) immediately:</p><pre><code class="language-julia">julia&gt; on(Observable(1); update=true) do x
    println("hi")
end
hi</code></pre><pre><code>on(f, c::Camera, observables::Observable...)</code></pre><p>When mapping over observables for the camera, we store them in the <code>steering_node</code> vector, to make it easier to disconnect the camera steering signals later!</p></div></div><div class="docstring"><div class="doc-header" id="onany"><a href="#onany">onany</a></div><div class="doc-content"><pre><code>onany(f, args...; weak::Bool = false, priority::Int = 0, update::Bool = false)</code></pre><p>Calls <code>f</code> on updates to any observable refs in <code>args</code>. <code>args</code> may contain any number of <code>Observable</code> objects. <code>f</code> will be passed the values contained in the refs as the respective argument. All other objects in <code>args</code> are passed as-is.</p><p>See also: <a href="@ref"><code>on</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousedownoutside"><a href="#onmousedownoutside">onmousedownoutside</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === downoutside</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseenter"><a href="#onmouseenter">onmouseenter</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === enter</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftclick"><a href="#onmouseleftclick">onmouseleftclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdoubleclick"><a href="#onmouseleftdoubleclick">onmouseleftdoubleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdoubleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdown"><a href="#onmouseleftdown">onmouseleftdown</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdown</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdrag"><a href="#onmouseleftdrag">onmouseleftdrag</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdrag</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdragstart"><a href="#onmouseleftdragstart">onmouseleftdragstart</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdragstart</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdragstop"><a href="#onmouseleftdragstop">onmouseleftdragstop</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdragstop</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftup"><a href="#onmouseleftup">onmouseleftup</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftup</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddleclick"><a href="#onmousemiddleclick">onmousemiddleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledoubleclick"><a href="#onmousemiddledoubleclick">onmousemiddledoubleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledoubleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledown"><a href="#onmousemiddledown">onmousemiddledown</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledown</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledrag"><a href="#onmousemiddledrag">onmousemiddledrag</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledrag</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledragstart"><a href="#onmousemiddledragstart">onmousemiddledragstart</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledragstart</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledragstop"><a href="#onmousemiddledragstop">onmousemiddledragstop</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledragstop</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddleup"><a href="#onmousemiddleup">onmousemiddleup</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middleup</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseout"><a href="#onmouseout">onmouseout</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === out</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseover"><a href="#onmouseover">onmouseover</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === over</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightclick"><a href="#onmouserightclick">onmouserightclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdoubleclick"><a href="#onmouserightdoubleclick">onmouserightdoubleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdoubleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdown"><a href="#onmouserightdown">onmouserightdown</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdown</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdrag"><a href="#onmouserightdrag">onmouserightdrag</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdrag</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdragstart"><a href="#onmouserightdragstart">onmouserightdragstart</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdragstart</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdragstop"><a href="#onmouserightdragstop">onmouserightdragstop</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdragstop</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightup"><a href="#onmouserightup">onmouserightup</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightup</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onpick"><a href="#onpick">onpick</a></div><div class="doc-content"><pre><code>onpick(func, plot)</code></pre><p>Calls <code>func</code> if one clicks on <code>plot</code>.  Implemented by the backend.</p><pre><code>onpick(f, fig/ax/scene, plots::AbstractPlot...)</code></pre><p>Calls <code>f(plot, idx)</code> whenever the mouse is over any of <code>plots</code>. <code>idx</code> is an index, e.g. when over a scatter plot, it will be the index of the hovered element</p></div></div><div class="docstring"><div class="doc-header" id="pick"><a href="#pick">pick</a></div><div class="doc-content"><p>Picks a mouse position.  Implemented by the backend.</p><pre><code>pick(fig/ax/scene, x, y)</code></pre><p>Returns the plot under pixel position <code>(x, y)</code>.</p><pre><code>pick(fig/ax/scene, xy::VecLike)</code></pre><p>Return the plot under pixel position xy.</p><pre><code>pick(fig/ax/scene, xy::VecLike, range)</code></pre><p>Return the plot closest to xy within a given range.</p><pre><code>pick(scene::Scene, rect::Rect2i)</code></pre><p>Return all <code>(plot, index)</code> pairs within the given rect. The rect must be within screen boundaries.</p></div></div><div class="docstring"><div class="doc-header" id="pie"><a href="#pie">pie</a></div><div class="doc-content"><pre><code>pie(fractions; kwargs...)</code></pre><p>Creates a pie chart with the given <code>fractions</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.pie}</code> are: </p><pre><code>  color           :gray
  inner_radius    0
  inspectable     true
  normalize       true
  offset          0
  radius          1
  strokecolor     :black
  strokewidth     1
  transparency    false
  vertex_per_deg  1
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="pie!"><a href="#pie!">pie!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.pie!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "pie!" from Makie:
 [1] pie!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="pixelarea"><a href="#pixelarea">pixelarea</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.pixelarea</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "pixelarea" from Makie:
 [1] pixelarea(args...; kwargs...)
     @ deprecated.jl:113</code></pre></div></div><div class="docstring"><div class="doc-header" id="plot"><a href="#plot">plot</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.plot</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "plot" from MakieCore:
 [1] plot(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:39</code></pre></div></div><div class="docstring"><div class="doc-header" id="plot!"><a href="#plot!">plot!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.plot!</code> is a <code>Function</code>.</p><pre><code># 65 methods for generic function "plot!" from MakieCore:
  [1] plot!(plot::Plot{MakieCore.plot, Tuple{Makie.GridLayoutSpec}})
     @ Makie ~/work/Makie.jl/Makie.jl/src/specapi.jl:730
  [2] plot!(fa::Makie.FigureAxis, plot)
     @ Makie ~/work/Makie.jl/Makie.jl/src/figureplotting.jl:313
  [3] plot!(ax::Axis, P::Type{&lt;:Plot{Makie.rainclouds}}, allattrs::Attributes, category_labels, data_array)
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/raincloud.jl:138
  [4] plot!(sc::Plot{Main.FD_SANDBOX_12283929528957551597.stockchart, &lt;:Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Main.FD_SANDBOX_12283929528957551597.StockValue}}})
     @ Main.FD_SANDBOX_12283929528957551597 none:1
  [5] plot!(plot::Plot{RPRMakie.matball})
     @ RPRMakie ~/work/Makie.jl/Makie.jl/RPRMakie/src/meshes.jl:172
  [6] plot!(plot::Plot{Makie.band})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/band.jl:33
  [7] plot!(axis::Plot{Makie.axis3d})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/axis.jl:320
  [8] plot!(p::Plot{Makie.ablines})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/ablines.jl:18
  [9] plot!(plot::Plot{Makie.annotations})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/annotations.jl:21
 [10] plot!(p::Plot{Makie.arc})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/arc.jl:24
 [11] plot!(arrowplot::Arrows{&lt;:Tuple{AbstractVector{&lt;:Point{N}}, V}}) where {N, V}
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/arrows.jl:115
 [12] plot!(p::Plot{Makie.barplot})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/barplot.jl:240
 [13] plot!(pl::Plot{Makie.bracket})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/bracket.jl:43
 [14] plot!(plot::Plot{Makie.contour, &lt;:Tuple{X, Y, Z, Vol}}) where {X, Y, Z, Vol}
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/contours.jl:119
 [15] plot!(plot::T) where T&lt;:Union{Plot{Makie.contour}, Plot{Makie.contour3d}}
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/contours.jl:205
 [16] plot!(c::Plot{Makie.contourf, &lt;:Tuple{var"#s317", var"#s29", var"#s28"} where {var"#s317"&lt;:(AbstractVector{&lt;:Real}), var"#s29"&lt;:(AbstractVector{&lt;:Real}), var"#s28"&lt;:(AbstractMatrix{&lt;:Real})}})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/contourf.jl:70
 [17] plot!(p::Plot{Makie.datashader, &lt;:Tuple{var"#s317"} where var"#s317"&lt;:(AbstractVector{&lt;:Point})})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/datashader.jl:377
 [18] plot!(p::Plot{Makie.datashader, &lt;:Tuple{Dict{String, Vector{Point{2, Float32}}}}})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/datashader.jl:432
 [19] plot!(plot::Plot{Makie.errorbars, T}) where T&lt;:Tuple{AbstractVector{&lt;:Union{NTuple{4, T}, StaticArraysCore.StaticArray{Tuple{4}, T, 1}} where T}}
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/error_and_rangebars.jl:137
 [20] plot!(plot::Plot{Makie.rangebars, T}) where T&lt;:Tuple{AbstractVector{&lt;:Union{Tuple{T, T, T}, StaticArraysCore.StaticArray{Tuple{3}, T, 1}} where T}}
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/error_and_rangebars.jl:167
 [21] plot!(p::Union{Plot{Makie.hlines}, Plot{Makie.vlines}})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/hvlines.jl:48
 [22] plot!(p::Union{Plot{Makie.hspan}, Plot{Makie.vspan}})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/hvspan.jl:45
 [23] plot!(plot::Plot{Makie.pie})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/pie.jl:25
 [24] plot!(plot::Poly{&lt;:Tuple{Union{GeometryBasics.GeometryPrimitive, GeometryBasics.Mesh}}})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/poly.jl:11
 [25] plot!(plot::Poly{&lt;:Tuple{var"#s317"} where var"#s317"&lt;:Union{GeometryBasics.Polygon, AbstractVector{&lt;:Union{AbstractVector{&lt;:Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where {N, T}}, Tuple{Vararg{T, N}} where {N, T}, GeometryBasics.AbstractMesh, GeometryBasics.HyperRectangle, GeometryBasics.MultiPolygon, GeometryBasics.Polygon, StaticArraysCore.StaticArray{Tuple{N}, T, 1} where {N, T}, Circle}}}})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/poly.jl:118
 [26] plot!(plot::Mesh{&lt;:Tuple{var"#s317"} where var"#s317"&lt;:AbstractVector{P}}) where P&lt;:Union{GeometryBasics.AbstractMesh, GeometryBasics.Polygon}
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/poly.jl:165
 [27] plot!(p::Plot{Makie.scatterlines, &lt;:Tuple{Vararg{Any, N}}}) where N
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/scatterlines.jl:34
 [28] plot!(p::Plot{Makie.spy})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/spy.jl:40
 [29] plot!(p::Plot{Makie.stairs, &lt;:Tuple{var"#s317"} where var"#s317"&lt;:(AbstractVector{&lt;:Point2})})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/stairs.jl:25
 [30] plot!(s::Plot{Makie.stem, &lt;:Tuple{var"#s317"} where var"#s317"&lt;:(AbstractVector{&lt;:Point})})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/stem.jl:52
 [31] plot!(p::Plot{Makie.streamplot})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/streamplot.jl:169
 [32] plot!(plot::Plot{Makie.timeseries})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/timeseries.jl:37
 [33] plot!(c::Plot{Makie.tricontourf, &lt;:Tuple{var"#s317", var"#s29"} where {var"#s317"&lt;:DelaunayTriangulation.Triangulation, var"#s29"&lt;:(AbstractVector{&lt;:Real})}})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/tricontourf.jl:118
 [34] plot!(p::Plot{Makie.triplot, &lt;:Tuple{var"#s317"} where var"#s317"&lt;:(Vector{&lt;:Point})})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/triplot.jl:183
 [35] plot!(p::Plot{Makie.triplot, &lt;:Tuple{var"#s317"} where var"#s317"&lt;:DelaunayTriangulation.Triangulation})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/triplot.jl:197
 [36] plot!(plot::Plot{Makie.volumeslices})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/volumeslices.jl:20
 [37] plot!(p::Plot{Makie.voronoiplot, &lt;:Tuple{var"#s317"} where var"#s317"&lt;:(Vector{&lt;:Point{N}})}) where N
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/voronoiplot.jl:133
 [38] plot!(p::Plot{Makie.voronoiplot, &lt;:Tuple{var"#s317"} where var"#s317"&lt;:DelaunayTriangulation.VoronoiTessellation})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/voronoiplot.jl:183
 [39] plot!(p::Plot{Makie.waterfall})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/waterfall.jl:35
 [40] plot!(plot::Wireframe{&lt;:Tuple{var"#s317", var"#s29", var"#s28"} where {var"#s317", var"#s29", var"#s28"&lt;:(AbstractMatrix)}})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/wireframe.jl:29
 [41] plot!(plot::Plot{MakieCore.wireframe, Tuple{T}}) where T
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/wireframe.jl:41
 [42] plot!(p::Plot{Makie.tooltip, &lt;:Tuple{var"#s317"} where var"#s317"&lt;:(Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where {N, T})})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/tooltip.jl:83
 [43] plot!(plot::Plot{Makie.tooltip, &lt;:Tuple{var"#s317", var"#s29"} where {var"#s317"&lt;:(Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where {N, T}), var"#s29"&lt;:AbstractString}})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/tooltip.jl:76
 [44] plot!(p::Plot{Makie.plotlist, &lt;:Tuple{var"#s1274"} where var"#s1274"&lt;:(AbstractArray{PlotSpec})})
     @ Makie ~/work/Makie.jl/Makie.jl/src/specapi.jl:486
 [45] plot!(plot::Plot{Makie.stephist})
     @ Makie ~/work/Makie.jl/Makie.jl/src/stats/hist.jl:56
 [46] plot!(plot::Plot{Makie.hist})
     @ Makie ~/work/Makie.jl/Makie.jl/src/stats/hist.jl:166
 [47] plot!(plot::Plot{Makie.density, &lt;:Tuple{var"#s1274"} where var"#s1274"&lt;:(AbstractVector)})
     @ Makie ~/work/Makie.jl/Makie.jl/src/stats/density.jl:57
 [48] plot!(p::Plot{Makie.qqplot})
     @ Makie ~/work/Makie.jl/Makie.jl/src/stats/distributions.jl:125
 [49] plot!(plot::Plot{Makie.crossbar})
     @ Makie ~/work/Makie.jl/Makie.jl/src/stats/crossbar.jl:54
 [50] plot!(plot::Plot{Makie.boxplot})
     @ Makie ~/work/Makie.jl/Makie.jl/src/stats/boxplot.jl:82
 [51] plot!(plot::Plot{Makie.violin})
     @ Makie ~/work/Makie.jl/Makie.jl/src/stats/violin.jl:52
 [52] plot!(hb::Plot{Makie.hexbin, &lt;:Tuple{var"#s1274"} where var"#s1274"&lt;:(AbstractVector{&lt;:Point2})})
     @ Makie ~/work/Makie.jl/Makie.jl/src/stats/hexbin.jl:81
 [53] plot!(plot::Plot{Makie.series})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/series.jl:67
 [54] plot!(plot::MakieCore.Text{&lt;:Tuple{var"#s1946"} where var"#s1946"&lt;:(AbstractArray{&lt;:AbstractString})})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:144
 [55] plot!(plot::MakieCore.Text{&lt;:Tuple{var"#s1946"} where var"#s1946"&lt;:(AbstractArray{&lt;:Tuple{var"#s1944", var"#s1925"} where {var"#s1944", var"#s1925"&lt;:Point}})})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:150
 [56] plot!(plot::MakieCore.Text{&lt;:Tuple{var"#s1946"} where var"#s1946"&lt;:(AbstractArray{&lt;:Makie.GlyphCollection})})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:142
 [57] plot!(plot::MakieCore.Text{&lt;:Tuple{var"#s1946"} where var"#s1946"&lt;:Makie.GlyphCollection})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:141
 [58] plot!(plot::MakieCore.Text{&lt;:Tuple{var"#s1946"} where var"#s1946"&lt;:AbstractString})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:126
 [59] plot!(plot::Plot{Makie.rainclouds})
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/raincloud.jl:194
 [60] plot!(plot::MakieCore.Text)
     @ Makie ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:7
 [61] plot!(::Plot{F}) where F
     @ Makie ~/work/Makie.jl/Makie.jl/src/interfaces.jl:230
 [62] plot!(ax::Makie.AbstractAxis, plot::AbstractPlot)
     @ Makie ~/work/Makie.jl/Makie.jl/src/figureplotting.jl:315
 [63] plot!(scene::Union{AbstractScene, MakieCore.ScenePlot}, plot::Plot)
     @ Makie ~/work/Makie.jl/Makie.jl/src/interfaces.jl:264
 [64] plot!(fig::Union{GridPosition, Figure}, plot::Plot{MakieCore.plot, Tuple{Makie.GridLayoutSpec}})
     @ Makie ~/work/Makie.jl/Makie.jl/src/specapi.jl:732
 [65] plot!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:40</code></pre></div></div><div class="docstring"><div class="doc-header" id="plotkey"><a href="#plotkey">plotkey</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.plotkey</code> is a <code>Function</code>.</p><pre><code># 4 methods for generic function "plotkey" from MakieCore:
 [1] plotkey(::Nothing)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:23
 [2] plotkey(::T) where T&lt;:AbstractPlot
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:22
 [3] plotkey(::Type{&lt;:AbstractPlot{Typ}}) where Typ
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:21
 [4] plotkey(any)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:24</code></pre></div></div><div class="docstring"><div class="doc-header" id="plotlist"><a href="#plotlist">plotlist</a></div><div class="doc-content"><pre><code>plotlist!(
    [
        PlotSpec(:Scatter, args...; kwargs...),
        PlotSpec(:Lines, args...; kwargs...),
    ]
)</code></pre><p>Plots a list of PlotSpec's, which can be an observable, making it possible to create efficiently animated plots with the following API:</p><h2>Example</h2><pre><code class="language-julia">using GLMakie
import Makie.SpecApi as S

fig = Figure()
ax = Axis(fig[1, 1])
plots = Observable([S.heatmap(0 .. 1, 0 .. 1, Makie.peaks()), S.lines(0 .. 1, sin.(0:0.01:1); color=:blue)])
pl = plot!(ax, plots)
display(fig)

# Updating the plot dynamically
plots[] = [S.heatmap(0 .. 1, 0 .. 1, Makie.peaks()), S.lines(0 .. 1, sin.(0:0.01:1); color=:red)]
plots[] = [
    S.image(0 .. 1, 0 .. 1, Makie.peaks()),
    S.poly(Rect2f(0.45, 0.45, 0.1, 0.1)),
    S.lines(0 .. 1, sin.(0:0.01:1); linewidth=10, color=Makie.resample_cmap(:viridis, 101)),
]

plots[] = [
    S.surface(0..1, 0..1, Makie.peaks(); colormap = :viridis, translation = Vec3f(0, 0, -1)),
]</code></pre></div></div><div class="docstring"><div class="doc-header" id="plotlist!"><a href="#plotlist!">plotlist!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.plotlist!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "plotlist!" from Makie:
 [1] plotlist!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="plots"><a href="#plots">plots</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.plots</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "plots" from Makie:
 [1] plots(scene::Union{AbstractScene, MakieCore.ScenePlot})
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:519
 [2] plots(x)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:518</code></pre></div></div><div class="docstring"><div class="doc-header" id="poly"><a href="#poly">poly</a></div><div class="doc-content"><pre><code>poly(vertices, indices; kwargs...)
poly(points; kwargs...)
poly(shape; kwargs...)
poly(mesh; kwargs...)</code></pre><p>Plots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to <code>mesh</code>. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by <code>GeometryBasics</code>), it will plot <code>decompose(shape)</code>.</p><pre><code>poly(coordinates, connectivity; kwargs...)</code></pre><p>Plots polygons, which are defined by <code>coordinates</code> (the coordinates of the vertices) and <code>connectivity</code> (the edges between the vertices).</p><h2>Attributes</h2><h3>Specific to <code>Poly</code></h3><ul><li><p><code>color=theme(scene, :patchcolor)</code> sets the color of the poly. Can be a <code>Vector{&lt;:Colorant}</code> for per vertex colors or a single <code>Colorant</code>.  A <code>Matrix{&lt;:Colorant}</code> can be used to color the mesh with a texture, which requires the mesh to contain texture coordinates.  Vector or Matrices of numbers can be used as well, which will use the colormap arguments to map the numbers to colors.  One can also use <code>Makie.LinePattern</code>, to cover the poly with a regular stroke pattern.</p></li><li><p><code>strokecolor::Union{Symbol, &lt;:Colorant} = :black</code> sets the color of the outline around a marker.</p></li><li><p><code>strokecolormap</code>::Union{Symbol, Vector{&lt;:Colorant}} = :viridis<code>sets the colormap that is sampled for numeric</code>color`s.</p></li><li><p><code>strokewidth::Real = 0</code> sets the width of the outline around a marker.</p></li><li><p><code>linestyle::Union{Nothing, Symbol, Vector} = nothing</code> sets the pattern of the line (e.g. <code>:solid</code>, <code>:dot</code>, <code>:dashdot</code>)</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="poly!"><a href="#poly!">poly!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.poly!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "poly!" from MakieCore:
 [1] poly!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="px"><a href="#px">px</a></div><div class="doc-content"><p>Unit in pixels on screen. This one is a bit tricky, since it refers to a static attribute (pixels on screen don't change) but since every visual is attached to a camera, the exact scale might change. So in the end, this is just relative to some normed camera - the value on screen, depending on the camera, will not actually sit on those pixels. Only camera that guarantees the correct mapping is the <code>:pixel</code> camera type.</p></div></div><div class="docstring"><div class="doc-header" id="qqnorm"><a href="#qqnorm">qqnorm</a></div><div class="doc-content"><pre><code>qqnorm(y; kwargs...)</code></pre><p>Shorthand for <code>qqplot(Normal(0,1), y)</code>, i.e., draw a Q-Q plot of <code>y</code> against the standard normal distribution. See <code>qqplot</code> for more details.</p></div></div><div class="docstring"><div class="doc-header" id="qqnorm!"><a href="#qqnorm!">qqnorm!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.qqnorm!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "qqnorm!" from Makie:
 [1] qqnorm!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="qqplot"><a href="#qqplot">qqplot</a></div><div class="doc-content"><pre><code>qqplot(x, y; kwargs...)</code></pre><p>Draw a Q-Q plot, comparing quantiles of two distributions. <code>y</code> must be a list of samples, i.e., <code>AbstractVector{&lt;:Real}</code>, whereas <code>x</code> can be</p><ul><li><p>a list of samples,</p></li><li><p>an abstract distribution, e.g. <code>Normal(0, 1)</code>,</p></li><li><p>a distribution type, e.g. <code>Normal</code>.</p></li></ul><p>In the last case, the distribution type is fitted to the data <code>y</code>.</p><p>The attribute <code>qqline</code> (defaults to <code>:none</code>) determines how to compute a fit line for the Q-Q plot. Possible values are the following.</p><ul><li><p><code>:identity</code> draws the identity line.</p></li><li><p><code>:fit</code> computes a least squares line fit of the quantile pairs.</p></li><li><p><code>:fitrobust</code> computes the line that passes through the first and third quartiles of the distributions.</p></li><li><p><code>:none</code> omits drawing the line.</p></li></ul><p>Broadly speaking, <code>qqline = :identity</code> is useful to see if <code>x</code> and <code>y</code> follow the same distribution, whereas <code>qqline = :fit</code> and <code>qqline = :fitrobust</code> are useful to see if the distribution of <code>y</code> can be obtained from the distribution of <code>x</code> via an affine transformation.</p><p>Graphical attributes are</p><ul><li><p><code>color</code> to control color of both line and markers (if <code>markercolor</code> is not specified)</p></li><li><p><code>linestyle</code></p></li><li><p><code>linewidth</code></p></li><li><p><code>markercolor</code></p></li><li><p><code>strokecolor</code></p></li><li><p><code>strokewidth</code></p></li><li><p><code>marker</code></p></li><li><p><code>markersize</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="qqplot!"><a href="#qqplot!">qqplot!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.qqplot!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "qqplot!" from Makie:
 [1] qqplot!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="qrotation"><a href="#qrotation">qrotation</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.qrotation</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "qrotation" from Makie:
 [1] qrotation(axis::StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, theta::Number)
     @ ~/work/Makie.jl/Makie.jl/src/utilities/quaternions.jl:39</code></pre></div></div><div class="docstring"><div class="doc-header" id="quiver"><a href="#quiver">quiver</a></div><div class="doc-content"><pre><code>arrows(points, directions; kwargs...)
arrows(x, y, u, v)
arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)
arrows(x, y, z, u, v, w)
arrows(x, y, [z], f::Function)</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each 'row' is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p><p>If a <code>Function</code> is provided in place of <code>u, v, [w]</code>, then it must accept a <code>Point</code> as input, and return an appropriately dimensioned <code>Point</code>, <code>Vec</code>, or other array-like output.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Arrows</code> are: </p><pre><code>  align           :origin
  alpha           1.0
  arrowcolor      MakieCore.Automatic()
  arrowhead       MakieCore.Automatic()
  arrowsize       MakieCore.Automatic()
  arrowtail       MakieCore.Automatic()
  backlight       0.0f0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  depth_shift     0.0f0
  diffuse         1.0
  highclip        MakieCore.Automatic()
  inspectable     true
  lengthscale     1.0f0
  linecolor       MakieCore.Automatic()
  linestyle       "nothing"
  linewidth       MakieCore.Automatic()
  lowclip         MakieCore.Automatic()
  markerspace     :pixel
  nan_color       :transparent
  normalize       false
  overdraw        false
  quality         32
  shading         MakieCore.Automatic()
  shininess       32.0f0
  space           :data
  specular        0.2
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="quiver!"><a href="#quiver!">quiver!</a></div><div class="doc-content"><p>See <a href="@ref"><code>arrows</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="rainclouds"><a href="#rainclouds">rainclouds</a></div><div class="doc-content"><pre><code>rainclouds!(ax, category_labels, data_array; plot_boxplots=true, plot_clouds=true, kwargs...)</code></pre><p>Plot a violin (/histogram), boxplot and individual data points with appropriate spacing between each.</p><h1>Arguments</h1><ul><li><p><code>ax</code>: Axis used to place all these plots onto.</p></li><li><p><code>category_labels</code>: Typically <code>Vector{String}</code> with a label for each element in <code>data_array</code></p></li><li><p><code>data_array</code>: Typically <code>Vector{Float64}</code> used for to represent the datapoints to plot.</p></li></ul><h1>Keywords</h1><ul><li><p><code>gap=0.2</code>: Distance between elements of x-axis.</p></li><li><p><code>side=:left</code>: Can take values of <code>:left</code>, <code>:right</code>, determines where the violin plot will be, relative to the scatter points</p></li><li><p><code>dodge</code>: vector of <code>Integer</code>` (length of data) of grouping variable to create multiple side-by-side boxes at the same x position</p></li><li><p><code>dodge_gap = 0.03</code>: spacing between dodged boxes</p></li><li><p><code>n_dodge</code>: the number of categories to dodge (defaults to maximum(dodge))</p></li><li><p><code>color</code>: a single color, or a vector of colors, one for each point</p></li></ul><h2>Violin/Histogram Plot Specific Keywords</h2><ul><li><p><code>clouds=violin</code>: [violin, hist, nothing] to show cloud plots either as violin or histogram plot, or no cloud plot.</p></li><li><p><code>hist_bins=30</code>: if <code>clouds=hist</code>, this passes down the number of bins to the histogram call.</p></li><li><p><code>cloud_width=1.0</code>: Determines size of violin plot. Corresponds to <code>width</code> keyword arg in</p></li></ul><p><code>violin</code>.</p><ul><li><p><code>orientation=:vertical</code> orientation of raindclouds (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>violin_limits=(-Inf, Inf)</code>: specify values to trim the <code>violin</code>. Can be a <code>Tuple</code> or a <code>Function</code> (e.g. <code>datalimits=extrema</code>)</p></li></ul><h2>Box Plot Specific Keywords</h2><ul><li><p><code>plot_boxplots=true</code>: Boolean to show boxplots to summarize distribution of data.</p></li><li><p><code>boxplot_width=0.1</code>: Width of the boxplot in category x-axis absolute terms.</p></li><li><p><code>center_boxplot=true</code>: Determines whether or not to have the boxplot be centered in the category.</p></li><li><p><code>whiskerwidth=0.5</code>: The width of the Q1, Q3 whisker in the boxplot. Value as a portion of the <code>boxplot_width</code>.</p></li><li><p><code>strokewidth=1.0</code>: Determines the stroke width for the outline of the boxplot.</p></li><li><p><code>show_median=true</code>: Determines whether or not to have a line should the median value in the boxplot.</p></li><li><p><code>boxplot_nudge=0.075</code>: Determines the distance away the boxplot should be placed from the   center line when <code>center_boxplot</code> is <code>false</code>. This is the value used to recentering the   boxplot.</p></li><li><p><code>show_boxplot_outliers</code>: show outliers in the boxplot as points (usually confusing when</p></li></ul><p>paired with the scatter plot so the default is to not show them)</p><h2>Scatter Plot Specific Keywords</h2><ul><li><p><code>side_nudge</code>: Default value is 0.02 if <code>plot_boxplots</code> is true, otherwise <code>0.075</code> default.</p></li><li><p><code>jitter_width=0.05</code>: Determines the width of the scatter-plot bar in category x-axis absolute terms.</p></li><li><p><code>markersize=2</code>: Size of marker used for the scatter plot.</p></li></ul><h2>Axis General Keywords</h2><ul><li><p><code>title</code></p></li><li><p><code>xlabel</code></p></li><li><p><code>ylabel</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="rainclouds!"><a href="#rainclouds!">rainclouds!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.rainclouds!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "rainclouds!" from Makie:
 [1] rainclouds!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="rangebars"><a href="#rangebars">rangebars</a></div><div class="doc-content"><pre><code>rangebars(val, low, high; kwargs...)
rangebars(val, low_high; kwargs...)
rangebars(val_low_high; kwargs...)</code></pre><p>Plots rangebars at <code>val</code> in one dimension, extending from <code>low</code> to <code>high</code> in the other dimension given the chosen <code>direction</code>. The <code>low_high</code> argument can be a vector of tuples or intervals.</p><p>If you want to plot errors relative to a reference value, use <code>errorbars</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.rangebars}</code> are: </p><pre><code>  color         :black
  colormap      :viridis
  colorrange    MakieCore.Automatic()
  colorscale    identity
  cycle         [:color]
  direction     :y
  inspectable   true
  linewidth     1.5
  transparency  false
  visible       true
  whiskerwidth  0</code></pre></div></div><div class="docstring"><div class="doc-header" id="rangebars!"><a href="#rangebars!">rangebars!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.rangebars!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "rangebars!" from Makie:
 [1] rangebars!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="record"><a href="#record">record</a></div><div class="doc-content"><pre><code>record(func, figurelike, path; backend=current_backend(), kwargs...)
record(func, figurelike, path, iter; backend=current_backend(), kwargs...)</code></pre><p>The first signature provides <code>func</code> with a VideoStream, which it should call <code>recordframe!(io)</code> on when recording a frame.</p><p>The second signature iterates <code>iter</code>, calling <code>recordframe!(io)</code> internally after calling <code>func</code> with the current iteration element.</p><p>Both notations require a Figure, FigureAxisPlot or Scene <code>figure</code> to work. The animation is then saved to <code>path</code>, with the format determined by <code>path</code>'s extension.</p><p>Under the hood, <code>record</code> is just <code>video_io = Record(func, figurelike, [iter]; same_kw...); save(path, video_io)</code>. <code>Record</code> can be used directly as well to do the saving at a later point, or to inline a video directly into a Notebook (the video supports, <code>show(video_io, "text/html")</code> for that purpose).</p><h1>Options one can pass via <code>kwargs...</code>:</h1><ul><li><p><code>backend::Module = current_backend()</code>: set the backend to write out video, can be set to <code>CairoMakie</code>, <code>GLMakie</code>, <code>WGLMakie</code>, <code>RPRMakie</code>.</p></li></ul><h3>Backend options</h3><p>See <code>?Backend.Screen</code> or <code>Base.doc(Backend.Screen)</code> for applicable options that can be passed and forwarded to the backend.</p><h3>Video options</h3><ul><li><p><code>format = "mkv"</code>: The format of the video. If a path is present, will be inferred from the file extension.   Can be one of the following:</p><ul><li><p><code>"mkv"</code>  (open standard, the default)</p></li><li><p><code>"mp4"</code>  (good for Web, most supported format)</p></li><li><p><code>"webm"</code> (smallest file size)</p></li><li><p><code>"gif"</code>  (largest file size for the same quality)</p></li></ul><p><code>mp4</code> and <code>mk4</code> are marginally bigger than <code>webm</code>. <code>gif</code>s can be significantly (as much as   6x) larger with worse quality (due to the limited color palette) and only should be used   as a last resort, for playing in a context where videos aren't supported.</p></li><li><p><code>framerate = 24</code>: The target framerate.</p></li><li><p><code>compression = 20</code>: Controls the video compression via <code>ffmpeg</code>'s <code>-crf</code> option, with   smaller numbers giving higher quality and larger file sizes (lower compression), and   higher numbers giving lower quality and smaller file sizes (higher compression). The   minimum value is <code>0</code> (lossless encoding).</p><ul><li><p>For <code>mp4</code>, <code>51</code> is the maximum. Note that <code>compression = 0</code> only works with <code>mp4</code> if</p></li></ul><p><code>profile = "high444"</code>.</p><ul><li><p>For <code>webm</code>, <code>63</code> is the maximum.</p></li><li><p><code>compression</code> has no effect on <code>mkv</code> and <code>gif</code> outputs.</p></li></ul></li><li><p><code>profile = "high422"</code>: A ffmpeg compatible profile. Currently only applies to <code>mp4</code>. If</p></li></ul><p>you have issues playing a video, try <code>profile = "high"</code> or <code>profile = "main"</code>.</p><ul><li><p><code>pixel_format = "yuv420p"</code>: A ffmpeg compatible pixel format (<code>-pix_fmt</code>). Currently only</p></li></ul><p>applies to <code>mp4</code>. Defaults to <code>yuv444p</code> for <code>profile = "high444"</code>.</p><ul><li><p><code>loop = 0</code>: Number of times the video is repeated, for a <code>gif</code>. Defaults to <code>0</code>, which</p></li></ul><p>means infinite looping. A value of <code>-1</code> turns off looping, and a value of <code>n &gt; 0</code> and above means <code>n</code> repetitions (i.e. the video is played <code>n+1</code> times).</p><pre><code>!!! warning
`profile` and `pixel_format` are only used when `format` is `"mp4"`; a warning will be issued if `format`
is not `"mp4"` and those two arguments are not `nothing`. Similarly, `compression` is only
valid when `format` is `"mp4"` or `"webm"`, and `loop` is only valid when `format` is `"gif"`.</code></pre><h1>Typical usage</h1><pre><code class="language-julia">record(figure, "video.mp4", itr) do i
    func(i) # or some other manipulation of the figure
end</code></pre><p>or, for more tweakability,</p><pre><code class="language-julia">record(figure, "test.gif") do io
    for i = 1:100
        func!(figure)     # animate figure
        recordframe!(io)  # record a new frame
    end
end</code></pre><p>If you want a more tweakable interface, consider using <a href="@ref"><code>VideoStream</code></a> and <a href="@ref"><code>save</code></a>.</p><h2>Extended help</h2><h3>Examples</h3><pre><code class="language-julia">fig, ax, p = lines(rand(10))
record(fig, "test.gif") do io
    for i in 1:255
        p[:color] = RGBf(i/255, (255 - i)/255, 0) # animate figure
        recordframe!(io)
    end
end</code></pre><p>or</p><pre><code class="language-julia">fig, ax, p = lines(rand(10))
record(fig, "test.gif", 1:255) do i
    p[:color] = RGBf(i/255, (255 - i)/255, 0) # animate figure
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="record_events"><a href="#record_events">record_events</a></div><div class="doc-content"><p>record_events(f, scene::Scene, path::String)</p><p>Records all window events that happen while executing function <code>f</code> for <code>scene</code> and serializes them to <code>path</code>.</p></div></div><div class="docstring"><div class="doc-header" id="recordframe!"><a href="#recordframe!">recordframe!</a></div><div class="doc-content"><pre><code>recordframe!(io::VideoStream)</code></pre><p>Adds a video frame to the VideoStream <code>io</code>.</p></div></div><div class="docstring"><div class="doc-header" id="register_interaction!"><a href="#register_interaction!">register_interaction!</a></div><div class="doc-content"><pre><code>register_interaction!(parent, name::Symbol, interaction)</code></pre><p>Register <code>interaction</code> with <code>parent</code> under the name <code>name</code>. The parent will call <code>process_interaction(interaction, event, parent)</code> whenever suitable events happen.</p><p>The interaction can be removed with <code>deregister_interaction!</code> or temporarily toggled with <code>activate_interaction!</code> / <code>deactivate_interaction!</code>.</p><pre><code>register_interaction!(interaction::Function, parent, name::Symbol)</code></pre><p>Register <code>interaction</code> with <code>parent</code> under the name <code>name</code>. The parent will call <code>process_interaction(interaction, event, parent)</code> whenever suitable events happen. This form with the first <code>Function</code> argument is especially intended for <code>do</code> syntax.</p><p>The interaction can be removed with <code>deregister_interaction!</code> or temporarily toggled with <code>activate_interaction!</code> / <code>deactivate_interaction!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="replace_automatic!"><a href="#replace_automatic!">replace_automatic!</a></div><div class="doc-content"><p>Like <code>get!(f, dict, key)</code> but also calls <code>f</code> and replaces <code>key</code> when the corresponding value is nothing</p></div></div><div class="docstring"><div class="doc-header" id="replay_events"><a href="#replay_events">replay_events</a></div><div class="doc-content"><p>replay<em>events(f, scene::Scene, path::String) replay</em>events(scene::Scene, path::String)</p><p>Replays the serialized events recorded with <code>record_events</code> in <code>path</code> in <code>scene</code>.</p></div></div><div class="docstring"><div class="doc-header" id="resample_cmap"><a href="#resample_cmap">resample_cmap</a></div><div class="doc-content"><pre><code>resample_cmap(cmap, ncolors::Integer; alpha=1.0)</code></pre><ul><li><p>cmap: anything that <code>to_colormap</code> accepts</p></li><li><p>ncolors: number of desired colors</p></li><li><p>alpha: additional alpha applied to each color. Can also be an array, matching <code>colors</code>, or a tuple giving a start + stop alpha value.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="reset_limits!"><a href="#reset_limits!">reset_limits!</a></div><div class="doc-content"><pre><code>reset_limits!(ax; xauto = true, yauto = true)</code></pre><p>Resets the axis limits depending on the value of <code>ax.limits</code>. If one of the two components of limits is nothing, that value is either copied from the targetlimits if <code>xauto</code> or <code>yauto</code> is false, respectively, or it is determined automatically from the plots in the axis. If one of the components is a tuple of two numbers, those are used directly.</p></div></div><div class="docstring"><div class="doc-header" id="resize_to_layout!"><a href="#resize_to_layout!">resize_to_layout!</a></div><div class="doc-content"><pre><code>resize_to_layout!(fig::Figure)</code></pre><p>Resize <code>fig</code> so that it fits the current contents of its top <code>GridLayout</code>. If a <code>GridLayout</code> contains fixed-size content or aspect-constrained columns, for example, it is likely that the solved size of the <code>GridLayout</code> differs from the size of the <code>Figure</code>. This can result in superfluous whitespace at the borders, or content clipping at the figure edges. Once resized, all content should fit the available space, including the <code>Figure</code>'s outer padding.</p></div></div><div class="docstring"><div class="doc-header" id="rich"><a href="#rich">rich</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.rich</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "rich" from Makie:
 [1] rich(args...; kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:291</code></pre></div></div><div class="docstring"><div class="doc-header" id="right"><a href="#right">right</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.right</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "right" from Makie:
 [1] right(rect::Rect2)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:3</code></pre></div></div><div class="docstring"><div class="doc-header" id="rlims!"><a href="#rlims!">rlims!</a></div><div class="doc-content"><pre><code>rlims!(ax::PolarAxis[, rmin], rmax)</code></pre><p>Sets the radial limits of a given <code>PolarAxis</code>.</p></div></div><div class="docstring"><div class="doc-header" id="rotate!"><a href="#rotate!">rotate!</a></div><div class="doc-content"><pre><code>rotate!(Accum, t::Transformable, axis_rot...)</code></pre><p>Apply a relative rotation to the transformable, by multiplying by the current rotation.</p><pre><code>rotate!(t::Transformable, axis_rot::Quaternion)
rotate!(t::Transformable, axis_rot::AbstractFloat)
rotate!(t::Transformable, axis_rot...)</code></pre><p>Apply an absolute rotation to the transformable. Rotations are all internally converted to <code>Quaternion</code>s.</p></div></div><div class="docstring"><div class="doc-header" id="rotate_cam!"><a href="#rotate_cam!">rotate_cam!</a></div><div class="doc-content"><pre><code>rotate_cam!(scene, cam::Camera3D, angles::Vec3)</code></pre><p>Rotates the camera by the given <code>angles</code> around the camera x- (left, right), y- (up, down) and z-axis (in out). The rotation around the y axis is applied first, then x, then y.</p><p>Note that this method reacts to <code>fix_x_key</code> etc and <code>fixed_axis</code>. The former restrict the rotation around a specific axis when a given key is pressed. The latter keeps the camera y axis fixed as the data space z axis.</p><pre><code>rotate_cam!(scene::Scene, theta_v::Number...)
rotate_cam!(scene::Scene, theta_v::VecTypes)</code></pre><p>Rotate the camera of the Scene by the given rotation. Passing <code>theta_v = (Î±, Î², Î³)</code> will rotate the camera according to the Euler angles (Î±, Î², Î³).</p></div></div><div class="docstring"><div class="doc-header" id="rowgap!"><a href="#rowgap!">rowgap!</a></div><div class="doc-content"><pre><code>rowgap!(gl::GridLayout, i::Integer, s::Union{Fixed, Relative, Real})
rowgap!(gl::GridLayout, s::Union{Fixed, Relative, Real})</code></pre><p>Set the gap between rows in <code>gl</code>.  The two-argument version sets all row gaps in <code>gl</code>.  The three-argument version sets the gap between rows <code>i</code> and <code>i+1</code>. Passing a real number to <code>s</code> has the same behaviour as passing <code>Fixed(s)</code>.</p><p>See also <a href="@ref">Fixed</a> and <a href="@ref">Relative</a>.</p></div></div><div class="docstring"><div class="doc-header" id="rowsize!"><a href="#rowsize!">rowsize!</a></div><div class="doc-content"><pre><code>rowsize!(gl::GridLayout, i::Integer, s::Union{Aspect, Auto, Fixed, Relative, Real})</code></pre><p>Set the size of the <code>i</code>th row in <code>gl</code>, i.e., <code>gl[i, :]</code>. Passing a real number to <code>s</code> has the same behaviour as passing <code>Fixed(s)</code>.</p><p>See also <a href="@ref">Aspect</a>, <a href="@ref">Auto</a>, <a href="@ref">Fixed</a>, and <a href="@ref">Relative</a>.</p></div></div><div class="docstring"><div class="doc-header" id="save"><a href="#save">save</a></div><div class="doc-content"><ul><li><p><code>save(filename, data...)</code> saves the contents of a formatted file, trying to infer the format from <code>filename</code>.</p></li><li><p><code>save(Stream{format"PNG"}(io), data...)</code> specifies the format directly, and bypasses the format <a href="@ref"><code>query</code></a>.</p></li><li><p><code>save(File{format"PNG"}(filename), data...)</code> specifies the format directly, and bypasses the format <a href="@ref"><code>query</code></a>.</p></li><li><p><code>save(f, data...; options...)</code> passes keyword arguments on to the saver.</p></li></ul><pre><code>FileIO.save(filename, scene; size = size(scene), pt_per_unit = 0.75, px_per_unit = 1.0)</code></pre><p>Save a <code>Scene</code> with the specified filename and format.</p><h1>Supported Formats</h1><ul><li><p><code>GLMakie</code>: <code>.png</code></p></li><li><p><code>CairoMakie</code>: <code>.svg</code>, <code>.pdf</code> and <code>.png</code></p></li><li><p><code>WGLMakie</code>: <code>.png</code></p></li></ul><h1>Supported Keyword Arguments</h1><h2>All Backends</h2><ul><li><p><code>size</code>: <code>(width::Int, height::Int)</code> of the scene in dimensionless units.</p></li><li><p><code>update</code>: Whether the figure should be updated before saving. This resets the limits of all Axes in the figure. Defaults to <code>true</code>.</p></li><li><p><code>backend</code>: Specify the <code>Makie</code> backend that should be used for saving. Defaults to the current backend.</p></li><li><p><code>px_per_unit</code>: The size of one scene unit in <code>px</code> when exporting to a bitmap format. This provides a mechanism to export the same scene with higher or lower resolution.</p></li><li><p>Further keywords will be forwarded to the screen.</p></li></ul><h2>CairoMakie</h2><ul><li><p><code>pt_per_unit</code>: The size of one scene unit in <code>pt</code> when exporting to a vector format.</p></li></ul><pre><code>save(path::String, io::VideoStream)</code></pre><p>Flushes the video stream and saves it to <code>path</code>. Ideally, <code>path</code>'s file extension is the same as the format that the <code>VideoStream</code> was created with (e.g., if created with format "mp4" then <code>path</code>'s file extension must be ".mp4"). Otherwise, the video will get converted to the target format. If using <a href="@ref"><code>record</code></a> then this is handled for you, as the <code>VideoStream</code>'s format is deduced from the file extension of the path passed to <code>record</code>.</p></div></div><div class="docstring"><div class="doc-header" id="scale!"><a href="#scale!">scale!</a></div><div class="doc-content"><pre><code>scale!(t::Transformable, x, y)
scale!(t::Transformable, x, y, z)
scale!(t::Transformable, xyz)
scale!(t::Transformable, xyz...)</code></pre><p>Scale the given <code>Transformable</code> (a Scene or Plot) to the given arguments. Can take <code>x, y</code> or <code>x, y, z</code>. This is an absolute scaling, and there is no option to perform relative scaling.</p></div></div><div class="docstring"><div class="doc-header" id="scatter"><a href="#scatter">scatter</a></div><div class="doc-content"><pre><code>scatter(positions)
scatter(x, y)
scatter(x, y, z)</code></pre><p>Plots a marker for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><h2>Attributes</h2><h3>Specific to <code>Scatter</code></h3><ul><li><p><code>color=theme(scene, :markercolor)</code> sets the color of the marker. If no color is set, multiple calls to <code>scatter!</code> will cycle through the axis color palette. Otherwise, one can set one color per point by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole scatterplot. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>marker::Union{Symbol, Char, Matrix{&lt;:Colorant}, BezierPath, Polygon}</code> sets the scatter marker.</p></li><li><p><code>markersize::Union{&lt;:Real, Vec2f} = 9</code> sets the size of the marker.</p></li><li><p><code>markerspace::Symbol = :pixel</code> sets the space in which <code>markersize</code> is given. See <code>Makie.spaces()</code> for possible inputs.</p></li><li><p><code>strokewidth::Real = 0</code> sets the width of the outline around a marker.</p></li><li><p><code>strokecolor::Union{Symbol, &lt;:Colorant} = :black</code> sets the color of the outline around a marker.</p></li><li><p><code>glowwidth::Real = 0</code> sets the size of a glow effect around the marker.</p></li><li><p><code>glowcolor::Union{Symbol, &lt;:Colorant} = (:black, 0)</code> sets the color of the glow effect.</p></li><li><p><code>rotations::Union{Real, Billboard, Quaternion} = Billboard(0f0)</code> sets the rotation of the marker. A <code>Billboard</code> rotation is always around the depth axis.</p></li><li><p><code>transform_marker::Bool = false</code> controls whether the model matrix (without translation) applies to the marker itself, rather than just the positions. (If this is true, <code>scale!</code> and <code>rotate!</code> will affect the marker.)</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="scatter!"><a href="#scatter!">scatter!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.scatter!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "scatter!" from MakieCore:
 [1] scatter!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="scatterlines"><a href="#scatterlines">scatterlines</a></div><div class="doc-content"><pre><code>scatterlines(xs, ys, [zs]; kwargs...)</code></pre><p>Plots <code>scatter</code> markers and <code>lines</code> between them.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.scatterlines}</code> are: </p><pre><code>  color             :black
  colormap          :viridis
  colorrange        MakieCore.Automatic()
  colorscale        identity
  cycle             [:color]
  inspectable       true
  linestyle         "nothing"
  linewidth         1.5
  marker            :circle
  markercolor       MakieCore.Automatic()
  markercolormap    MakieCore.Automatic()
  markercolorrange  MakieCore.Automatic()
  markersize        9
  strokecolor       :black
  strokewidth       0</code></pre></div></div><div class="docstring"><div class="doc-header" id="scatterlines!"><a href="#scatterlines!">scatterlines!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.scatterlines!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "scatterlines!" from Makie:
 [1] scatterlines!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="scroll"><a href="#scroll">scroll</a></div><div class="doc-content"><p>Registers a callback for the mouse scroll. returns an <code>Observable{Vec{2, Float64}}</code>, which is an x and y offset. <a href="http://www.glfw.org/docs/latest/group__input.html#gacc95e259ad21d4f666faa6280d4018fd">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="select_line"><a href="#select_line">select_line</a></div><div class="doc-content"><pre><code>select_line(scene; kwargs...) -&gt; line</code></pre><p>Interactively select a line (typically an arrow) on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. Return an <strong>observable</strong> whose value corresponds to the selected line on the scene. In addition the function <em>plots</em> the line on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted line disappears.</p><p>The value of the returned line is updated <strong>only</strong> when the user un-clicks and only if the selected line has non-zero length.</p><p>The <code>kwargs...</code> are propagated into <code>lines!</code> which plots the selected line.</p></div></div><div class="docstring"><div class="doc-header" id="select_point"><a href="#select_point">select_point</a></div><div class="doc-content"><pre><code>select_point(scene; kwargs...) -&gt; point</code></pre><p>Interactively select a point on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. Return an <strong>observable</strong> whose value corresponds to the selected point on the scene. In addition the function <em>plots</em> the point on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted point disappears.</p><p>The value of the returned point is updated <strong>only</strong> when the user un-clicks.</p><p>The <code>kwargs...</code> are propagated into <code>scatter!</code> which plots the selected point.</p></div></div><div class="docstring"><div class="doc-header" id="select_rectangle"><a href="#select_rectangle">select_rectangle</a></div><div class="doc-content"><pre><code>select_rectangle(scene; kwargs...) -&gt; rect</code></pre><p>Interactively select a rectangle on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. The function returns an <strong>observable</strong><code>rect</code> whose value corresponds to the selected rectangle on the scene. In addition the function <em>plots</em> the selected rectangle on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted rectangle disappears.</p><p>The value of the returned observable is updated <strong>only</strong> when the user un-clicks (i.e. when the final value of the rectangle has been decided) and only if the rectangle has area &gt; 0.</p><p>The <code>kwargs...</code> are propagated into <code>lines!</code> which plots the selected rectangle.</p></div></div><div class="docstring"><div class="doc-header" id="series"><a href="#series">series</a></div><div class="doc-content"><pre><code>series(curves;
    linewidth=2,
    color=:lighttest,
    solid_color=nothing,
    labels=nothing,
    # scatter arguments, if any is set != nothing, a scatterplot is added
    marker=nothing,
    markersize=nothing,
    markercolor=automatic,
    strokecolor=nothing,
    strokewidth=nothing)</code></pre><p>Curves can be:</p><ul><li><p><code>AbstractVector{&lt;: AbstractVector{&lt;: Point2}}</code>: the native representation of a series as a vector of lines</p></li><li><p><code>AbstractMatrix</code>: each row represents y coordinates of the line, while <code>x</code> goes from <code>1:size(curves, 1)</code></p></li><li><p><code>AbstractVector, AbstractMatrix</code>: the same as the above, but the first argument sets the x values for all lines</p></li><li><p><code>AbstractVector{&lt;: Tuple{X&lt;: AbstractVector, Y&lt;: AbstractVector}}</code>: A vector of tuples, where each tuple contains a vector for the x and y coordinates</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="series!"><a href="#series!">series!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.series!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "series!" from Makie:
 [1] series!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="set_close_to!"><a href="#set_close_to!">set_close_to!</a></div><div class="doc-content"><pre><code>set_close_to!(slider, value) -&gt; closest_value</code></pre><p>Set the <code>slider</code> to the value in the slider's range that is closest to <code>value</code> and return this value. This function should be used to set a slider to a value programmatically, rather than mutating its value observable directly, which doesn't update the slider visually.</p><p>Set the <code>slider</code> to the values in the slider's range that are closest to <code>v1</code> and <code>v2</code>, and return those values ordered min, misl.</p></div></div><div class="docstring"><div class="doc-header" id="set_theme!"><a href="#set_theme!">set_theme!</a></div><div class="doc-content"><pre><code>set_theme(theme; kwargs...)</code></pre><p>Set the global default theme to <code>theme</code> and add / override any attributes given as keyword arguments.</p></div></div><div class="docstring"><div class="doc-header" id="showgradients"><a href="#showgradients">showgradients</a></div><div class="doc-content"><pre><code>showgradients(
    cgrads::AbstractVector{Symbol};
    h = 0.0, offset = 0.2, fontsize = 0.7,
    size = (800, length(cgrads) * 84)
)::Scene</code></pre><p>Plots the given colour gradients arranged as horizontal colourbars. If you change the offsets or the font size, you may need to change the resolution.</p></div></div><div class="docstring"><div class="doc-header" id="spy"><a href="#spy">spy</a></div><div class="doc-content"><p>spy(x::Range, y::Range, z::AbstractSparseArray)</p><p>Visualizes big sparse matrices. Usage:</p><pre><code class="language-julia">N = 200_000
x = sprand(Float64, N, N, (3(10^6)) / (N*N));
spy(x)
# or if you want to specify the range of x and y:
spy(0..1, 0..1, x)</code></pre><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.spy}</code> are: </p><pre><code>  colormap     :viridis
  colorrange   MakieCore.Automatic()
  colorscale   identity
  framecolor   :black
  framesize    1
  inspectable  true
  marker       MakieCore.Automatic()
  markersize   MakieCore.Automatic()
  visible      true</code></pre></div></div><div class="docstring"><div class="doc-header" id="spy!"><a href="#spy!">spy!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.spy!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "spy!" from Makie:
 [1] spy!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="stairs"><a href="#stairs">stairs</a></div><div class="doc-content"><pre><code>stairs(xs, ys; kwargs...)</code></pre><p>Plot a stair function.</p><p>The <code>step</code> parameter can take the following values:</p><ul><li><p><code>:pre</code>: horizontal part of step extends to the left of each value in <code>xs</code>.</p></li><li><p><code>:post</code>: horizontal part of step extends to the right of each value in <code>xs</code>.</p></li><li><p><code>:center</code>: horizontal part of step extends halfway between the two adjacent values of <code>xs</code>.</p></li></ul><p>The conversion trait of stem is <code>PointBased</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.stairs}</code> are: </p><pre><code>  alpha           1.0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  cycle           [:color]
  depth_shift     0.0f0
  highclip        MakieCore.Automatic()
  inspectable     true
  linestyle       "nothing"
  linewidth       1.5
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  space           :data
  ssao            false
  step            :pre
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="stairs!"><a href="#stairs!">stairs!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.stairs!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "stairs!" from Makie:
 [1] stairs!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="stem"><a href="#stem">stem</a></div><div class="doc-content"><pre><code>stem(xs, ys, [zs]; kwargs...)</code></pre><p>Plots markers at the given positions extending from <code>offset</code> along stem lines.</p><p><code>offset</code> can be a number, in which case it sets y for 2D, and z for 3D stems. It can be a Point2 for 2D plots, as well as a Point3 for 3D plots. It can also be an iterable of any of these at the same length as xs, ys, zs.</p><p>The conversion trait of stem is <code>PointBased</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.stem}</code> are: </p><pre><code>  color            :black
  colormap         :viridis
  colorrange       MakieCore.Automatic()
  colorscale       identity
  cycle            [[:stemcolor, :color, :trunkcolor] =&gt; :color]
  inspectable      true
  marker           :circle
  markersize       9
  offset           0
  stemcolor        :black
  stemcolormap     :viridis
  stemcolorrange   MakieCore.Automatic()
  stemlinestyle    "nothing"
  stemwidth        1.5
  strokecolor      :black
  strokewidth      0
  trunkcolor       :black
  trunkcolormap    :viridis
  trunkcolorrange  MakieCore.Automatic()
  trunklinestyle   "nothing"
  trunkwidth       1.5
  visible          true</code></pre></div></div><div class="docstring"><div class="doc-header" id="stem!"><a href="#stem!">stem!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.stem!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "stem!" from Makie:
 [1] stem!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="stephist"><a href="#stephist">stephist</a></div><div class="doc-content"><pre><code>stephist(values; bins = 15, normalization = :none)</code></pre><p>Plot a step histogram of <code>values</code>. <code>bins</code> can be an <code>Int</code> to create that number of equal-width bins over the range of <code>values</code>. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting <code>normalization</code>.</p><p>Shares most options with <code>hist</code> plotting function.</p><p>Statistical weights can be provided via the <code>weights</code> keyword argument.</p><p>The following attributes can move the histogram around, which comes in handy when placing multiple histograms into one plot:</p><ul><li><p><code>scale_to = nothing</code>: allows to scale all values to a certain height</p></li></ul><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.stephist}</code> are: </p><pre><code>  bins           15
  color          RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  cycle          [:color =&gt; :patchcolor]
  linestyle      :solid
  normalization  :none
  scale_to       "nothing"
  weights        MakieCore.Automatic()</code></pre></div></div><div class="docstring"><div class="doc-header" id="stephist!"><a href="#stephist!">stephist!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.stephist!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "stephist!" from Makie:
 [1] stephist!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="streamplot"><a href="#streamplot">streamplot</a></div><div class="doc-content"><pre><code>streamplot(f::function, xinterval, yinterval; color = norm, kwargs...)</code></pre><p>f must either accept <code>f(::Point)</code> or <code>f(x::Number, y::Number)</code>. f must return a Point2.</p><p>Example:</p><pre><code class="language-julia">v(x::Point2{T}) where T = Point2f(x[2], 4*x[1])
streamplot(v, -2..2, -2..2)</code></pre><p>One can choose the color of the lines by passing a function <code>color_func(dx::Point)</code> to the <code>color</code> attribute. By default this is set to <code>norm</code>, but can be set to any function or composition of functions. The <code>dx</code> which is passed to <code>color_func</code> is the output of <code>f</code> at the point being colored.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.streamplot}</code> are: </p><pre><code>  alpha           1.0
  arrow_head      MakieCore.Automatic()
  arrow_size      MakieCore.Automatic()
  color           LinearAlgebra.norm
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  density         1.0
  depth_shift     0.0f0
  gridsize        (32, 32, 32)
  highclip        MakieCore.Automatic()
  inspectable     true
  linestyle       "nothing"
  linewidth       1.5
  lowclip         MakieCore.Automatic()
  maxsteps        500
  nan_color       :transparent
  overdraw        false
  quality         16
  space           :data
  ssao            false
  stepsize        0.01
  transparency    false
  visible         true</code></pre><h2>Implementation</h2><p>See the function <code>Makie.streamplot_impl</code> for implementation details.</p></div></div><div class="docstring"><div class="doc-header" id="streamplot!"><a href="#streamplot!">streamplot!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.streamplot!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "streamplot!" from Makie:
 [1] streamplot!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="subscript"><a href="#subscript">subscript</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.subscript</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "subscript" from Makie:
 [1] subscript(args...; kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:292</code></pre></div></div><div class="docstring"><div class="doc-header" id="superscript"><a href="#superscript">superscript</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.superscript</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "superscript" from Makie:
 [1] superscript(args...; kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:293</code></pre></div></div><div class="docstring"><div class="doc-header" id="surface"><a href="#surface">surface</a></div><div class="doc-content"><pre><code>surface(x, y, z)
surface(z)</code></pre><p>Plots a surface, where <code>(x, y)</code> define a grid whose heights are the entries in <code>z</code>. <code>x</code> and <code>y</code> may be <code>Vectors</code> which define a regular grid, <strong>or</strong><code>Matrices</code> which define an irregular grid.</p><h2>Attributes</h2><h3>Specific to <code>Surface</code></h3><ul><li><p><code>invert_normals::Bool = false</code> inverts the normals generated for the surface. This can be useful to illuminate the other side of the surface.</p></li><li><p><code>color = nothing</code>, can be set to an <code>Matrix{&lt;: Union{Number, Colorant}}</code> to color surface independent of the <code>z</code> component. If <code>color=nothing</code>, it defaults to <code>color=z</code>.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = Makie.automatic</code> sets the lighting algorithm used. Options are <code>NoShading</code> (no lighting), <code>FastShading</code> (AmbientLight + PointLight) or <code>MultiLightShading</code> (Multiple lights, GLMakie only). Note that this does not affect RPRMakie.</p></li><li><p><code>diffuse::Vec3f = Vec3f(1.0)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.4)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>backlight::Float32 = 0f0</code> sets a weight for secondary light calculation with inverted normals.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="surface!"><a href="#surface!">surface!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.surface!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "surface!" from MakieCore:
 [1] surface!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="swap!"><a href="#swap!">swap!</a></div><div class="doc-content"><p>Swaps or rotates the layout positions of the given elements to their neighbor's.</p></div></div><div class="docstring"><div class="doc-header" id="text"><a href="#text">text</a></div><div class="doc-content"><pre><code>text(positions; text, kwargs...)
text(x, y; text, kwargs...)
text(x, y, z; text, kwargs...)</code></pre><p>Plots one or multiple texts passed via the <code>text</code> keyword. <code>Text</code> uses the <code>PointBased</code> conversion trait.</p><h2>Attributes</h2><h3>Specific to <code>Text</code></h3><ul><li><p><code>color=theme(scene, :textcolor)</code> sets the color of the text. One can set one color per glyph by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole text. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>text</code> specifies one piece of text or a vector of texts to show, where the number has to match the number of positions given. Makie supports <code>String</code> which is used for all normal text and <code>LaTeXString</code> which layouts mathematical expressions using <code>MathTeXEngine.jl</code>.</p></li><li><p><code>align::Tuple{Union{Symbol, Real}, Union{Symbol, Real}} = (:left, :bottom)</code> sets the alignment of the string w.r.t. <code>position</code>. Uses <code>:left, :center, :right, :top, :bottom, :baseline</code> or fractions.</p></li><li><p><code>font::Union{String, Vector{String}} = :regular</code> sets the font for the string or each character.</p></li><li><p><code>justification::Union{Real, Symbol} = automatic</code> sets the alignment of text w.r.t its bounding box. Can be <code>:left, :center, :right</code> or a fraction. Will default to the horizontal alignment in <code>align</code>.</p></li><li><p><code>rotation::Union{Real, Quaternion}</code> rotates text around the given position.</p></li><li><p><code>fontsize::Union{Real, Vec2f}</code> sets the size of each character.</p></li><li><p><code>markerspace::Symbol = :pixel</code> sets the space in which <code>fontsize</code> acts. See <code>Makie.spaces()</code> for possible inputs.</p></li><li><p><code>strokewidth::Real = 0</code> sets the width of the outline around a marker.</p></li><li><p><code>strokecolor::Union{Symbol, &lt;:Colorant} = :black</code> sets the color of the outline around a marker.</p></li><li><p><code>glowwidth::Real = 0</code> sets the size of a glow effect around the marker.</p></li><li><p><code>glowcolor::Union{Symbol, &lt;:Colorant} = (:black, 0)</code> sets the color of the glow effect.</p></li><li><p><code>word_wrap_width::Real = -1</code> specifies a linewidth limit for text. If a word overflows this limit, a newline is inserted before it. Negative numbers disable word wrapping.</p></li><li><p><code>transform_marker::Bool = false</code> controls whether the model matrix (without translation) applies to the glyph itself, rather than just the positions. (If this is true, <code>scale!</code> and <code>rotate!</code> will affect the text glyphs.)</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="text!"><a href="#text!">text!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.text!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "text!" from MakieCore:
 [1] text!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme"><a href="#theme">theme</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.theme</code> is a <code>Function</code>.</p><pre><code># 8 methods for generic function "theme" from MakieCore:
 [1] theme(key::Symbol; default)
     @ Makie ~/work/Makie.jl/Makie.jl/src/theming.jl:238
 [2] theme(::Nothing)
     @ Makie ~/work/Makie.jl/Makie.jl/src/theming.jl:237
 [3] theme(::Nothing, key::Symbol; default)
     @ Makie ~/work/Makie.jl/Makie.jl/src/theming.jl:236
 [4] theme(x::AbstractScene)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:56
 [5] theme(x::AbstractScene, key; default)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:57
 [6] theme(x::Union{AbstractScene, MakieCore.ScenePlot}, args...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:55
 [7] theme(x::AbstractPlot)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/attributes.jl:166
 [8] theme(x::AbstractPlot, key; default)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:58</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_black"><a href="#theme_black">theme_black</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_black</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_black" from Makie:
 [1] theme_black()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_black.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_dark"><a href="#theme_dark">theme_dark</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_dark</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_dark" from Makie:
 [1] theme_dark()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_dark.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_ggplot2"><a href="#theme_ggplot2">theme_ggplot2</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_ggplot2</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_ggplot2" from Makie:
 [1] theme_ggplot2()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_ggplot2.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_latexfonts"><a href="#theme_latexfonts">theme_latexfonts</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_latexfonts</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_latexfonts" from Makie:
 [1] theme_latexfonts()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_latexfonts.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_light"><a href="#theme_light">theme_light</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_light</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_light" from Makie:
 [1] theme_light()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_light.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_minimal"><a href="#theme_minimal">theme_minimal</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_minimal</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_minimal" from Makie:
 [1] theme_minimal()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_minimal.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="thetalims!"><a href="#thetalims!">thetalims!</a></div><div class="doc-content"><pre><code>thetalims!(ax::PolarAxis, thetamin, thetamax)</code></pre><p>Sets the angular limits of a given <code>PolarAxis</code>.</p></div></div><div class="docstring"><div class="doc-header" id="tight_ticklabel_spacing!"><a href="#tight_ticklabel_spacing!">tight_ticklabel_spacing!</a></div><div class="doc-content"><pre><code>tight_ticklabel_spacing!(ax::Axis)</code></pre><p>Sets the space allocated for the xticklabels and yticklabels of the <code>Axis</code> to the minimum that is needed.</p><pre><code>space = tight_ticklabel_spacing!(cb::Colorbar)</code></pre><p>Sets the space allocated for the ticklabels of the <code>Colorbar</code> to the minimum that is needed and returns that value.</p></div></div><div class="docstring"><div class="doc-header" id="tight_xticklabel_spacing!"><a href="#tight_xticklabel_spacing!">tight_xticklabel_spacing!</a></div><div class="doc-content"><pre><code>space = tight_xticklabel_spacing!(ax::Axis)</code></pre><p>Sets the space allocated for the xticklabels of the <code>Axis</code> to the minimum that is needed and returns that value.</p></div></div><div class="docstring"><div class="doc-header" id="tight_yticklabel_spacing!"><a href="#tight_yticklabel_spacing!">tight_yticklabel_spacing!</a></div><div class="doc-content"><pre><code>space = tight_yticklabel_spacing!(ax::Axis)</code></pre><p>Sets the space allocated for the yticklabels of the <code>Axis</code> to the minimum that is needed and returns that value.</p></div></div><div class="docstring"><div class="doc-header" id="tightlimits!"><a href="#tightlimits!">tightlimits!</a></div><div class="doc-content"><pre><code>tightlimits!(la::Axis)</code></pre><p>Sets the autolimit margins to zero on all sides.</p><pre><code>tightlimits!(la::Axis, sides::Union{Left, Right, Bottom, Top}...)</code></pre><p>Sets the autolimit margins to zero on all given sides.</p><p>Example:</p><pre><code>tightlimits!(laxis, Bottom())</code></pre></div></div><div class="docstring"><div class="doc-header" id="timeseries"><a href="#timeseries">timeseries</a></div><div class="doc-content"><pre><code>timeseries(x::Observable{{Union{Number, Point2}}})</code></pre><p>Plots a sampled signal. Usage:</p><pre><code class="language-julia">signal = Observable(1.0)
scene = timeseries(signal)
display(scene)
# @async is optional, but helps to continue evaluating more code
@async while isopen(scene)
    # aquire data from e.g. a sensor:
    data = rand()
    # update the signal
    signal[] = data
    # sleep/ wait for new data/ whatever...
    # It's important to yield here though, otherwise nothing will be rendered
    sleep(1/30)
end
</code></pre></div></div><div class="docstring"><div class="doc-header" id="timeseries!"><a href="#timeseries!">timeseries!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.timeseries!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "timeseries!" from Makie:
 [1] timeseries!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_align"><a href="#to_align">to_align</a></div><div class="doc-content"><pre><code>to_align(align[, error_prefix])</code></pre><p>Converts the given align to a <code>Vec2f</code>. Can convert <code>VecTypes{2}</code> and two component <code>Tuple</code>s with <code>Real</code> and <code>Symbol</code> elements.</p><p>To specify a custom error message you can add an <code>error_prefix</code> or use <code>halign2num(value, error_msg)</code> and <code>valign2num(value, error_msg)</code> respectively.</p></div></div><div class="docstring"><div class="doc-header" id="to_color"><a href="#to_color">to_color</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_color</code> is a <code>Function</code>.</p><pre><code># 13 methods for generic function "to_color" from Makie:
  [1] to_color(scene::Scene, attribute_name, cycled::Cycled)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/blocks/axis.jl:695
  [2] to_color(c::Symbol)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:854
  [3] to_color(p::Makie.Palette)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:845
  [4] to_color(c::String)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:855
  [5] to_color(c::Nothing)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:851
  [6] to_color(c::Makie.ColorMapping)
     @ ~/work/Makie.jl/Makie.jl/src/colorsampler.jl:344
  [7] to_color(c::ColorTypes.Colorant)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:853
  [8] to_color(sampler::Sampler)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:1737
  [9] to_color(c::Real)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:852
 [10] to_color(p::Makie.AbstractPattern)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:858
 [11] to_color(c::AbstractArray{&lt;:ColorTypes.Colorant, N}) where N
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:857
 [12] to_color(c::AbstractArray)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:856
 [13] to_color(c::Tuple{Any, Number})
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:859</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_colormap"><a href="#to_colormap">to_colormap</a></div><div class="doc-content"><pre><code>to_colormap(b::AbstractVector)</code></pre><p>An <code>AbstractVector{T}</code> with any object that <a href="@ref"><code>to_color</code></a> accepts.</p><pre><code>to_colormap(cs::Union{String, Symbol})::Vector{RGBAf}</code></pre><p>A Symbol/String naming the gradient. For more on what names are available please see: <code>available_gradients()</code>. For now, we support gradients from <code>PlotUtils</code> natively.</p></div></div><div class="docstring"><div class="doc-header" id="to_font"><a href="#to_font">to_font</a></div><div class="doc-content"><pre><code>to_font(str::String)</code></pre><p>Loads a font specified by <code>str</code> and returns a <code>NativeFont</code> object storing the font handle. A font can either be specified by a file path, such as "folder/with/fonts/font.otf", or by a (partial) name such as "Helvetica", "Helvetica Bold" etc.</p></div></div><div class="docstring"><div class="doc-header" id="to_fontsize"><a href="#to_fontsize">to_fontsize</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_fontsize</code> is a <code>Function</code>.</p><pre><code># 4 methods for generic function "to_fontsize" from Makie:
 [1] to_fontsize(x::Vec2)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:1195
 [2] to_fontsize(x::AbstractVector{T}) where T&lt;:(Vec2)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:1196
 [3] to_fontsize(x::AbstractVector{T}) where T&lt;:Number
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:1194
 [4] to_fontsize(x::Number)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:1193</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_ndim"><a href="#to_ndim">to_ndim</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_ndim</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "to_ndim" from Makie:
 [1] to_ndim(T::Type{&lt;:Union{Tuple{Vararg{ET, N}}, StaticArraysCore.StaticArray{Tuple{N}, ET, 1}}}, vec::Union{Tuple{Vararg{T, N2}}, StaticArraysCore.StaticArray{Tuple{N2}, T, 1}} where T, fillval) where {N, ET, N2}
     @ ~/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:242</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_rotation"><a href="#to_rotation">to_rotation</a></div><div class="doc-content"><pre><code>rotation accepts:
to_rotation(b, quaternion)
to_rotation(b, tuple_float)
to_rotation(b, vec4)</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_value"><a href="#to_value">to_value</a></div><div class="doc-content"><pre><code>to_value(x::Union{Any, AbstractObservable})</code></pre><p>Extracts the value of an observable, and returns the object if it's not an observable!</p></div></div><div class="docstring"><div class="doc-header" id="to_vector"><a href="#to_vector">to_vector</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_vector</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "to_vector" from Makie:
 [1] to_vector(x::IntervalSets.ClosedInterval, len, T)
     @ ~/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:289
 [2] to_vector(x::AbstractVector, len, T)
     @ ~/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:281
 [3] to_vector(x::AbstractArray, len, T)
     @ ~/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:282</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_world"><a href="#to_world">to_world</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_world</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "to_world" from Makie:
 [1] to_world(p::Vec{N, T}, prj_view_inv::StaticArraysCore.SMatrix{4, 4, T, 16} where T, cam_res::StaticArraysCore.StaticArray{Tuple{N}, T, 1} where {N, T}) where {N, T}
     @ ~/work/Makie.jl/Makie.jl/src/camera/projection_math.jl:272
 [2] to_world(p::StaticArraysCore.StaticArray{Tuple{N}, T, 1}, prj_view_inv::StaticArraysCore.SMatrix{4, 4, T, 16} where T, cam_res::StaticArraysCore.StaticArray{Tuple{N}, T, 1} where {N, T}) where {N, T}
     @ ~/work/Makie.jl/Makie.jl/src/camera/projection_math.jl:256
 [3] to_world(scene::Scene, point::T) where T&lt;:(StaticArraysCore.StaticArray{Tuple{N}, T, 1} where {N, T})
     @ ~/work/Makie.jl/Makie.jl/src/camera/projection_math.jl:241</code></pre></div></div><div class="docstring"><div class="doc-header" id="tooltip"><a href="#tooltip">tooltip</a></div><div class="doc-content"><pre><code>tooltip(position, string)
tooltip(x, y, string)</code></pre><p>Creates a tooltip pointing at <code>position</code> displaying the given <code>string</code></p><h2>Attributes</h2><h3>Generic</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for positions of markers. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul><h3>Tooltip specific</h3><ul><li><p><code>offset = 10</code> sets the offset between the given <code>position</code> and the tip of the triangle pointing at that position.</p></li><li><p><code>placement = :above</code> sets where the tooltipÃ¼ should be placed relative to <code>position</code>. Can be <code>:above</code>, <code>:below</code>, <code>:left</code>, <code>:right</code>.</p></li><li><p><code>align = 0.5</code> sets the alignment of the tooltip relative <code>position</code>. With <code>align = 0.5</code> the tooltip is centered above/below/left/right the <code>position</code>.</p></li><li><p><code>backgroundcolor = :white</code> sets the background color of the tooltip.</p></li><li><p><code>triangle_size = 10</code> sets the size of the triangle pointing at <code>position</code>.</p></li><li><p><code>outline_color = :black</code> sets the color of the tooltip outline.</p></li><li><p><code>outline_linewidth = 2f0</code> sets the linewidth of the tooltip outline.</p></li><li><p><code>outline_linestyle = nothing</code> sets the linestyle of the tooltip outline.</p></li><li><p><code>textpadding = (4, 4, 4, 4)</code> sets the padding around text in the tooltip. This is given as <code>(left, right, bottom top)</code> offsets.</p></li><li><p><code>textcolor = theme(scene, :textcolor)</code> sets the text color.</p></li><li><p><code>fontsize = 16</code> sets the text size.</p></li><li><p><code>font = theme(scene, :font)</code> sets the font.</p></li><li><p><code>strokewidth = 0</code>: Gives text an outline if set to a positive value.</p></li><li><p><code>strokecolor = :white</code> sets the text outline color.</p></li><li><p><code>justification = :left</code> sets whether text is aligned to the <code>:left</code>, <code>:center</code> or <code>:right</code> within its bounding box.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="tooltip!"><a href="#tooltip!">tooltip!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.tooltip!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "tooltip!" from Makie:
 [1] tooltip!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="top"><a href="#top">top</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.top</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "top" from Makie:
 [1] top(rect::Rect2)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:5</code></pre></div></div><div class="docstring"><div class="doc-header" id="translate!"><a href="#translate!">translate!</a></div><div class="doc-content"><pre><code>translate!(t::Transformable, xyz::VecTypes)
translate!(t::Transformable, xyz...)</code></pre><p>Apply an absolute translation to the given <code>Transformable</code> (a Scene or Plot), translating it to <code>x, y, z</code>.</p><pre><code>translate!(Accum, t::Transformable, xyz...)</code></pre><p>Translate the given <code>Transformable</code> (a Scene or Plot), relative to its current position.</p></div></div><div class="docstring"><div class="doc-header" id="translate_cam!"><a href="#translate_cam!">translate_cam!</a></div><div class="doc-content"><pre><code>translate_cam!(scene, cam::Camera3D, v::Vec3)</code></pre><p>Translates the camera by the given vector in camera space, i.e. by <code>v[1]</code> to the right, <code>v[2]</code> to the top and <code>v[3]</code> forward.</p><p>Note that this method reacts to <code>fix_x_key</code> etc. If any of those keys are pressed the translation will be restricted to act in these directions.</p><pre><code>translate_cam!(scene::Scene, translation::VecTypes)</code></pre><p>Translate the camera by a translation vector given in camera space.</p></div></div><div class="docstring"><div class="doc-header" id="translated"><a href="#translated">translated</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.translated</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "translated" from Makie:
 [1] translated(scene::Scene; kw_args...)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/transformation.jl:40
 [2] translated(scene::Scene, translation...)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/transformation.jl:34</code></pre></div></div><div class="docstring"><div class="doc-header" id="translation"><a href="#translation">translation</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.translation</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "translation" from Makie:
 [1] translation(t::MakieCore.Transformable)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/transformation.jl:115</code></pre></div></div><div class="docstring"><div class="doc-header" id="tricontourf"><a href="#tricontourf">tricontourf</a></div><div class="doc-content"><pre><code>tricontourf(triangles::Triangulation, zs; kwargs...)
tricontourf(xs, ys, zs; kwargs...)</code></pre><p>Plots a filled tricontour of the height information in <code>zs</code> at the horizontal positions <code>xs</code> and vertical positions <code>ys</code>. A <code>Triangulation</code> from DelaunayTriangulation.jl can also be provided instead of <code>xs</code> and <code>ys</code> for specifying the triangles, otherwise an unconstrained triangulation of <code>xs</code> and <code>ys</code> is computed.</p><h2>Attributes</h2><h3>Specific to <code>Tricontourf</code></h3><ul><li><p><code>levels = 10</code> can be either an <code>Int</code> which results in n bands delimited by n+1 equally spaced levels, or it can be an <code>AbstractVector{&lt;:Real}</code> that lists n consecutive edges from low to high, which result in n-1 bands.</p></li><li><p><code>mode = :normal</code> sets the way in which a vector of levels is interpreted, if it's set to <code>:relative</code>, each number is interpreted as a fraction between the minimum and maximum values of <code>zs</code>. For example, <code>levels = 0.1:0.1:1.0</code> would exclude the lower 10% of data.</p></li><li><p><code>extendlow = nothing</code>. This sets the color of an optional additional band from <code>minimum(zs)</code> to the lowest value in <code>levels</code>. If it's <code>:auto</code>, the lower end of the colormap is picked and the remaining colors are shifted accordingly. If it's any color representation, this color is used. If it's <code>nothing</code>, no band is added.</p></li><li><p><code>extendhigh = nothing</code>. This sets the color of an optional additional band from the highest value of <code>levels</code> to <code>maximum(zs)</code>. If it's <code>:auto</code>, the high end of the colormap is picked and the remaining colors are shifted accordingly. If it's any color representation, this color is used. If it's <code>nothing</code>, no band is added.</p></li><li><p><code>triangulation = DelaunayTriangulation()</code>. The mode with which the points in <code>xs</code> and <code>ys</code> are triangulated. Passing <code>DelaunayTriangulation()</code> performs a Delaunay triangulation. You can also pass a preexisting triangulation as an <code>AbstractMatrix{&lt;:Int}</code> with size (3, n), where each column specifies the vertex indices of one triangle, or as a <code>Triangulation</code> from DelaunayTriangulation.jl.</p></li></ul><h3>Generic</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = false</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>color</code> sets the color of the plot. It can be given as a named color <code>Symbol</code> or a <code>Colors.Colorant</code>. Transparency can be included either directly as an alpha value in the <code>Colorant</code> or as an additional float in a tuple <code>(color, alpha)</code>. The color can also be set for each scattered marker by passing a <code>Vector</code> of colors or be used to index the <code>colormap</code> by passing a <code>Real</code> number or <code>Vector{&lt;: Real}</code>.</p></li><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap from which the band colors are sampled.</p></li><li><p><code>colorscale::Function = identity</code> color transform function.</p></li></ul><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.tricontourf}</code> are: </p><pre><code>  colormap       :viridis
  colorscale     identity
  edges          "nothing"
  extendhigh     "nothing"
  extendlow      "nothing"
  inspectable    true
  levels         10
  mode           :normal
  nan_color      :transparent
  transparency   false
  triangulation  Makie.DelaunayTriangulation()</code></pre></div></div><div class="docstring"><div class="doc-header" id="tricontourf!"><a href="#tricontourf!">tricontourf!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.tricontourf!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "tricontourf!" from Makie:
 [1] tricontourf!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="trim!"><a href="#trim!">trim!</a></div><div class="doc-content"><pre><code>trim!(gl::GridLayout)</code></pre><p>Remove empty rows and columns from <code>gl</code>.</p></div></div><div class="docstring"><div class="doc-header" id="triplot"><a href="#triplot">triplot</a></div><div class="doc-content"><pre><code>triplot(x, y; kwargs...)
triplot(positions; kwargs...)
triplot(triangles::Triangulation; kwargs...)</code></pre><p>Plots a triangulation based on the provided position or <code>Triangulation</code> from DelaunayTriangulation.jl.</p><h2>Attributes</h2><ul><li><p><code>show_points = false</code> determines whether to plot the individual points. Note that this will only plot points included in the triangulation.</p></li><li><p><code>show_convex_hull = false</code> determines whether to plot the convex hull.</p></li><li><p><code>show_ghost_edges = false</code> determines whether to plot the ghost edges.</p></li><li><p><code>show_constrained_edges = false</code> determines whether to plot the constrained edges.</p></li><li><p><code>recompute_centers = false</code> determines whether to recompute the representative points for the ghost edge orientation. Note that this will mutate <code>tri.representative_point_list</code> directly.</p></li><li><p><code>markersize = 12</code> sets the size of the points.</p></li><li><p><code>marker = :circle</code> sets the shape of the points.</p></li><li><p><code>markercolor = :black</code> sets the color of the points.</p></li><li><p><code>strokecolor = :black</code> sets the color of triangle edges.</p></li><li><p><code>strokewidth = 1</code> sets the linewidth of triangle edges.</p></li><li><p><code>linestyle = :solid</code> sets the linestyle of triangle edges.</p></li><li><p><code>triangle_color = (:white, 0.0)</code> sets the color of the triangles.</p></li><li><p><code>convex_hull_color = :red</code> sets the color of the convex hull.</p></li><li><p><code>convex_hull_linestyle = :dash</code> sets the linestyle of the convex hull.</p></li><li><p><code>convex_hull_linewidth = 1</code> sets the width of the convex hull.</p></li><li><p><code>ghost_edge_color = :blue</code> sets the color of the ghost edges.</p></li><li><p><code>ghost_edge_linestyle = :solid</code> sets the linestyle of the ghost edges.</p></li><li><p><code>ghost_edge_linewidth = 1</code> sets the width of the ghost edges.</p></li><li><p><code>ghost_edge_extension_factor = 0.1</code> sets the extension factor for the rectangle that the exterior ghost edges are extended onto.</p></li><li><p><code>bounding_box::Union{Automatic, Rect2, Tuple} = automatic</code>: Sets the bounding box for truncating ghost edges which can be a <code>Rect2</code> (or <code>BBox</code>) or a tuple of the form <code>(xmin, xmax, ymin, ymax)</code>. By default, the rectangle will be given by <code>[a - eÎx, b + eÎx] Ã [c - eÎy, d + eÎy]</code> where <code>e</code> is the <code>ghost_edge_extension_factor</code>, <code>Îx = b - a</code> and <code>Îy = d - c</code> are the lengths of the sides of the rectangle, and <code>[a, b] Ã [c, d]</code> is the bounding box of the points in the triangulation.</p></li><li><p><code>constrained_edge_color = :magenta</code> sets the color of the constrained edges.</p></li><li><p><code>constrained_edge_linestyle = :solid</code> sets the linestyle of the constrained edges.</p></li><li><p><code>constrained_edge_linewidth = 1</code> sets the width of the constrained edges.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="triplot!"><a href="#triplot!">triplot!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.triplot!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "triplot!" from Makie:
 [1] triplot!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="unicode_input"><a href="#unicode_input">unicode_input</a></div><div class="doc-content"><p>Registers a callback for keyboard unicode input. returns an <code>Observable{Vector{Char}}</code>, containing the pressed char. Is empty, if no key is pressed. <a href="http://www.glfw.org/docs/latest/group__input.html#ga1e008c7a8751cea648c8f42cc91104cf">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="update_cam!"><a href="#update_cam!">update_cam!</a></div><div class="doc-content"><pre><code>update_cam!(scene::SceneLike, area)</code></pre><p>Updates the camera for the given <code>scene</code> to cover the given <code>area</code> in 2d.</p><pre><code>update_cam!(scene::SceneLike)</code></pre><p>Updates the camera for the given <code>scene</code> to cover the limits of the <code>Scene</code>. Useful when using the <code>Observable</code> pipeline.</p><pre><code>update_cam!(scene, cam::Camera3D, Ï, Î¸[, radius])</code></pre><p>Set the camera position based on two angles <code>0 â¤ Ï â¤ 2Ï</code> and <code>-pi/2 â¤ Î¸ â¤ pi/2</code> and an optional radius around the current <code>cam.lookat[]</code>.</p><pre><code>update_cam!(scene::Scene, eyeposition, lookat, up = Vec3f(0, 0, 1))</code></pre><p>Updates the camera's controls to point to the specified location.</p></div></div><div class="docstring"><div class="doc-header" id="update_theme!"><a href="#update_theme!">update_theme!</a></div><div class="doc-content"><pre><code>update_theme!(with_theme::Theme; kwargs...)</code></pre><p>Update the current theme incrementally. This means that only the keys given in <code>with_theme</code> or through keyword arguments are changed, the rest is left intact. Nested attributes are either also updated incrementally, or replaced if they are not attributes in the new theme.</p><h1>Example</h1><p>To change the default colormap to <code>:greys</code>, you can pass that attribute as a keyword argument to <code>update_theme!</code> as demonstrated below.</p><pre><code>update_theme!(colormap=:greys)</code></pre><p>This can also be achieved by passing an object of types <code>Attributes</code> or <code>Theme</code> as the first and only positional argument:</p><pre><code>update_theme!(Attributes(colormap=:greys))
update_theme!(Theme(colormap=:greys))</code></pre></div></div><div class="docstring"><div class="doc-header" id="used_attributes"><a href="#used_attributes">used_attributes</a></div><div class="doc-content"><pre><code>used_attributes(args...) = ()</code></pre><p>Function used to indicate what keyword args one wants to get passed in <code>convert_arguments</code>. Those attributes will not be forwarded to the backend, but only used during the conversion pipeline. Usage:</p><pre><code class="language-julia">    struct MyType end
    used_attributes(::MyType) = (:attribute,)
    function convert_arguments(x::MyType; attribute = 1)
        ...
    end
    # attribute will get passed to convert_arguments
    # without keyword_verload, this wouldn't happen
    plot(MyType, attribute = 2)
    #You can also use the convenience macro, to overload convert_arguments in one step:
    @keywords convert_arguments(x::MyType; attribute = 1)
        ...
    end</code></pre></div></div><div class="docstring"><div class="doc-header" id="vgrid!"><a href="#vgrid!">vgrid!</a></div><div class="doc-content"><pre><code>vbox!(content::Vararg; kwargs...)</code></pre><p>Creates a single-column GridLayout with all elements contained in <code>content</code> placed from top to bottom.</p></div></div><div class="docstring"><div class="doc-header" id="viewport"><a href="#viewport">viewport</a></div><div class="doc-content"><pre><code>viewport(scene::Scene)</code></pre><p>Gets the viewport of the scene in device independent units as an <code>Observable{Rect2{Int}}</code>.</p></div></div><div class="docstring"><div class="doc-header" id="violin"><a href="#violin">violin</a></div><div class="doc-content"><pre><code>violin(x, y; kwargs...)</code></pre><p>Draw a violin plot.</p><h1>Arguments</h1><ul><li><p><code>x</code>: positions of the categories</p></li><li><p><code>y</code>: variables whose density is computed</p></li></ul><h1>Keywords</h1><ul><li><p><code>weights</code>: vector of statistical weights (length of data). By default, each observation has weight <code>1</code>.</p></li><li><p><code>orientation=:vertical</code>: orientation of the violins (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=1</code>: width of the box before shrinking</p></li><li><p><code>gap=0.2</code>: shrinking factor, <code>width -&gt; width * (1 - gap)</code></p></li><li><p><code>show_median=false</code>: show median as midline</p></li><li><p><code>side=:both</code>: specify <code>:left</code> or <code>:right</code> to only plot the violin on one side</p></li><li><p><code>scale=:width</code>: scale density by area (<code>:area</code>), count (<code>:count</code>), or width (<code>:width</code>).</p></li><li><p><code>datalimits</code>: specify values to trim the <code>violin</code>. Can be a <code>Tuple</code> or a <code>Function</code> (e.g. <code>datalimits=extrema</code>)</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="violin!"><a href="#violin!">violin!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.violin!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "violin!" from Makie:
 [1] violin!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="vlines"><a href="#vlines">vlines</a></div><div class="doc-content"><pre><code>vlines(xs; ymin = 0.0, ymax = 1.0, attrs...)</code></pre><p>Create vertical lines across a <code>Scene</code> with 2D projection. The lines will be placed at <code>xs</code> in data coordinates and <code>ymin</code> to <code>ymax</code> in scene coordinates (0 to 1). All three of these can have single or multiple values because they are broadcast to calculate the final line segments.</p><p>All style attributes are the same as for <code>LineSegments</code>.</p></div></div><div class="docstring"><div class="doc-header" id="vlines!"><a href="#vlines!">vlines!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.vlines!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "vlines!" from Makie:
 [1] vlines!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="volume"><a href="#volume">volume</a></div><div class="doc-content"><pre><code>volume(volume_data)
volume(x, y, z, volume_data)</code></pre><p>Plots a volume, with optional physical dimensions <code>x, y, z</code>. Available algorithms are:</p><ul><li><p><code>:iso</code> =&gt; IsoValue</p></li><li><p><code>:absorption</code> =&gt; Absorption</p></li><li><p><code>:mip</code> =&gt; MaximumIntensityProjection</p></li><li><p><code>:absorptionrgba</code> =&gt; AbsorptionRGBA</p></li><li><p><code>:additive</code> =&gt; AdditiveRGBA</p></li><li><p><code>:indexedabsorption</code> =&gt; IndexedAbsorptionRGBA</p></li></ul><h2>Attributes</h2><h3>Specific to <code>Volume</code></h3><ul><li><p><code>algorithm::Union{Symbol, RaymarchAlgorithm} = :mip</code> sets the volume algorithm that is used.</p></li><li><p><code>isorange::Real = 0.05</code> sets the range of values picked up by the IsoValue algorithm.</p></li><li><p><code>isovalue = 0.5</code> sets the target value for the IsoValue algorithm.</p></li><li><p><code>interpolate::Bool = true</code> sets whether the volume data should be sampled with interpolation.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = Makie.automatic</code> sets the lighting algorithm used. Options are <code>NoShading</code> (no lighting), <code>FastShading</code> (AmbientLight + PointLight) or <code>MultiLightShading</code> (Multiple lights, GLMakie only). Note that this does not affect RPRMakie.</p></li><li><p><code>diffuse::Vec3f = Vec3f(1.0)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.4)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>backlight::Float32 = 0f0</code> sets a weight for secondary light calculation with inverted normals.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="volume!"><a href="#volume!">volume!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.volume!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "volume!" from MakieCore:
 [1] volume!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="volumeslices"><a href="#volumeslices">volumeslices</a></div><div class="doc-content"><p>VolumeSlices</p><pre><code>volumeslices(x, y, z, v)</code></pre><p>Draws heatmap slices of the volume v</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.volumeslices}</code> are: </p><pre><code>  alpha           1.0
  bbox_color      RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.5f0)
  bbox_visible    true
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  depth_shift     0.0f0
  highclip        MakieCore.Automatic()
  inspectable     true
  interpolate     false
  linewidth       0.0
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  space           :data
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="volumeslices!"><a href="#volumeslices!">volumeslices!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.volumeslices!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "volumeslices!" from Makie:
 [1] volumeslices!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="voronoiplot"><a href="#voronoiplot">voronoiplot</a></div><div class="doc-content"><pre><code>voronoiplot(x, y, values; kwargs...)
voronoiplot(values; kwargs...)
voronoiplot(x, y; kwargs...)
voronoiplot(positions; kwargs...)
voronoiplot(vorn::VoronoiTessellation; kwargs...)</code></pre><p>Generates and plots a Voronoi tessalation from <code>heatmap</code>- or point-like data. The tessellation can also be passed directly as a <code>VoronoiTessellation</code> from DelaunayTriangulation.jl.</p><h2>Attributes</h2><ul><li><p><code>show_generators = true</code> determines whether to plot the individual generators.</p></li><li><p><code>markersize = 12</code> sets the size of the points.</p></li><li><p><code>marker = :circle</code> sets the shape of the points.</p></li><li><p><code>markercolor = :black</code> sets the color of the points.</p></li><li><p><code>strokecolor = :black</code> sets the strokecolor of the polygons.</p></li><li><p><code>strokewidth = 1</code> sets the width of the polygon stroke.</p></li><li><p><code>color = automatic</code> sets the color of the polygons. If <code>automatic</code>, the polygons will be individually colored according to the colormap.</p></li><li><p><code>unbounded_edge_extension_factor = 0.1</code> sets the extension factor for the unbounded edges, used in <code>DelaunayTriangulation.polygon_bounds</code>.</p></li><li><p><code>clip::Union{Automatic, Rect2, Circle, Tuple} = automatic</code> sets the clipping area for the generated polygons which can be a <code>Rect2</code> (or <code>BBox</code>), <code>Tuple</code> with entries <code>(xmin, xmax, ymin, ymax)</code> or as a <code>Circle</code>. Anything outside the specified area will be removed. If the <code>clip</code> is not set it is automatically determined using <code>unbounded_edge_extension_factor</code> as a <code>Rect</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="voronoiplot!"><a href="#voronoiplot!">voronoiplot!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.voronoiplot!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "voronoiplot!" from Makie:
 [1] voronoiplot!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="vspan"><a href="#vspan">vspan</a></div><div class="doc-content"><pre><code>vspan(xs_low, xs_high; ymin = 0.0, ymax = 1.0, attrs...)
vspan(xs_lowhigh; ymin = 0.0, ymax = 1.0, attrs...)</code></pre><p>Create vertical bands spanning across a <code>Scene</code> with 2D projection. The bands will be placed from <code>xs_low</code> to <code>xs_high</code> in data coordinates and <code>ymin</code> to <code>ymax</code> in scene coordinates (0 to 1). All four of these can have single or multiple values because they are broadcast to calculate the final spans. Both bounds can be passed together as an interval <code>xs_lowhigh</code>.</p><p>All style attributes are the same as for <code>Poly</code>.</p></div></div><div class="docstring"><div class="doc-header" id="vspan!"><a href="#vspan!">vspan!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.vspan!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "vspan!" from Makie:
 [1] vspan!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="waterfall"><a href="#waterfall">waterfall</a></div><div class="doc-content"><pre><code>waterfall(x, y; kwargs...)</code></pre><p>Plots a <a href="https://en.wikipedia.org/wiki/Waterfall_chart">waterfall chart</a> to visualize individual positive and negative components that add up to a net result as a barplot with stacked bars next to each other.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Plot{Makie.waterfall}</code> are: </p><pre><code>  cycle            [:color =&gt; :patchcolor]
  direction_color  :white
  dodge            MakieCore.Automatic()
  dodge_gap        0.03
  final_color      RGBA{Float64}(0.8980392156862745,0.8980392156862745,0.8980392156862745,0.5)
  final_dodge_gap  0
  final_gap        MakieCore.Automatic()
  gap              0.2
  marker_neg       :dtriangle
  marker_pos       :utriangle
  n_dodge          MakieCore.Automatic()
  show_direction   false
  show_final       false
  stack            MakieCore.Automatic()
  width            MakieCore.Automatic()</code></pre><p>Furthermore the same attributes as for <code>barplot</code> are supported.</p></div></div><div class="docstring"><div class="doc-header" id="waterfall!"><a href="#waterfall!">waterfall!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.waterfall!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "waterfall!" from Makie:
 [1] waterfall!(args...; kw...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:176</code></pre></div></div><div class="docstring"><div class="doc-header" id="width"><a href="#width">width</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.width</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "width" from GeometryBasics:
 [1] width(prim::GeometryBasics.HyperRectangle)
     @ ~/.julia/packages/GeometryBasics/ebXl0/src/primitives/rectangles.jl:186</code></pre></div></div><div class="docstring"><div class="doc-header" id="widths"><a href="#widths">widths</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.widths</code> is a <code>Function</code>.</p><pre><code># 4 methods for generic function "widths" from GeometryBasics:
 [1] widths(scene::Scene)
     @ Makie ~/work/Makie.jl/Makie.jl/src/scenes.jl:342
 [2] widths(x::AbstractRange)
     @ ~/.julia/packages/GeometryBasics/ebXl0/src/geometry_primitives.jl:4
 [3] widths(c::GeometryBasics.HyperSphere{N, T}) where {N, T}
     @ ~/.julia/packages/GeometryBasics/ebXl0/src/primitives/spheres.jl:28
 [4] widths(prim::GeometryBasics.HyperRectangle)
     @ ~/.julia/packages/GeometryBasics/ebXl0/src/primitives/rectangles.jl:184</code></pre></div></div><div class="docstring"><div class="doc-header" id="window_area"><a href="#window_area">window_area</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.window_area</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "window_area" from Makie:
 [1] window_area(scene::Scene, screen::GLMakie.Screen)
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:40
 [2] window_area(scene, native_window)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/events.jl:3</code></pre></div></div><div class="docstring"><div class="doc-header" id="window_open"><a href="#window_open">window_open</a></div><div class="doc-content"><p>Returns a signal, which is true as long as the window is open. returns <code>Observable{Bool}</code><a href="http://www.glfw.org/docs/latest/group__window.html#gaade9264e79fae52bdb78e2df11ee8d6a">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="wireframe"><a href="#wireframe">wireframe</a></div><div class="doc-content"><pre><code>wireframe(x, y, z)
wireframe(positions)
wireframe(mesh)</code></pre><p>Draws a wireframe, either interpreted as a surface or as a mesh.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Wireframe</code> are: </p><pre><code>  alpha           1.0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  cycle           [:color]
  depth_shift     -1.0f-5
  highclip        MakieCore.Automatic()
  inspectable     true
  linestyle       "nothing"
  linewidth       1.5
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  space           :data
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="wireframe!"><a href="#wireframe!">wireframe!</a></div><div class="doc-content"><p>See <a href="@ref"><code>wireframe</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="with_theme"><a href="#with_theme">with_theme</a></div><div class="doc-content"><pre><code>with_theme(f, theme = Theme(); kwargs...)</code></pre><p>Calls <code>f</code> with <code>theme</code> temporarily activated. Attributes in <code>theme</code> can be overridden or extended with <code>kwargs</code>. The previous theme is always restored afterwards, no matter if <code>f</code> succeeds or fails.</p><p>Example:</p><pre><code class="language-julia">my_theme = Theme(size = (500, 500), color = :red)
with_theme(my_theme, color = :blue, linestyle = :dashed) do
    scatter(randn(100, 2))
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="with_updates_suspended"><a href="#with_updates_suspended">with_updates_suspended</a></div><div class="doc-content"><pre><code>with_updates_suspended(f::Function, gl::GridLayout; update = true)</code></pre><p>Disable layout updates for <code>gl</code> and call the function <code>f</code>. If <code>update</code> is true, force a layout update after <code>f</code> returns.</p></div></div><div class="docstring"><div class="doc-header" id="xlabel!"><a href="#xlabel!">xlabel!</a></div><div class="doc-content"><pre><code>xlabel!([scene,] xlabel)</code></pre><p>Set the x-axis label for the given Scene. Defaults to using the current Scene.</p></div></div><div class="docstring"><div class="doc-header" id="xlims!"><a href="#xlims!">xlims!</a></div><div class="doc-content"><pre><code>xlims!(ax, low, high)
xlims!(ax; low = nothing, high = nothing)
xlims!(ax, (low, high))
xlims!(ax, low..high)</code></pre><p>Set the x-axis limits of axis <code>ax</code> to <code>low</code> and <code>high</code> or a tuple <code>xlims = (low,high)</code>. If the limits are ordered high-low, the axis orientation will be reversed. If a limit is <code>nothing</code> it will be determined automatically from the plots in the axis.</p><pre><code>xlims!(low, high)
xlims!(; low = nothing, high = nothing)</code></pre><p>Set the x-axis limits of the current axis to <code>low</code> and <code>high</code>. If the limits are ordered high-low, this reverses the axis orientation. A limit set to <code>nothing</code> will be determined automatically from the plots in the axis.</p><pre><code>xlims!(ax = current_axis())</code></pre><p>Reset the x-axis limits to be determined automatically from the plots in the axis.</p></div></div><div class="docstring"><div class="doc-header" id="xticklabels"><a href="#xticklabels">xticklabels</a></div><div class="doc-content"><pre><code>xticklabels(scene)</code></pre><p>Returns all the x-axis tick labels. See also <code>ticklabels</code>.</p></div></div><div class="docstring"><div class="doc-header" id="xtickrange"><a href="#xtickrange">xtickrange</a></div><div class="doc-content"><pre><code>xtickrange(scene)</code></pre><p>Returns the tick range along the x-axis. See also <code>tickranges</code>.</p></div></div><div class="docstring"><div class="doc-header" id="xtickrotation"><a href="#xtickrotation">xtickrotation</a></div><div class="doc-content"><pre><code>xtickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the x-axis. See also <code>tickrotations</code></p></div></div><div class="docstring"><div class="doc-header" id="xtickrotation!"><a href="#xtickrotation!">xtickrotation!</a></div><div class="doc-content"><pre><code>xtickrotation!([scene,] xangle)</code></pre><p>Set the rotation of tick labels along the x-axis. See also <code>tickrotations!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="xticks!"><a href="#xticks!">xticks!</a></div><div class="doc-content"><pre><code>xticks!([scene,]; xtickrange=xtickrange(scene), xticklabels=xticklabel(scene))</code></pre><p>Set the tick labels and range along the x-axis. See also <code>ticks!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ylabel!"><a href="#ylabel!">ylabel!</a></div><div class="doc-content"><pre><code>ylabel!([scene,] ylabel)</code></pre><p>Set the y-axis label for the given Scene. Defaults to using the current Scene.</p></div></div><div class="docstring"><div class="doc-header" id="ylims!"><a href="#ylims!">ylims!</a></div><div class="doc-content"><pre><code>ylims!(ax, low, high)
ylims!(ax; low = nothing, high = nothing)
ylims!(ax, (low, high))
ylims!(ax, low..high)</code></pre><p>Set the y-axis limits of axis <code>ax</code> to <code>low</code> and <code>high</code> or a tuple <code>ylims = (low,high)</code>. If the limits are ordered high-low, the axis orientation will be reversed. If a limit is <code>nothing</code> it will be determined automatically from the plots in the axis.</p><pre><code>ylims!(low, high)
ylims!(; low = nothing, high = nothing)</code></pre><p>Set the y-axis limits of the current axis to <code>low</code> and <code>high</code>. If the limits are ordered high-low, this reverses the axis orientation. A limit set to <code>nothing</code> will be determined automatically from the plots in the axis.</p><pre><code>ylims!(ax = current_axis())</code></pre><p>Reset the y-axis limits to be determined automatically from the plots in the axis.</p></div></div><div class="docstring"><div class="doc-header" id="yticklabels"><a href="#yticklabels">yticklabels</a></div><div class="doc-content"><pre><code>yticklabels(scene)</code></pre><p>Returns all the y-axis tick labels. See also <code>ticklabels</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ytickrange"><a href="#ytickrange">ytickrange</a></div><div class="doc-content"><pre><code>ytickrange(scene)</code></pre><p>Returns the tick range along the y-axis. See also <code>tickranges</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ytickrotation"><a href="#ytickrotation">ytickrotation</a></div><div class="doc-content"><pre><code>ytickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the y-axis. See also <code>tickrotations</code></p></div></div><div class="docstring"><div class="doc-header" id="ytickrotation!"><a href="#ytickrotation!">ytickrotation!</a></div><div class="doc-content"><pre><code>ytickrotation!([scene,] yangle)</code></pre><p>Set the rotation of tick labels along the y-axis. See also <code>tickrotations!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="yticks!"><a href="#yticks!">yticks!</a></div><div class="doc-content"><pre><code>yticks!([scene,]; ytickrange=ytickrange(scene), yticklabels=yticklabel(scene))</code></pre><p>Set the tick labels and range along all the y-axis. See also <code>ticks!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="zlabel!"><a href="#zlabel!">zlabel!</a></div><div class="doc-content"><pre><code>zlabel!([scene,] zlabel)</code></pre><p>Set the z-axis label for the given Scene. Defaults to using the current Scene.</p><div class="admonition warning"><p class="admonition-title">Warning</p><p>The Scene must have an Axis3D.  If not, then this function will error.</p></div></div></div><div class="docstring"><div class="doc-header" id="zlims!"><a href="#zlims!">zlims!</a></div><div class="doc-content"><pre><code>zlims!(ax, low, high)
zlims!(ax; low = nothing, high = nothing)
zlims!(ax, (low, high))
zlims!(ax, low..high)</code></pre><p>Set the z-axis limits of axis <code>ax</code> to <code>low</code> and <code>high</code> or a tuple <code>zlims = (low,high)</code>. If the limits are ordered high-low, the axis orientation will be reversed. If a limit is <code>nothing</code> it will be determined automatically from the plots in the axis.</p><pre><code>zlims!(low, high)
zlims!(; low = nothing, high = nothing)</code></pre><p>Set the z-axis limits of the current axis to <code>low</code> and <code>high</code>. If the limits are ordered high-low, this reverses the axis orientation. A limit set to <code>nothing</code> will be determined automatically from the plots in the axis.</p><pre><code>zlims!(ax = current_axis())</code></pre><p>Reset the z-axis limits to be determined automatically from the plots in the axis.</p></div></div><div class="docstring"><div class="doc-header" id="zoom!"><a href="#zoom!">zoom!</a></div><div class="doc-content"><pre><code>zoom!(scene, cam::Camera3D, zoom_step[, cad = false, zoom_shift_lookat = false])</code></pre><p>Zooms the camera in or out based on the multiplier <code>zoom_step</code>. A <code>zoom_step</code> of 1.0 is neutral, larger zooms out and lower zooms in.</p><p>If <code>cad = true</code> zooming will also apply a rotation based on how far the cursor is from the center of the scene. If <code>zoom_shift_lookat = true</code> and <code>projectiontype = Orthographic</code> zooming will keep the data under the cursor at the same screen space position.</p><pre><code>zoom!(scene, point, zoom_step, shift_lookat::Bool)</code></pre><p>Zooms the camera of <code>scene</code> in towards <code>point</code> by a factor of <code>zoom_step</code>. A positive <code>zoom_step</code> zooms in while a negative <code>zoom_step</code> zooms out.</p></div></div><div class="docstring"><div class="doc-header" id="zticklabels"><a href="#zticklabels">zticklabels</a></div><div class="doc-content"><pre><code>zticklabels(scene)</code></pre><p>Returns all the z-axis tick labels. See also <code>ticklabels</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ztickrange"><a href="#ztickrange">ztickrange</a></div><div class="doc-content"><pre><code>ztickrange(scene)</code></pre><p>Returns the tick range along the z-axis. See also <code>tickranges</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ztickrotation"><a href="#ztickrotation">ztickrotation</a></div><div class="doc-content"><pre><code>ztickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the z-axis. See also <code>tickrotations</code></p></div></div><div class="docstring"><div class="doc-header" id="ztickrotation!"><a href="#ztickrotation!">ztickrotation!</a></div><div class="doc-content"><pre><code>ztickrotation!([scene,] zangle)</code></pre><p>Set the rotation of tick labels along the z-axis. See also <code>tickrotations!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="zticks!"><a href="#zticks!">zticks!</a></div><div class="doc-content"><pre><code>zticks!([scene,]; ztickranges=ztickrange(scene), zticklabels=zticklabel(scene))</code></pre><p>Set the tick labels and range along all z-axis. See also <code>ticks!</code>.</p></div></div><div class="page-foot"><div class="copyright">
    Â© Makie.jl. Last modified: May 07, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
      <p>These docs were autogenerated using Makie: v0.20.10, GLMakie: v0.9.11, CairoMakie: v0.11.12, WGLMakie: v0.9.10</p></div></div></div></div><div class="page__footer"><footer><div class="page__footer-follow"><ul class="social-icons"><li><a href="https://twitter.com/MakiePlots" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-twitter-square"></i> Twitter</a></li><li><a href="https://github.com/JuliaPlots/Makie.jl" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-github"></i> GitHub</a></li></ul></div><div class="page__footer-copyright">Â© Makie.jl. Powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div></footer></div></div><script src="../../versions.js" type="text/javascript"></script><script src="../siteinfo.js" type="text/javascript"></script><script src="../libs/warner.js" type="text/javascript"></script><script src="../libs/navbar.js"></script><link href="../pagefind/pagefind-ui.css" rel="stylesheet"/><script src="../pagefind/pagefind-ui.js" type="text/javascript"></script><script>
        window.addEventListener('DOMContentLoaded', (event) => {
            new PagefindUI({
              element: "#makiesearch",
              showImages: false
            });
            new PagefindUI({
              element: "#makiesearch-overlay",
              showImages: false
            });
        });
    </script><script async="" defer="" src="https://api.makie.org/latest.js"></script><noscript><img alt="" referrerpolicy="no-referrer-when-downgrade" src="https://api.makie.org/noscript.gif"/></noscript></body></HTML>