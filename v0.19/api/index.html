<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link href="../css/franklin.css" rel="stylesheet"/><link href="../css/minimal-mistakes.css" rel="stylesheet"/><link href="../css/makie.css" rel="stylesheet"/><link href="../assets/icon_transparent.png" rel="icon"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://files.stork-search.net/releases/v1.4.2/basic.css" rel="stylesheet"/><style>
    .stork-wrapper {
      width:99%
    }
    .stork-wrapper .stork-results {
      max-height: 42vh;
    }
</style><title>API Â· Makie</title></head><body class="layout--single"><div class="site-container"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav class="greedy-nav" id="site-nav"><a class="title-icon" href=".."><img src="../assets/makie_logo_transparent.svg"/></a><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/JuliaPlots/Makie.jl"><img class="masthead-icon" src="../assets/GitHub-Mark-64px.png"/></a></li><li class="masthead__menu-item"><a href="../reference/">Reference</a></li><li class="masthead__menu-item"><a href="../tutorials/">Tutorials</a></li><li class="masthead__menu-item"><a href="../how-to/">How-Tos</a></li><li class="masthead__menu-item"><a href="../explanations/">Explanations</a></li><li class="masthead__menu-item"><a href="">API</a></li><li class="masthead__menu-item"><a href="../news/">News</a></li><li class="masthead__menu-item" id="masthead-search-button"><script>
                            function toggleSearchOverlay(){
                                const overlay = document.querySelector("#makiesearch-overlay-container");
                                overlay.classList.toggle("hidden");
                                overlay.querySelector("input").focus();
                                overlay.onclick = function(e){
                                    if (e.target !== this){
                                        return
                                    }
                                    this.classList.toggle("hidden");
                                };
                            }
                        </script><button onclick="toggleSearchOverlay()"><i class="fas fa-search"></i> Search</button></li></ul><button class="greedy-nav__toggle" type="button"><span class="visually-hidden">Toggle menu</span><div class="navicon"></div></button><ul class="hidden-links hidden"></ul></nav></div></div></div><div id="main" role="main"><div id="overlay"></div><div class="hidden" id="makiesearch-overlay-container"><div id="makiesearch-overlay-container-inner"><div id="makiesearch-overlay"></div></div></div><div class="content-table-hidden" id="content-table-container"><button id="on-this-page" onclick="toggle_content_table_visibility()">On this page</button><script>
            function toggle_content_table_visibility(){
              const c = document.querySelector("#content-table-container");
              const ct = c.querySelector("#content-table");
              const vh = window.visualViewport.height;
              ct.style.height = `${Math.min(ct.scrollHeight, 0.66*vh)}px`;
              c.classList.toggle("content-table-hidden");
            }
          </script><div id="content-table"></div></div><div id="navbar-container"><div id="navbar"><div id="makiesearch"></div><ul><li><div class="tocitem-container"><a href="..">Home</a></div></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-2"><i class="docs-chevron"></i></label><a href="../reference">Reference</a></div><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-2-1"><i class="docs-chevron"></i></label><a href="../reference/blocks">Blocks</a></div><ul><li><div class="tocitem-container"><a href="../reference/blocks/axis">Axis</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/axis3">Axis3</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/box">Box</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/button">Button</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/colorbar">Colorbar</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/gridlayout">GridLayout</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/intervalslider">IntervalSlider</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/label">Label</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/legend">Legend</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/lscene">LScene</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/menu">Menu</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/polaraxis">PolarAxis</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/slider">Slider</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/slidergrid">SliderGrid</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/textbox">Textbox</a></div></li><li><div class="tocitem-container"><a href="../reference/blocks/toggle">Toggle</a></div></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-2-2"><i class="docs-chevron"></i></label><a href="../reference/plots">Plots</a></div><ul><li><div class="tocitem-container"><a href="../reference/plots/ablines">ablines</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/arc">arc</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/arrows">arrows</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/band">band</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/barplot">barplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/boxplot">boxplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/bracket">bracket</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/contour">contour</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/contour3d">contour3d</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/contourf">contourf</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/crossbar">crossbar</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/datashader">datashader</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/density">density</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/ecdf">ecdfplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/errorbars">errorbars</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/heatmap">heatmap</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/hexbin">hexbin</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/hist">hist</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/hvlines">hlines and vlines</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/hvspan">hspan and vspan</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/image">image</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/lines">lines</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/linesegments">linesegments</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/mesh">mesh</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/meshscatter">meshscatter</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/pie">pie</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/poly">poly</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/qqplot">qqplot and qqnorm</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/rainclouds">rainclouds</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/rangebars">rangebars</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/scatter">scatter</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/scatterlines">scatterlines</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/series">series</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/spy">spy</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/stairs">stairs</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/stem">stem</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/stephist">stephist</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/streamplot">streamplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/surface">surface</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/text">text</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/tooltip">tooltip</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/tricontourf">tricontourf</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/triplot">triplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/violin">violin</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/volume">volume</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/volumeslices">volumeslices</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/voronoiplot">voronoiplot</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/waterfall">waterfall</a></div></li><li><div class="tocitem-container"><a href="../reference/plots/wireframe">wireframe</a></div></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-3"><i class="docs-chevron"></i></label><a href="../tutorials">Tutorials</a></div><ul><li><div class="tocitem-container"><a href="../tutorials/aspect-tutorial">Aspect ratio and size control tutorial</a></div></li><li><div class="tocitem-container"><a href="../tutorials/basic-tutorial">Basic Tutorial</a></div></li><li><div class="tocitem-container"><a href="../tutorials/layout-tutorial">Layout Tutorial</a></div></li><li><div class="tocitem-container"><a href="../tutorials/scenes">Scene tutorial</a></div></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-4"><i class="docs-chevron"></i></label><a href="../how-to">How-Tos</a></div><ul><li><div class="tocitem-container"><a href="../how-to/save-figure-with-transparency">How to save a <code>Figure</code> with transparency</a></div></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-5"><i class="docs-chevron"></i></label><a href="../explanations">Explanations</a></div><ul><li><div class="tocitem-container"><a href="../explanations/animation">Animations</a></div></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-5-2"><i class="docs-chevron"></i></label><a href="../explanations/backends">Backends</a></div><ul><li><div class="tocitem-container"><a href="../explanations/backends/cairomakie">CairoMakie</a></div></li><li><div class="tocitem-container"><a href="../explanations/backends/glmakie">GLMakie</a></div></li><li><div class="tocitem-container"><a href="../explanations/backends/rprmakie">RPRMakie</a></div></li><li><div class="tocitem-container"><a href="../explanations/backends/wglmakie">WGLMakie</a></div></li></ul></li><li><div class="tocitem-container"><a href="../explanations/blocks">Blocks</a></div></li><li><div class="tocitem-container"><a href="../explanations/cameras">Cameras</a></div></li><li><div class="tocitem-container"><a href="../explanations/colors">Colors</a></div></li><li><div class="tocitem-container"><a href="../explanations/events">Events</a></div></li><li><div class="tocitem-container"><a href="../explanations/faq">Frequently Asked Questions</a></div></li><li><div class="tocitem-container"><a href="../explanations/figure">Figures</a></div></li><li><div class="tocitem-container"><a href="../explanations/figure_size">Exporting a Figure with physical dimensions</a></div></li><li><div class="tocitem-container"><a href="../explanations/fonts">Fonts</a></div></li><li><div class="tocitem-container"><a href="../explanations/headless">Headless</a></div></li><li><div class="tocitem-container"><a href="../explanations/inspector">Inspecting Data</a></div></li><li><div class="tocitem-container"><a href="../explanations/latex">LaTeX</a></div></li><li><div class="tocitem-container"><a href="../explanations/layouting">How layouts work</a></div></li><li><div class="tocitem-container"><a href="../explanations/lighting">Lighting</a></div></li><li><div class="tocitem-container"><a href="../explanations/nodes">Observables &amp; Interaction</a></div></li><li><div class="tocitem-container"><a href="../explanations/plot_method_signatures">Plot Method Signatures</a></div></li><li><div class="tocitem-container"><a href="../explanations/recipes">Plot Recipes</a></div></li><li><div class="tocitem-container"><a href="../explanations/scenes">Scenes</a></div></li><li><input class="collapse-toggle" id="menuitem-5-20" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-5-20"><i class="docs-chevron"></i></label><a href="../explanations/theming">Theming</a></div><ul><li><div class="tocitem-container"><a href="../explanations/theming/predefined_themes">Predefined themes</a></div></li></ul></li><li><div class="tocitem-container"><a href="../explanations/transparency">Basic transparency</a></div></li></ul></li><li><div class="tocitem-container"><a class="active" href="">API</a></div></li><li><div class="tocitem-container"><a href="../news">News</a></div></li></ul></div></div><div class="franklin-content"><h1 id="api"><a class="header-anchor" href="#api">API</a></h1><div class="docstring"><div class="doc-header" id=".."><a href="#..">..</a></div><div class="doc-content"><pre><code>iv = l..r</code></pre><p>Construct a ClosedInterval <code>iv</code> spanning the region from <code>l</code> to <code>r</code>.</p></div></div><div class="docstring"><div class="doc-header" id="@L_str"><a href="#@L_str">@L_str</a></div><div class="doc-content"><pre><code>L"..."</code></pre><p>Creates a <code>LaTeXString</code> and is equivalent to <code>latexstring(raw"...")</code>, except that <code>%$</code> can be used for interpolation.</p><pre><code class="language-jldoctest">julia&gt; L"x = \sqrt{2}"
L"$x = \sqrt{2}$"

julia&gt; L"x = %$(sqrt(2))"
L"$x = 1.4142135623730951$"</code></pre></div></div><div class="docstring"><div class="doc-header" id="@colorant_str"><a href="#@colorant_str">@colorant_str</a></div><div class="doc-content"><pre><code>@colorant_str(ex)</code></pre><p>Parse a literal color name as a Colorant. See <a href="@ref"><code>Base.parse(Colorant, desc)</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="@extract"><a href="#@extract">@extract</a></div><div class="doc-content"><p>usage @extract scene (a, b, c, d)</p></div></div><div class="docstring"><div class="doc-header" id="@extractvalue"><a href="#@extractvalue">@extractvalue</a></div><div class="doc-content"><p>usage @extractvalue scene (a, b, c, d) will become:</p><pre><code class="language-julia">begin
    a = to_value(scene[:a])
    b = to_value(scene[:b])
    c = to_value(scene[:c])
    (a, b, c)
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="@get_attribute"><a href="#@get_attribute">@get_attribute</a></div><div class="doc-content"><pre><code>@get_attribute scene (a, b, c, d)</code></pre><p>This will extract attribute <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> from <code>scene</code> and apply the correct attribute conversions + will extract the value if it's a signal. It will make those attributes available as variables and return them as a tuple. So the above is equal to: will become:</p><pre><code class="language-julia">begin
    a = get_attribute(scene, :a)
    b = get_attribute(scene, :b)
    c = get_attribute(scene, :c)
    (a, b, c)
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="@key_str"><a href="#@key_str">@key_str</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.@key_str</code> is a macro.</p><pre><code># 1 method for macro "@key_str" from MakieCore:
 [1] var"@key_str"(__source__::LineNumberNode, __module__::Module, arg)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/types.jl:76</code></pre></div></div><div class="docstring"><div class="doc-header" id="@lift"><a href="#@lift">@lift</a></div><div class="doc-content"><p>Replaces an expression with <code>lift(argtuple -&gt; expression, args...)</code>, where <code>args</code> are all expressions inside the main one that begin with $.</p><h1>Example:</h1><pre><code class="language-julia">x = Observable(rand(100))
y = Observable(rand(100))</code></pre><h2>before</h2><pre><code class="language-julia">z = lift((x, y) -&gt; x .+ y, x, y)</code></pre><h2>after</h2><pre><code class="language-julia">z = @lift($x .+ $y)</code></pre><p>You can also use parentheses around an expression if that expression evaluates to an observable.</p><pre><code class="language-julia">nt = (x = Observable(1), y = Observable(2))
@lift($(nt.x) + $(nt.y))</code></pre></div></div><div class="docstring"><div class="doc-header" id="@recipe"><a href="#@recipe">@recipe</a></div><div class="doc-content"><h1>Plot Recipes in <code>Makie</code></h1><p>There's two types of recipes. <em>Type recipes</em> define a simple mapping from a user defined type to an existing plot type. <em>Full recipes</em> can customize the theme and define a custom plotting function.</p><h2>Type recipes</h2><p>Type recipe are really simple and just overload the argument conversion pipeline. This can be done for all plot types or for a subset of plot types:</p><pre><code># All plot types
convert_arguments(P::Type{&lt;:AbstractPlot}, x::MyType) = convert_arguments(P, rand(10, 10))
# Only for scatter plots
convert_arguments(P::Type{&lt;:Scatter}, x::MyType) = convert_arguments(P, rand(10, 10))</code></pre><p>Optionally you may define the default plot type so that <code>plot(x::MyType)</code> will use this:</p><pre><code>plottype(::MyType) = Surface</code></pre><h2>Full recipes with the <code>@recipe</code> macro</h2><p>A full recipe for <code>MyPlot</code> comes in two parts. First is the plot type name, arguments and theme definition which are defined using the <code>@recipe</code> macro. Second is a custom <code>plot!</code> for <code>MyPlot</code>, implemented in terms of the atomic plotting functions.</p><p>We use an example to show how this works:</p><pre><code># arguments (x, y, z) &amp;&amp; theme are optional
@recipe(MyPlot, x, y, z) do scene
    Attributes(
        plot_color = :red
    )
end</code></pre><p>This macro expands to several things. Firstly a type definition:</p><pre><code>const MyPlot{ArgTypes} = Combined{myplot, ArgTypes}</code></pre><p>The type parameter of <code>Combined</code> contains the function instead of e.g. a symbol. This way the mapping from <code>MyPlot</code> to <code>myplot</code> is safer and simpler. (The downside is we always need a function <code>myplot</code> - TODO: is this a problem?)</p><p>The following signatures are defined to make <code>MyPlot</code> nice to use:</p><pre><code>myplot(args...; kw_args...) = ...
myplot!(scene, args...; kw_args...) = ...
myplot(kw_args::Dict, args...) = ...
myplot!(scene, kw_args::Dict, args...) = ...
#etc (not 100% settled what signatures there will be)</code></pre><p>A specialization of <code>argument_names</code> is emitted if you have an argument list <code>(x,y,z)</code> provided to the recipe macro:</p><pre><code>argument_names(::Type{&lt;: MyPlot}) = (:x, :y, :z)</code></pre><p>This is optional but it will allow the use of <code>plot_object[:x]</code> to fetch the first argument from the call <code>plot_object = myplot(rand(10), rand(10), rand(10))</code>, for example. Alternatively you can always fetch the <code>i</code>th argument using <code>plot_object[i]</code>, and if you leave out the <code>(x,y,z)</code>, the default version of <code>argument_names</code> will provide <code>plot_object[:arg1]</code> etc.</p><p>The theme given in the body of the <code>@recipe</code> invocation is inserted into a specialization of <code>default_theme</code> which inserts the theme into any scene that plots <code>MyPlot</code>:</p><pre><code>function default_theme(scene, ::MyPlot)
    Attributes(
        plot_color = :red
    )
end</code></pre><p>As the second part of defining <code>MyPlot</code>, you should implement the actual plotting of the <code>MyPlot</code> object by specializing <code>plot!</code>:</p><pre><code>function plot!(plot::MyPlot)
    # normal plotting code, building on any previously defined recipes
    # or atomic plotting operations, and adding to the combined `plot`:
    lines!(plot, rand(10), color = plot[:plot_color])
    plot!(plot, plot[:x], plot[:y])
    plot
end</code></pre><p>It's possible to add specializations here, depending on the argument <em>types</em> supplied to <code>myplot</code>. For example, to specialize the behavior of <code>myplot(a)</code> when <code>a</code> is a 3D array of floating point numbers:</p><pre><code>const MyVolume = MyPlot{Tuple{&lt;:AbstractArray{&lt;: AbstractFloat, 3}}}
argument_names(::Type{&lt;: MyVolume}) = (:volume,) # again, optional
function plot!(plot::MyVolume)
    # plot a volume with a colormap going from fully transparent to plot_color
    volume!(plot, plot[:volume], colormap = :transparent =&gt; plot[:plot_color])
    plot
end</code></pre><p>The docstring given to the recipe will be transferred to the functions it generates.</p></div></div><div class="docstring"><div class="doc-header" id="ABLines"><a href="#ABLines">ABLines</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Absolute"><a href="#Absolute">Absolute</a></div><div class="doc-content"><pre><code>Absolute</code></pre><p>Force transformation to be absolute, not relative to the current state. This is the default setting.</p></div></div><div class="docstring"><div class="doc-header" id="Absorption"><a href="#Absorption">Absorption</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbsorptionRGBA"><a href="#AbsorptionRGBA">AbsorptionRGBA</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbstractCamera"><a href="#AbstractCamera">AbstractCamera</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type AbstractCamera</code></pre><h1>Subtypes</h1><pre><code>Camera2D
Camera3D
EmptyCamera
Makie.OldCamera3D
Makie.OrthographicCamera
Makie.PixelCamera
Makie.RelativeCamera</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbstractPlot"><a href="#AbstractPlot">AbstractPlot</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type AbstractPlot{Typ}</code></pre><h1>Subtypes</h1><pre><code>Makie.FakePlot
MakieCore.ScenePlot{Typ}</code></pre><h1>Supertype Hierarchy</h1><pre><code>AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbstractScene"><a href="#AbstractScene">AbstractScene</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type AbstractScene</code></pre><h1>Subtypes</h1><pre><code>Scene</code></pre><h1>Supertype Hierarchy</h1><pre><code>AbstractScene &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Accum"><a href="#Accum">Accum</a></div><div class="doc-content"><pre><code>Accum</code></pre><p>Force transformation to be relative to the current state, not absolute.</p></div></div><div class="docstring"><div class="doc-header" id="AmbientLight"><a href="#AmbientLight">AmbientLight</a></div><div class="doc-content"><p>A simple, one color ambient light.</p></div></div><div class="docstring"><div class="doc-header" id="Annotations"><a href="#Annotations">Annotations</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Arc"><a href="#Arc">Arc</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Arrows"><a href="#Arrows">Arrows</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Aspect"><a href="#Aspect">Aspect</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Aspect</code></pre><h1>Fields</h1><pre><code>index :: Int64
ratio :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="Atomic"><a href="#Atomic">Atomic</a></div><div class="doc-content"><pre><code>Union{Types...}</code></pre><p>A type union is an abstract type which includes all instances of any of its argument types. The empty union <a href="@ref"><code>Union{}</code></a> is the bottom type of Julia.</p><h1>Examples</h1><pre><code class="language-jldoctest">julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 isa IntOrString
true

julia&gt; "Hello!" isa IntOrString
true

julia&gt; 1.0 isa IntOrString
false</code></pre></div></div><div class="docstring"><div class="doc-header" id="Attributes"><a href="#Attributes">Attributes</a></div><div class="doc-content"><p>Main structure for holding attributes, for theming plots etc! Will turn all values into observables, so that they can be updated.</p></div></div><div class="docstring"><div class="doc-header" id="Auto"><a href="#Auto">Auto</a></div><div class="doc-content"><pre><code>struct Auto</code></pre><p>If used as a <code>GridLayout</code>'s row / column size and <code>trydetermine == true</code>, signals to the <code>GridLayout</code> that the row / column should shrink to match the largest determinable element inside. If no size of a content element can be determined, the remaining space is split between all <code>Auto</code> rows / columns according to their <code>ratio</code>.</p><p>If used as width / height of a layoutable element and <code>trydetermine == true</code>, the element's computed width / height will report the auto width / height if it can be determined. This enables a parent <code>GridLayout</code> to adjust its column / rowsize to the element's width / height. If <code>trydetermine == false</code>, the element's computed width / height will report <code>nothing</code> even if an auto width / height can be determined, which will prohibit a parent <code>GridLayout</code> from adjusting a row / column to the element's width / height. This is useful to, e.g., prohibit a <code>GridLayout</code> from shrinking a column's width to the width of a super title, even though the title's width can be auto-determined.</p><p>The <code>ratio</code> is ignored if <code>Auto</code> is used as an element size.</p></div></div><div class="docstring"><div class="doc-header" id="Axis"><a href="#Axis">Axis</a></div><div class="doc-content"><p><strong><code>Axis &lt;: Block</code></strong></p><p>A 2D axis which can be plotted into.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">Axis(fig_or_scene; palette = nothing, kwargs...)</code></pre><p><strong>Attributes</strong></p><p>(type <code>?Axis.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>aspect</code>, <code>autolimitaspect</code>, <code>backgroundcolor</code>, <code>bottomspinecolor</code>, <code>bottomspinevisible</code>, <code>flip_ylabel</code>, <code>halign</code>, <code>height</code>, <code>leftspinecolor</code>, <code>leftspinevisible</code>, <code>limits</code>, <code>panbutton</code>, <code>rightspinecolor</code>, <code>rightspinevisible</code>, <code>spinewidth</code>, <code>subtitle</code>, <code>subtitlecolor</code>, <code>subtitlefont</code>, <code>subtitlegap</code>, <code>subtitlelineheight</code>, <code>subtitlesize</code>, <code>subtitlevisible</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>title</code>, <code>titlealign</code>, <code>titlecolor</code>, <code>titlefont</code>, <code>titlegap</code>, <code>titlelineheight</code>, <code>titlesize</code>, <code>titlevisible</code>, <code>topspinecolor</code>, <code>topspinevisible</code>, <code>valign</code>, <code>width</code>, <code>xautolimitmargin</code>, <code>xaxisposition</code>, <code>xgridcolor</code>, <code>xgridstyle</code>, <code>xgridvisible</code>, <code>xgridwidth</code>, <code>xlabel</code>, <code>xlabelcolor</code>, <code>xlabelfont</code>, <code>xlabelpadding</code>, <code>xlabelrotation</code>, <code>xlabelsize</code>, <code>xlabelvisible</code>, <code>xminorgridcolor</code>, <code>xminorgridstyle</code>, <code>xminorgridvisible</code>, <code>xminorgridwidth</code>, <code>xminortickalign</code>, <code>xminortickcolor</code>, <code>xminorticks</code>, <code>xminorticksize</code>, <code>xminorticksvisible</code>, <code>xminortickwidth</code>, <code>xpankey</code>, <code>xpanlock</code>, <code>xrectzoom</code>, <code>xreversed</code>, <code>xscale</code>, <code>xtickalign</code>, <code>xtickcolor</code>, <code>xtickformat</code>, <code>xticklabelalign</code>, <code>xticklabelcolor</code>, <code>xticklabelfont</code>, <code>xticklabelpad</code>, <code>xticklabelrotation</code>, <code>xticklabelsize</code>, <code>xticklabelspace</code>, <code>xticklabelsvisible</code>, <code>xticks</code>, <code>xticksize</code>, <code>xticksmirrored</code>, <code>xticksvisible</code>, <code>xtickwidth</code>, <code>xtrimspine</code>, <code>xzoomkey</code>, <code>xzoomlock</code>, <code>yautolimitmargin</code>, <code>yaxisposition</code>, <code>ygridcolor</code>, <code>ygridstyle</code>, <code>ygridvisible</code>, <code>ygridwidth</code>, <code>ylabel</code>, <code>ylabelcolor</code>, <code>ylabelfont</code>, <code>ylabelpadding</code>, <code>ylabelrotation</code>, <code>ylabelsize</code>, <code>ylabelvisible</code>, <code>yminorgridcolor</code>, <code>yminorgridstyle</code>, <code>yminorgridvisible</code>, <code>yminorgridwidth</code>, <code>yminortickalign</code>, <code>yminortickcolor</code>, <code>yminorticks</code>, <code>yminorticksize</code>, <code>yminorticksvisible</code>, <code>yminortickwidth</code>, <code>ypankey</code>, <code>ypanlock</code>, <code>yrectzoom</code>, <code>yreversed</code>, <code>yscale</code>, <code>ytickalign</code>, <code>ytickcolor</code>, <code>ytickformat</code>, <code>yticklabelalign</code>, <code>yticklabelcolor</code>, <code>yticklabelfont</code>, <code>yticklabelpad</code>, <code>yticklabelrotation</code>, <code>yticklabelsize</code>, <code>yticklabelspace</code>, <code>yticklabelsvisible</code>, <code>yticks</code>, <code>yticksize</code>, <code>yticksmirrored</code>, <code>yticksvisible</code>, <code>ytickwidth</code>, <code>ytrimspine</code>, <code>yzoomkey</code>, <code>yzoomlock</code></p></div></div><div class="docstring"><div class="doc-header" id="Axis3"><a href="#Axis3">Axis3</a></div><div class="doc-content"><p><strong><code>Axis3 &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Axis3.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>aspect</code>, <code>azimuth</code>, <code>backgroundcolor</code>, <code>elevation</code>, <code>halign</code>, <code>height</code>, <code>limits</code>, <code>perspectiveness</code>, <code>protrusions</code>, <code>targetlimits</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>title</code>, <code>titlealign</code>, <code>titlecolor</code>, <code>titlefont</code>, <code>titlegap</code>, <code>titlesize</code>, <code>titlevisible</code>, <code>valign</code>, <code>viewmode</code>, <code>width</code>, <code>xautolimitmargin</code>, <code>xgridcolor</code>, <code>xgridvisible</code>, <code>xgridwidth</code>, <code>xlabel</code>, <code>xlabelalign</code>, <code>xlabelcolor</code>, <code>xlabelfont</code>, <code>xlabeloffset</code>, <code>xlabelrotation</code>, <code>xlabelsize</code>, <code>xlabelvisible</code>, <code>xreversed</code>, <code>xspinecolor_1</code>, <code>xspinecolor_2</code>, <code>xspinecolor_3</code>, <code>xspinesvisible</code>, <code>xspinewidth</code>, <code>xtickcolor</code>, <code>xtickformat</code>, <code>xticklabelcolor</code>, <code>xticklabelfont</code>, <code>xticklabelpad</code>, <code>xticklabelsize</code>, <code>xticklabelsvisible</code>, <code>xticks</code>, <code>xticksize</code>, <code>xticksvisible</code>, <code>xtickwidth</code>, <code>xypanelcolor</code>, <code>xypanelvisible</code>, <code>xzpanelcolor</code>, <code>xzpanelvisible</code>, <code>yautolimitmargin</code>, <code>ygridcolor</code>, <code>ygridvisible</code>, <code>ygridwidth</code>, <code>ylabel</code>, <code>ylabelalign</code>, <code>ylabelcolor</code>, <code>ylabelfont</code>, <code>ylabeloffset</code>, <code>ylabelrotation</code>, <code>ylabelsize</code>, <code>ylabelvisible</code>, <code>yreversed</code>, <code>yspinecolor_1</code>, <code>yspinecolor_2</code>, <code>yspinecolor_3</code>, <code>yspinesvisible</code>, <code>yspinewidth</code>, <code>ytickcolor</code>, <code>ytickformat</code>, <code>yticklabelcolor</code>, <code>yticklabelfont</code>, <code>yticklabelpad</code>, <code>yticklabelsize</code>, <code>yticklabelsvisible</code>, <code>yticks</code>, <code>yticksize</code>, <code>yticksvisible</code>, <code>ytickwidth</code>, <code>yzpanelcolor</code>, <code>yzpanelvisible</code>, <code>zautolimitmargin</code>, <code>zgridcolor</code>, <code>zgridvisible</code>, <code>zgridwidth</code>, <code>zlabel</code>, <code>zlabelalign</code>, <code>zlabelcolor</code>, <code>zlabelfont</code>, <code>zlabeloffset</code>, <code>zlabelrotation</code>, <code>zlabelsize</code>, <code>zlabelvisible</code>, <code>zreversed</code>, <code>zspinecolor_1</code>, <code>zspinecolor_2</code>, <code>zspinecolor_3</code>, <code>zspinesvisible</code>, <code>zspinewidth</code>, <code>ztickcolor</code>, <code>ztickformat</code>, <code>zticklabelcolor</code>, <code>zticklabelfont</code>, <code>zticklabelpad</code>, <code>zticklabelsize</code>, <code>zticklabelsvisible</code>, <code>zticks</code>, <code>zticksize</code>, <code>zticksvisible</code>, <code>ztickwidth</code></p></div></div><div class="docstring"><div class="doc-header" id="Axis3D"><a href="#Axis3D">Axis3D</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AxisAspect"><a href="#AxisAspect">AxisAspect</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct AxisAspect</code></pre><h1>Fields</h1><pre><code>aspect :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="BBox"><a href="#BBox">BBox</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.BBox</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "BBox" from GridLayoutBase:
 [1] BBox(left::Number, right::Number, bottom::Number, top::Number)
     @ ~/.julia/packages/GridLayoutBase/kiave/src/helpers.jl:116</code></pre></div></div><div class="docstring"><div class="doc-header" id="Band"><a href="#Band">Band</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="BarPlot"><a href="#BarPlot">BarPlot</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="BezierPath"><a href="#BezierPath">BezierPath</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct BezierPath</code></pre><h1>Fields</h1><pre><code>commands :: Vector{Union{ClosePath, CurveTo, EllipticalArc, LineTo, MoveTo}}</code></pre></div></div><div class="docstring"><div class="doc-header" id="Billboard"><a href="#Billboard">Billboard</a></div><div class="doc-content"><pre><code>Billboard([angle::Real])
Billboard([angles::Vector{&lt;: Real}])</code></pre><p>Billboard attribute to always have a primitive face the camera. Can be used for rotation.</p></div></div><div class="docstring"><div class="doc-header" id="Bottom"><a href="#Bottom">Bottom</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Bottom</code></pre><h1>Supertype Hierarchy</h1><pre><code>Bottom &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="BottomLeft"><a href="#BottomLeft">BottomLeft</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct BottomLeft</code></pre><h1>Supertype Hierarchy</h1><pre><code>BottomLeft &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="BottomRight"><a href="#BottomRight">BottomRight</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct BottomRight</code></pre><h1>Supertype Hierarchy</h1><pre><code>BottomRight &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Box"><a href="#Box">Box</a></div><div class="doc-content"><p><strong><code>Box &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Box.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>color</code>, <code>cornerradius</code>, <code>halign</code>, <code>height</code>, <code>strokecolor</code>, <code>strokevisible</code>, <code>strokewidth</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>visible</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="BoxPlot"><a href="#BoxPlot">BoxPlot</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Bracket"><a href="#Bracket">Bracket</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Button"><a href="#Button">Button</a></div><div class="doc-content"><p><strong><code>Button &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Button.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>buttoncolor</code>, <code>buttoncolor_active</code>, <code>buttoncolor_hover</code>, <code>clicks</code>, <code>cornerradius</code>, <code>cornersegments</code>, <code>font</code>, <code>fontsize</code>, <code>halign</code>, <code>height</code>, <code>label</code>, <code>labelcolor</code>, <code>labelcolor_active</code>, <code>labelcolor_hover</code>, <code>padding</code>, <code>strokecolor</code>, <code>strokewidth</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Camera"><a href="#Camera">Camera</a></div><div class="doc-content"><pre><code>Camera(pixel_area)</code></pre><p>Struct to hold all relevant matrices and additional parameters, to let backends apply camera based transformations.</p><h2>Fields</h2><ul><li><p><code>pixel_space::Observable{StaticArraysCore.SMatrix{4, 4, Float32, 16}}</code>: projection used to convert pixel to device units</p></li></ul><ul><li><p><code>view::Observable{StaticArraysCore.SMatrix{4, 4, Float32, 16}}</code>: View matrix is usually used to rotate, scale and translate the scene</p></li></ul><ul><li><p><code>projection::Observable{StaticArraysCore.SMatrix{4, 4, Float32, 16}}</code>: Projection matrix is used for any perspective transformation</p></li></ul><ul><li><p><code>projectionview::Observable{StaticArraysCore.SMatrix{4, 4, Float32, 16}}</code>: just projection * view</p></li></ul><ul><li><p><code>resolution::Observable{Vec{2, Float32}}</code>: resolution of the canvas this camera draws to</p></li></ul><ul><li><p><code>eyeposition::Observable{Vec{3, Float32}}</code>: Eye position of the camera, sued for e.g. ray tracing.</p></li></ul><ul><li><p><code>steering_nodes::Vector{Observables.ObserverFunction}</code>: To make camera interactive, steering observables are connected to the different matrices. We need to keep track of them, so, that we can connect and disconnect them.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Camera2D"><a href="#Camera2D">Camera2D</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Camera2D</code></pre><h1>Fields</h1><pre><code>area          :: Observable{GeometryBasics.HyperRectangle{2, Float32}}
zoomspeed     :: Observable{Float32}
zoombutton    :: Observable{Union{Nothing, Makie.Keyboard.Button, Makie.Mouse.Button}}
panbutton     :: Observable{Union{Nothing, Makie.Keyboard.Button, Makie.Mouse.Button, Vector{Union{Nothing, Makie.Keyboard.Button, Makie.Mouse.Button}}}}
padding       :: Observable{Float32}
last_area     :: Observable{Vec2{Int64}}
update_limits :: Observable{Bool}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Camera2D &lt;: AbstractCamera &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Camera3D"><a href="#Camera3D">Camera3D</a></div><div class="doc-content"><pre><code>Camera3D(scene[; attributes...])</code></pre><p>Creates a 3d camera with a lot of controls.</p><p>The 3D camera is (or can be) unrestricted in terms of rotations and translations. Both <code>cam3d!(scene)</code> and <code>cam3d_cad!(scene)</code> create this camera type. Unlike the 2D camera, settings and controls are stored in the <code>cam.attributes</code> field rather than in the struct directly, but can still be passed as keyword arguments. The general camera settings include</p><ul><li><p><code>fov = 45f0</code> sets the "neutral" field of view, i.e. the fov corresponding to no zoom. This is irrelevant if the camera uses an orthographic projection.</p></li><li><p><code>near = automatic</code> sets the value of the near clip. By default this will be chosen based on the scenes bounding box. The final value is in <code>cam.near</code>.</p></li><li><p><code>far = automatic</code> sets the value of the far clip. By default this will be chosen based on the scenes bounding box. The final value is in <code>cam.far</code>.</p></li><li><p><code>rotation_center = :lookat</code> sets the default center for camera rotations. Currently allows <code>:lookat</code> or <code>:eyeposition</code>.</p></li><li><p><code>projectiontype = Perspective</code> sets the type of the projection. Can be <code>Orthographic</code> or <code>Perspective</code>.</p></li><li><p><code>fixed_axis = false</code>: If true panning uses the (world/plot) z-axis instead of the camera up direction.</p></li><li><p><code>zoom_shift_lookat = true</code>: If true attempts to keep data under the cursor in view when zooming.</p></li><li><p><code>cad = false</code>: If true rotates the view around <code>lookat</code> when zooming off-center.</p></li></ul><p>The camera view follows from the position of the camera <code>eyeposition</code>, the point which the camera focuses <code>lookat</code> and the up direction of the camera <code>upvector</code>. These can be accessed as <code>cam.eyeposition</code> etc and adjusted via <code>update_cam!(scene, cameracontrols(scene), eyeposition, lookat[, upvector = Vec3f(0, 0, 1)])</code>. They can also be passed as keyword arguments when the camera is constructed.</p><p>The camera can be controlled by keyboard and mouse. The keyboard has the following available attributes</p><ul><li><p><code>up_key   = Keyboard.r</code> sets the key for translations towards the top of the screen.</p></li><li><p><code>down_key = Keyboard.f</code> sets the key for translations towards the bottom of the screen.</p></li><li><p><code>left_key  = Keyboard.a</code> sets the key for translations towards the left of the screen.</p></li><li><p><code>right_key = Keyboard.d</code> sets the key for translations towards the right of the screen.</p></li><li><p><code>forward_key  = Keyboard.w</code> sets the key for translations into the screen.</p></li><li><p><code>backward_key = Keyboard.s</code> sets the key for translations out of the screen.</p></li><li><p><code>zoom_in_key   = Keyboard.u</code> sets the key for zooming into the scene (enlarge, via fov).</p></li><li><p><code>zoom_out_key  = Keyboard.o</code> sets the key for zooming out of the scene (shrink, via fov).</p></li><li><p><code>stretch_view_key  = Keyboard.page_up</code> sets the key for moving <code>eyepostion</code> away from <code>lookat</code>.</p></li><li><p><code>contract_view_key = Keyboard.page_down</code> sets the key for moving <code>eyeposition</code> towards <code>lookat</code>.</p></li><li><p><code>pan_left_key  = Keyboard.j</code> sets the key for rotations around the screens vertical axis.</p></li><li><p><code>pan_right_key = Keyboard.l</code> sets the key for rotations around the screens vertical axis.</p></li><li><p><code>tilt_up_key   = Keyboard.i</code> sets the key for rotations around the screens horizontal axis.</p></li><li><p><code>tilt_down_key = Keyboard.k</code> sets the key for rotations around the screens horizontal axis.</p></li><li><p><code>roll_clockwise_key        = Keyboard.e</code> sets the key for rotations of the screen.</p></li><li><p><code>roll_counterclockwise_key = Keyboard.q</code> sets the key for rotations of the screen.</p></li><li><p><code>keyboard_rotationspeed = 1f0</code> sets the speed of keyboard based rotations.</p></li><li><p><code>keyboard_translationspeed = 0.5f0</code> sets the speed of keyboard based translations.</p></li><li><p><code>keyboard_zoomspeed = 1f0</code> sets the speed of keyboard based zooms.</p></li><li><p><code>update_rate = 1/30</code> sets the rate at which keyboard based camera updates are evaluated.</p></li></ul><p>and mouse interactions are controlled by</p><ul><li><p><code>translation_button = Mouse.right</code> sets the mouse button for drag-translations. (up/down/left/right)</p></li><li><p><code>scroll_mod = true</code> sets an additional modifier button for scroll-based zoom. (true being neutral)</p></li><li><p><code>rotation_button = Mouse.left</code> sets the mouse button for drag-rotations. (pan, tilt)</p></li><li><p><code>mouse_rotationspeed = 1f0</code> sets the speed of mouse rotations.</p></li><li><p><code>mouse_translationspeed = 0.5f0</code> sets the speed of mouse translations.</p></li><li><p><code>mouse_zoomspeed = 1f0</code> sets the speed of mouse zooming (mousewheel).</p></li><li><p><code>circular_rotation = (true, true, true)</code> enables circular rotations for (fixed x, fixed y, fixed z) rotation axis. (This means drawing a circle with your mouse around the center of the scene will result in a continuous rotation.)</p></li></ul><p>There are also a few generally applicable controls:</p><ul><li><p><code>fix_x_key = Keyboard.x</code> sets the key for fixing translations and rotations to the (world/plot) x-axis.</p></li><li><p><code>fix_y_key = Keyboard.y</code> sets the key for fixing translations and rotations to the (world/plot) y-axis.</p></li><li><p><code>fix_z_key = Keyboard.z</code> sets the key for fixing translations and rotations to the (world/plot) z-axis.</p></li><li><p><code>reset = Keyboard.home</code> sets the key for fully resetting the camera. This equivalent to setting <code>lookat = Vec3f(0)</code>, <code>upvector = Vec3f(0, 0, 1)</code>, <code>eyeposition = Vec3f(3)</code> and then calling <code>center!(scene)</code>.</p></li></ul><p>You can also make adjustments to the camera position, rotation and zoom by calling relevant functions:</p><ul><li><p><code>translate_cam!(scene, v)</code> will translate the camera by the given world/plot space vector <code>v</code>.</p></li><li><p><code>rotate_cam!(scene, angles)</code> will rotate the camera around its axes with the corresponding angles. The first angle will rotate around the cameras "right" that is the screens horizontal axis, the second around the up vector/vertical axis or <code>Vec3f(0, 0, +-1)</code> if <code>fixed_axis = true</code>, and the third will rotate around the view direction i.e. the axis out of the screen. The rotation respects the current <code>rotation_center</code> of the camera.</p></li><li><p><code>zoom!(scene, zoom_step)</code> will change the zoom level of the scene without translating or rotating the scene. <code>zoom_step</code> applies multiplicatively to <code>cam.zoom_mult</code> which is used as a multiplier to the fov (perspective projection) or width and height (orthographic projection).</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Circle"><a href="#Circle">Circle</a></div><div class="doc-content"><pre><code>HyperSphere{N, T}</code></pre><p>A <code>HyperSphere</code> is a generalization of a sphere into N-dimensions. A <code>center</code> and radius, <code>r</code>, must be specified.</p></div></div><div class="docstring"><div class="doc-header" id="ClosePath"><a href="#ClosePath">ClosePath</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct ClosePath</code></pre></div></div><div class="docstring"><div class="doc-header" id="Colorbar"><a href="#Colorbar">Colorbar</a></div><div class="doc-content"><p><strong><code>Colorbar &lt;: Block</code></strong></p><p>Create a colorbar that shows a continuous or categorical colormap with ticks chosen according to the colorrange.</p><p>You can set colorrange and colormap manually, or pass a plot object as the second argument to copy its respective attributes.</p><h2>Constructors</h2><pre><code class="language-julia">Colorbar(fig_or_scene; kwargs...)
Colorbar(fig_or_scene, plot::AbstractPlot; kwargs...)
Colorbar(fig_or_scene, heatmap::Union{Heatmap, Image}; kwargs...)
Colorbar(fig_or_scene, contourf::Makie.Contourf; kwargs...)</code></pre><p><strong>Attributes</strong></p><p>(type <code>?Colorbar.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>bottomspinecolor</code>, <code>bottomspinevisible</code>, <code>colormap</code>, <code>colorrange</code>, <code>flip_vertical_label</code>, <code>flipaxis</code>, <code>halign</code>, <code>height</code>, <code>highclip</code>, <code>label</code>, <code>labelcolor</code>, <code>labelfont</code>, <code>labelpadding</code>, <code>labelrotation</code>, <code>labelsize</code>, <code>labelvisible</code>, <code>leftspinecolor</code>, <code>leftspinevisible</code>, <code>limits</code>, <code>lowclip</code>, <code>minortickalign</code>, <code>minortickcolor</code>, <code>minorticks</code>, <code>minorticksize</code>, <code>minorticksvisible</code>, <code>minortickwidth</code>, <code>nsteps</code>, <code>rightspinecolor</code>, <code>rightspinevisible</code>, <code>scale</code>, <code>size</code>, <code>spinewidth</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>tickalign</code>, <code>tickcolor</code>, <code>tickformat</code>, <code>ticklabelalign</code>, <code>ticklabelcolor</code>, <code>ticklabelfont</code>, <code>ticklabelpad</code>, <code>ticklabelrotation</code>, <code>ticklabelsize</code>, <code>ticklabelspace</code>, <code>ticklabelsvisible</code>, <code>ticks</code>, <code>ticksize</code>, <code>ticksvisible</code>, <code>tickwidth</code>, <code>topspinecolor</code>, <code>topspinevisible</code>, <code>valign</code>, <code>vertical</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Combined"><a href="#Combined">Combined</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Consume"><a href="#Consume">Consume</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Consume</code></pre><h1>Fields</h1><pre><code>x :: Bool</code></pre></div></div><div class="docstring"><div class="doc-header" id="ContinuousSurface"><a href="#ContinuousSurface">ContinuousSurface</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct ContinuousSurface</code></pre><h1>Supertype Hierarchy</h1><pre><code>ContinuousSurface &lt;: SurfaceLike &lt;: ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Contour"><a href="#Contour">Contour</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Contour3d"><a href="#Contour3d">Contour3d</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Contourf"><a href="#Contourf">Contourf</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="ConversionTrait"><a href="#ConversionTrait">ConversionTrait</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type ConversionTrait</code></pre><h1>Subtypes</h1><pre><code>Makie.SampleBased
NoConversion
PointBased
SurfaceLike
VolumeLike</code></pre></div></div><div class="docstring"><div class="doc-header" id="CrossBar"><a href="#CrossBar">CrossBar</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="CurveTo"><a href="#CurveTo">CurveTo</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct CurveTo</code></pre><h1>Fields</h1><pre><code>c1 :: Point2{Float64}
c2 :: Point2{Float64}
p  :: Point2{Float64}</code></pre></div></div><div class="docstring"><div class="doc-header" id="Cycle"><a href="#Cycle">Cycle</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Cycle</code></pre><h1>Fields</h1><pre><code>cycle  :: Vector{Pair{Vector{Symbol}, Symbol}}
covary :: Bool</code></pre></div></div><div class="docstring"><div class="doc-header" id="Cycled"><a href="#Cycled">Cycled</a></div><div class="doc-content"><pre><code>Cycled(i::Int)</code></pre><p>If a <code>Cycled</code> value is passed as an attribute to a plotting function, it is replaced with the value from the cycler for this attribute (as long as there is one defined) at the index <code>i</code>.</p></div></div><div class="docstring"><div class="doc-header" id="DataAspect"><a href="#DataAspect">DataAspect</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct DataAspect</code></pre></div></div><div class="docstring"><div class="doc-header" id="DataInspector"><a href="#DataInspector">DataInspector</a></div><div class="doc-content"><pre><code>DataInspector(figure_axis_or_scene = current_figure(); kwargs...)</code></pre><p>Creates a data inspector which will show relevant information in a tooltip when you hover over a plot.</p><p>This functionality can be disabled on a per-plot basis by setting <code>plot.inspectable[] = false</code>. The displayed text can be adjusted by setting <code>plot.inspector_label</code> to a function <code>(plot, index, position) -&gt; "my_label"</code> returning a label. See Makie documentation for more detail.</p><h3>Keyword Arguments:</h3><ul><li><p><code>range = 10</code>: Controls the snapping range for selecting an element of a plot.</p></li><li><p><code>priority = 100</code>: The priority of creating a tooltip on a mouse movement or   scrolling event.</p></li><li><p><code>enabled = true</code>: Disables inspection of plots when set to false. Can also be   adjusted with <code>enable!(inspector)</code> and <code>disable!(inspector)</code>.</p></li><li><p><code>indicator_color = :red</code>: Color of the selection indicator.</p></li><li><p><code>indicator_linewidth = 2</code>: Linewidth of the selection indicator.</p></li><li><p><code>indicator_linestyle = nothing</code>: Linestyle of the selection indicator</p></li><li><p><code>enable_indicators = true)</code>: Enables or disables indicators</p></li><li><p><code>depth = 9e3</code>: Depth value of the tooltip. This should be high so that the   tooltip is always in front.</p></li><li><p><code>apply_tooltip_offset = true</code>: Enables or disables offsetting tooltips based    on, for example, markersize.</p></li><li><p>and all attributes from <code>Tooltip</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="DataShader"><a href="#DataShader">DataShader</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Density"><a href="#Density">Density</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="DiscreteSurface"><a href="#DiscreteSurface">DiscreteSurface</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct DiscreteSurface</code></pre><h1>Supertype Hierarchy</h1><pre><code>DiscreteSurface &lt;: SurfaceLike &lt;: ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="ECDFPlot"><a href="#ECDFPlot">ECDFPlot</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="EllipticalArc"><a href="#EllipticalArc">EllipticalArc</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct EllipticalArc</code></pre><h1>Fields</h1><pre><code>c     :: Point2{Float64}
r1    :: Float64
r2    :: Float64
angle :: Float64
a1    :: Float64
a2    :: Float64</code></pre></div></div><div class="docstring"><div class="doc-header" id="EmptyCamera"><a href="#EmptyCamera">EmptyCamera</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct EmptyCamera</code></pre><h1>Supertype Hierarchy</h1><pre><code>EmptyCamera &lt;: AbstractCamera &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="EnvironmentLight"><a href="#EnvironmentLight">EnvironmentLight</a></div><div class="doc-content"><p>An environment Light, that uses a spherical environment map to provide lighting. See: https://en.wikipedia.org/wiki/Reflection_mapping</p></div></div><div class="docstring"><div class="doc-header" id="Errorbars"><a href="#Errorbars">Errorbars</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Events"><a href="#Events">Events</a></div><div class="doc-content"><p>This struct provides accessible <code>Observable</code>s to monitor the events associated with a Scene.</p><p>Functions that act on a <code>Observable</code> must return <code>Consume()</code> if the function consumes an event. When an event is consumed it does not trigger other observer functions. The order in which functions are exectued can be controlled via the <code>priority</code> keyword (default 0) in <code>on</code>.</p><p>Example:</p><pre><code>on(events(scene).mousebutton, priority = 20) do event
    if is_correct_event(event)
        do_something()
        return Consume()
    end
    return
end</code></pre><h2>Fields</h2><ul><li><p><code>window_area::Observable{GeometryBasics.HyperRectangle{2, Int64}}</code>: The area of the window in pixels, as a <code>Rect2</code>.</p></li></ul><ul><li><p><code>window_dpi::Observable{Float64}</code>: The DPI resolution of the window, as a <code>Float64</code>.</p></li></ul><ul><li><p><code>window_open::Observable{Bool}</code>: The state of the window (open =&gt; true, closed =&gt; false).</p></li></ul><ul><li><p><code>mousebutton::Observable{Makie.MouseButtonEvent}</code>: Most recently triggered <code>MouseButtonEvent</code>. Contains the relevant <code>event.button</code> and <code>event.action</code> (press/release)</p><p>See also <a href="@ref"><code>ispressed</code></a>.</p></li></ul><ul><li><p><code>mousebuttonstate::Set{Makie.Mouse.Button}</code>: A Set of all currently pressed mousebuttons.</p></li></ul><ul><li><p><code>mouseposition::Observable{Tuple{Float64, Float64}}</code>: The position of the mouse as a <code>NTuple{2, Float64}</code>. Updates once per event poll/frame.</p></li></ul><ul><li><p><code>scroll::Observable{Tuple{Float64, Float64}}</code>: The direction of scroll</p></li></ul><ul><li><p><code>keyboardbutton::Observable{Makie.KeyEvent}</code>: Most recently triggered <code>KeyEvent</code>. Contains the relevant <code>event.key</code> and <code>event.action</code> (press/repeat/release)</p><p>See also <a href="@ref"><code>ispressed</code></a>.</p></li></ul><ul><li><p><code>keyboardstate::Set{Makie.Keyboard.Button}</code>: Contains all currently pressed keys.</p></li></ul><ul><li><p><code>unicode_input::Observable{Char}</code>: Contains the last typed character.</p></li></ul><ul><li><p><code>dropped_files::Observable{Vector{String}}</code>: Contains a list of filepaths to files dragged into the scene.</p></li></ul><ul><li><p><code>hasfocus::Observable{Bool}</code>: Whether the Scene window is in focus or not.</p></li></ul><ul><li><p><code>entered_window::Observable{Bool}</code>: Whether the mouse is inside the window or not.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Exclusively"><a href="#Exclusively">Exclusively</a></div><div class="doc-content"><pre><code>Exclusively(x)</code></pre><p>Marks a button, button collection or logical expression of buttons as the exclusive subset of buttons that must be pressed for <code>ispressed</code> to return true.</p><p>For example <code>Exclusively((Keyboard.left_control, Keyboard.c))</code> would require left control and c to be pressed without any other buttons.</p><p>Boolean expressions are lowered to multiple <code>Exclusive</code> sets in an <code>Or</code>. It is worth noting that <code>Not</code> branches are ignored here, i.e. it assumed that every button under a <code>Not</code> must not be pressed and that this follows automatically from the subset of buttons that must be pressed.</p><p>See also: <a href="@ref"><code>And</code></a>, <a href="@ref"><code>Or</code></a>, <a href="@ref"><code>Not</code></a>, <a href="@ref"><code>ispressed</code></a>, <a href="@ref"><code>&amp;</code></a>, <a href="@ref"><code>|</code></a>, <a href="@ref"><code>!</code></a></p></div></div><div class="docstring"><div class="doc-header" id="Figure"><a href="#Figure">Figure</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Figure</code></pre><h1>Fields</h1><pre><code>scene        :: Scene
layout       :: GridLayout
content      :: Vector
attributes   :: Attributes
current_axis :: Ref{Any}</code></pre></div></div><div class="docstring"><div class="doc-header" id="Fixed"><a href="#Fixed">Fixed</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Fixed</code></pre><h1>Fields</h1><pre><code>x :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="GridLayout"><a href="#GridLayout">GridLayout</a></div><div class="doc-content"><pre><code>GridLayout(; kwargs...)</code></pre><p>Create a <code>GridLayout</code> without parent and with size [1, 1].</p><pre><code>GridLayout(g::Union{GridPosition, GridSubposition}, args...; kwargs...)</code></pre><p>Create a <code>GridLayout</code> at position <code>g</code> in the parent <code>GridLayout</code> of <code>g</code> if it is a <code>GridPosition</code> and in a nested child <code>GridLayout</code> if it is a <code>GridSubposition</code>. The <code>args</code> and <code>kwargs</code> are passed on to the normal <code>GridLayout</code> constructor.</p><pre><code>function GridLayout(nrows::Integer, ncols::Integer;
    parent = nothing,
    rowsizes = nothing,
    colsizes = nothing,
    addedrowgaps = nothing,
    addedcolgaps = nothing,
    alignmode = Inside(),
    equalprotrusiongaps = (false, false),
    bbox = nothing,
    width = Auto(),
    height = Auto(),
    tellwidth::Bool = true,
    tellheight::Bool = true,
    halign = :center,
    valign = :center,
    default_rowgap = get_default_rowgap(),
    default_colgap = get_default_colgap(),
    kwargs...)</code></pre><p>Create a <code>GridLayout</code> with optional parent <code>parent</code> with <code>nrows</code> rows and <code>ncols</code> columns.</p></div></div><div class="docstring"><div class="doc-header" id="GridLayoutSpec"><a href="#GridLayoutSpec">GridLayoutSpec</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutSpec</code></pre><h1>Fields</h1><pre><code>content :: Vector{Pair{Tuple{Union{Colon, Int64, UnitRange}, Union{Colon, Int64, UnitRange}, GridLayoutBase.Side}, Any}}
kwargs  :: Dict{Symbol, Any}</code></pre></div></div><div class="docstring"><div class="doc-header" id="GridPosition"><a href="#GridPosition">GridPosition</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridPosition</code></pre><h1>Fields</h1><pre><code>layout :: GridLayout
span   :: GridLayoutBase.Span
side   :: GridLayoutBase.Side</code></pre></div></div><div class="docstring"><div class="doc-header" id="GridSubposition"><a href="#GridSubposition">GridSubposition</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridSubposition</code></pre><h1>Fields</h1><pre><code>parent :: Union{GridPosition, GridSubposition}
rows   :: Any
cols   :: Any
side   :: GridLayoutBase.Side</code></pre></div></div><div class="docstring"><div class="doc-header" id="HLines"><a href="#HLines">HLines</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="HSpan"><a href="#HSpan">HSpan</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Heatmap"><a href="#Heatmap">Heatmap</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Hexbin"><a href="#Hexbin">Hexbin</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Hist"><a href="#Hist">Hist</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Image"><a href="#Image">Image</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="IndexedAbsorptionRGBA"><a href="#IndexedAbsorptionRGBA">IndexedAbsorptionRGBA</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Inside"><a href="#Inside">Inside</a></div><div class="doc-content"><p>AlignMode that excludes the protrusions from the bounding box.</p></div></div><div class="docstring"><div class="doc-header" id="IntervalSlider"><a href="#IntervalSlider">IntervalSlider</a></div><div class="doc-content"><p><strong><code>IntervalSlider &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?IntervalSlider.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>color_active</code>, <code>color_active_dimmed</code>, <code>color_inactive</code>, <code>halign</code>, <code>height</code>, <code>horizontal</code>, <code>interval</code>, <code>linewidth</code>, <code>range</code>, <code>snap</code>, <code>startvalues</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="IntervalsBetween"><a href="#IntervalsBetween">IntervalsBetween</a></div><div class="doc-content"><pre><code>IntervalsBetween(n::Int, mirror::Bool = true)</code></pre><p>Indicates to create n-1 minor ticks between every pair of adjacent major ticks.</p></div></div><div class="docstring"><div class="doc-header" id="IsoValue"><a href="#IsoValue">IsoValue</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Keyboard"><a href="#Keyboard">Keyboard</a></div><div class="doc-content"><p>Backend independent enums which represent keyboard buttons.</p></div></div><div class="docstring"><div class="doc-header" id="KeysEvent"><a href="#KeysEvent">KeysEvent</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct KeysEvent</code></pre><h1>Fields</h1><pre><code>keys :: Set{Makie.Keyboard.Button}</code></pre></div></div><div class="docstring"><div class="doc-header" id="LScene"><a href="#LScene">LScene</a></div><div class="doc-content"><p><strong><code>LScene &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?LScene.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>halign</code>, <code>height</code>, <code>show_axis</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Label"><a href="#Label">Label</a></div><div class="doc-content"><p><strong><code>Label &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Label.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>color</code>, <code>font</code>, <code>fontsize</code>, <code>halign</code>, <code>height</code>, <code>justification</code>, <code>lineheight</code>, <code>padding</code>, <code>rotation</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>text</code>, <code>valign</code>, <code>visible</code>, <code>width</code>, <code>word_wrap</code></p></div></div><div class="docstring"><div class="doc-header" id="LayoutObservables"><a href="#LayoutObservables">LayoutObservables</a></div><div class="doc-content"><pre><code>struct LayoutObservables{G}</code></pre><p><code>T</code> is the same type parameter of contained <code>GridContent</code>, <code>G</code> is <code>GridLayout</code> which is defined only after <code>LayoutObservables</code>.</p><p>A collection of <code>Observable</code>s and an optional <code>GridContent</code> that are needed to interface with the MakieLayout layouting system.</p><ul><li><p><code>suggestedbbox::Observable{Rect2f}</code>: The bounding box that an element should place itself in. Depending on the element's <code>width</code> and <code>height</code> attributes, this is not necessarily equal to the computedbbox.</p></li><li><p><code>protrusions::Observable{RectSides{Float32}}</code>: The sizes of content "sticking out" of the main element into the <code>GridLayout</code> gaps.</p></li><li><p><code>reporteddimensions::Observable{Dimensions}</code>: The dimensions (inner and outer) that the object communicates to the containing <code>GridLayout</code>.</p></li><li><p><code>autosize::Observable{NTuple{2, Optional{Float32}}}</code>: The width and height that the element reports to its parent <code>GridLayout</code>. If the element doesn't want to cause the parent to adjust to its size, autosize can hide the reportedsize from it by being set to <code>nothing</code>.</p></li><li><p><code>computedbbox::Observable{Rect2f}</code>: The bounding box that the element computes for itself after it has received a suggestedbbox.</p></li><li><p><code>gridcontent::Optional{GridContent{G}}</code>: A reference of a <code>GridContent</code> if the element is currently placed in a <code>GridLayout</code>. This can be used to retrieve the parent layout, remove the element from it or change its position, and assign it to a different layout.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Left"><a href="#Left">Left</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Left</code></pre><h1>Supertype Hierarchy</h1><pre><code>Left &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Legend"><a href="#Legend">Legend</a></div><div class="doc-content"><p><strong><code>Legend &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Legend.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>backgroundcolor</code>, <code>bgcolor</code>, <code>colgap</code>, <code>framecolor</code>, <code>framevisible</code>, <code>framewidth</code>, <code>gridshalign</code>, <code>gridsvalign</code>, <code>groupgap</code>, <code>halign</code>, <code>height</code>, <code>label</code>, <code>labelcolor</code>, <code>labelfont</code>, <code>labelhalign</code>, <code>labeljustification</code>, <code>labelsize</code>, <code>labelvalign</code>, <code>linecolor</code>, <code>linepoints</code>, <code>linestyle</code>, <code>linewidth</code>, <code>margin</code>, <code>marker</code>, <code>markercolor</code>, <code>markerpoints</code>, <code>markersize</code>, <code>markerstrokecolor</code>, <code>markerstrokewidth</code>, <code>nbanks</code>, <code>orientation</code>, <code>padding</code>, <code>patchcolor</code>, <code>patchlabelgap</code>, <code>patchsize</code>, <code>patchstrokecolor</code>, <code>patchstrokewidth</code>, <code>polycolor</code>, <code>polypoints</code>, <code>polystrokecolor</code>, <code>polystrokewidth</code>, <code>rowgap</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>titlecolor</code>, <code>titlefont</code>, <code>titlegap</code>, <code>titlehalign</code>, <code>titleposition</code>, <code>titlesize</code>, <code>titlevalign</code>, <code>titlevisible</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="LegendElement"><a href="#LegendElement">LegendElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type LegendElement</code></pre><h1>Subtypes</h1><pre><code>LineElement
MarkerElement
PolyElement</code></pre></div></div><div class="docstring"><div class="doc-header" id="LegendEntry"><a href="#LegendEntry">LegendEntry</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct LegendEntry</code></pre><h1>Fields</h1><pre><code>elements   :: Vector{LegendElement}
attributes :: Attributes</code></pre></div></div><div class="docstring"><div class="doc-header" id="LineElement"><a href="#LineElement">LineElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct LineElement</code></pre><h1>Fields</h1><pre><code>attributes :: Attributes</code></pre><h1>Supertype Hierarchy</h1><pre><code>LineElement &lt;: LegendElement &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="LineSegments"><a href="#LineSegments">LineSegments</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="LineTo"><a href="#LineTo">LineTo</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct LineTo</code></pre><h1>Fields</h1><pre><code>p :: Point2{Float64}</code></pre></div></div><div class="docstring"><div class="doc-header" id="LinearTicks"><a href="#LinearTicks">LinearTicks</a></div><div class="doc-content"><p>LinearTicks with ideally a number of <code>n_ideal</code> tick marks.</p></div></div><div class="docstring"><div class="doc-header" id="Lines"><a href="#Lines">Lines</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Linestyle"><a href="#Linestyle">Linestyle</a></div><div class="doc-content"><pre><code>Linestyle(value::Vector{&lt;:Real})</code></pre><p>A type that can be used as value for the <code>linestyle</code> keyword argument of plotting functions to arbitrarily customize the linestyle.</p><p>The <code>value</code> is a vector of positions where the line flips from being drawn or not and vice versa. The values of <code>value</code> are in units of linewidth.</p><p>For example, with <code>value = [0.0, 4.0, 6.0, 9.5]</code> you start drawing at 0, stop at 4 linewidths, start again at 6, stop at 9.5, then repeat with 0 and 9.5 being treated as the same position.</p></div></div><div class="docstring"><div class="doc-header" id="LogTicks"><a href="#LogTicks">LogTicks</a></div><div class="doc-content"><pre><code>LogTicks{T}(linear_ticks::T)</code></pre><p>Wraps any other tick object. Used to apply a linear tick searching algorithm on a log-transformed interval.</p></div></div><div class="docstring"><div class="doc-header" id="Makie"><a href="#Makie">Makie</a></div><div class="doc-content"><p>No docstring found for module <code>Makie</code>.</p><h1>Exported names</h1><p><code>..</code>, <code>@L_str</code>, <code>@colorant_str</code>, <code>@extract</code>, <code>@extractvalue</code>, <code>@get_attribute</code>, <code>@key_str</code>, <code>@lift</code>, <code>@recipe</code>, <code>ABLines</code>, <code>Absolute</code>, <code>Absorption</code>, <code>AbsorptionRGBA</code>, <code>AbstractCamera</code>, <code>AbstractPlot</code>, <code>AbstractScene</code>, <code>Accum</code>, <code>AmbientLight</code>, <code>Annotations</code>, <code>Arc</code>, <code>Arrows</code>, <code>Aspect</code>, <code>Atomic</code>, <code>Attributes</code>, <code>Auto</code>, <code>Axis</code>, <code>Axis3</code>, <code>Axis3D</code>, <code>AxisAspect</code>, <code>BBox</code>, <code>Band</code>, <code>BarPlot</code>, <code>BezierPath</code>, <code>Billboard</code>, <code>Bottom</code>, <code>BottomLeft</code>, <code>BottomRight</code>, <code>Box</code>, <code>BoxPlot</code>, <code>Bracket</code>, <code>Button</code>, <code>Camera</code>, <code>Camera2D</code>, <code>Camera3D</code>, <code>Circle</code>, <code>ClosePath</code>, <code>Colorbar</code>, <code>Combined</code>, <code>Consume</code>, <code>ContinuousSurface</code>, <code>Contour</code>, <code>Contour3d</code>, <code>Contourf</code>, <code>ConversionTrait</code>, <code>CrossBar</code>, <code>CurveTo</code>, <code>Cycle</code>, <code>Cycled</code>, <code>DataAspect</code>, <code>DataInspector</code>, <code>DataShader</code>, <code>Density</code>, <code>DiscreteSurface</code>, <code>ECDFPlot</code>, <code>EllipticalArc</code>, <code>EmptyCamera</code>, <code>EnvironmentLight</code>, <code>Errorbars</code>, <code>Events</code>, <code>Exclusively</code>, <code>Figure</code>, <code>Fixed</code>, <code>GridLayout</code>, <code>GridLayoutSpec</code>, <code>GridPosition</code>, <code>GridSubposition</code>, <code>HLines</code>, <code>HSpan</code>, <code>Heatmap</code>, <code>Hexbin</code>, <code>Hist</code>, <code>Image</code>, <code>IndexedAbsorptionRGBA</code>, <code>Inside</code>, <code>IntervalSlider</code>, <code>IntervalsBetween</code>, <code>IsoValue</code>, <code>Keyboard</code>, <code>KeysEvent</code>, <code>LScene</code>, <code>Label</code>, <code>LayoutObservables</code>, <code>Left</code>, <code>Legend</code>, <code>LegendElement</code>, <code>LegendEntry</code>, <code>LineElement</code>, <code>LineSegments</code>, <code>LineTo</code>, <code>LinearTicks</code>, <code>Lines</code>, <code>Linestyle</code>, <code>LogTicks</code>, <code>MakieScreen</code>, <code>MarkerElement</code>, <code>MaximumIntensityProjection</code>, <code>Menu</code>, <code>Mesh</code>, <code>MeshScatter</code>, <code>Mixed</code>, <code>Mouse</code>, <code>MouseEvent</code>, <code>MouseEventTypes</code>, <code>MoveTo</code>, <code>MultiplesTicks</code>, <code>NoConversion</code>, <code>Observable</code>, <code>OldAxis</code>, <code>Outside</code>, <code>Pattern</code>, <code>Pie</code>, <code>Pixel</code>, <code>PixelSpace</code>, <code>PlotSpec</code>, <code>Point</code>, <code>Point2</code>, <code>Point2f</code>, <code>Point3</code>, <code>Point3f</code>, <code>Point4</code>, <code>Point4f</code>, <code>PointBased</code>, <code>PointLight</code>, <code>PolarAxis</code>, <code>Poly</code>, <code>PolyElement</code>, <code>QQNorm</code>, <code>QQPlot</code>, <code>Quaternion</code>, <code>Quaternionf</code>, <code>RGBAf</code>, <code>RGBf</code>, <code>RainClouds</code>, <code>Rangebars</code>, <code>RaymarchAlgorithm</code>, <code>RealVector</code>, <code>Record</code>, <code>RecordEvents</code>, <code>Rect</code>, <code>Rect2</code>, <code>Rect2f</code>, <code>Rect2i</code>, <code>Rect3</code>, <code>Rect3f</code>, <code>Rect3i</code>, <code>Rectf</code>, <code>Recti</code>, <code>Relative</code>, <code>Reverse</code>, <code>ReversibleScale</code>, <code>Right</code>, <code>SSAO</code>, <code>Scatter</code>, <code>ScatterLines</code>, <code>Scene</code>, <code>SceneLike</code>, <code>SceneSpace</code>, <code>ScrollEvent</code>, <code>Series</code>, <code>Slider</code>, <code>SliderGrid</code>, <code>Sphere</code>, <code>Spy</code>, <code>Stairs</code>, <code>Stem</code>, <code>StepHist</code>, <code>Stepper</code>, <code>StreamPlot</code>, <code>Surface</code>, <code>SurfaceLike</code>, <code>Text</code>, <code>Textbox</code>, <code>Theme</code>, <code>TimeSeries</code>, <code>Toggle</code>, <code>Tooltip</code>, <code>Top</code>, <code>TopLeft</code>, <code>TopRight</code>, <code>Transformation</code>, <code>Tricontourf</code>, <code>Triplot</code>, <code>Unit</code>, <code>VLines</code>, <code>VSpan</code>, <code>Vec</code>, <code>Vec2</code>, <code>Vec2f</code>, <code>Vec3</code>, <code>Vec3f</code>, <code>Vec4</code>, <code>Vec4f</code>, <code>VecTypes</code>, <code>VideoStream</code>, <code>Violin</code>, <code>Volume</code>, <code>VolumeLike</code>, <code>VolumeSlices</code>, <code>Voronoiplot</code>, <code>Waterfall</code>, <code>WilkinsonTicks</code>, <code>Wireframe</code>, <code>abline!</code>, <code>ablines</code>, <code>ablines!</code>, <code>activate_interaction!</code>, <code>addmouseevents!</code>, <code>annotations</code>, <code>annotations!</code>, <code>arc</code>, <code>arc!</code>, <code>arrows</code>, <code>arrows!</code>, <code>assetpath</code>, <code>attributes</code>, <code>autolimits!</code>, <code>available_gradients</code>, <code>axis3d</code>, <code>axis3d!</code>, <code>axislegend</code>, <code>band</code>, <code>band!</code>, <code>barplot</code>, <code>barplot!</code>, <code>bottom</code>, <code>boundingbox</code>, <code>boxplot</code>, <code>boxplot!</code>, <code>bracket</code>, <code>bracket!</code>, <code>broadcast_foreach</code>, <code>cam2d</code>, <code>cam2d!</code>, <code>cam3d!</code>, <code>cam3d_cad!</code>, <code>cam_relative!</code>, <code>camera</code>, <code>cameracontrols</code>, <code>cameracontrols!</code>, <code>campixel</code>, <code>campixel!</code>, <code>categorical_colors</code>, <code>center!</code>, <code>cgrad</code>, <code>colgap!</code>, <code>colorbuffer</code>, <code>colsize!</code>, <code>connect!</code>, <code>connect_screen</code>, <code>content</code>, <code>contents</code>, <code>contour</code>, <code>contour!</code>, <code>contour3d</code>, <code>contour3d!</code>, <code>contourf</code>, <code>contourf!</code>, <code>convert_arguments</code>, <code>convert_attribute</code>, <code>crossbar</code>, <code>crossbar!</code>, <code>current_axis</code>, <code>current_axis!</code>, <code>current_figure</code>, <code>current_figure!</code>, <code>data_limits</code>, <code>datashader</code>, <code>datashader!</code>, <code>deactivate_interaction!</code>, <code>decompose</code>, <code>default_theme</code>, <code>density</code>, <code>density!</code>, <code>deregister_interaction!</code>, <code>disconnect!</code>, <code>dropped_files</code>, <code>ecdfplot</code>, <code>ecdfplot!</code>, <code>entered_window</code>, <code>errorbars</code>, <code>errorbars!</code>, <code>events</code>, <code>fill_between!</code>, <code>flatten_plots</code>, <code>grid!</code>, <code>gridnest!</code>, <code>hasfocus</code>, <code>heatmap</code>, <code>heatmap!</code>, <code>height</code>, <code>help</code>, <code>help_arguments</code>, <code>help_attributes</code>, <code>hexbin</code>, <code>hexbin!</code>, <code>hgrid!</code>, <code>hidedecorations!</code>, <code>hidespines!</code>, <code>hidexdecorations!</code>, <code>hideydecorations!</code>, <code>hidezdecorations!</code>, <code>hist</code>, <code>hist!</code>, <code>hlines</code>, <code>hlines!</code>, <code>hovered_scene</code>, <code>hspan</code>, <code>hspan!</code>, <code>image</code>, <code>image!</code>, <code>insertplots!</code>, <code>interactions</code>, <code>is_mouseinside</code>, <code>ispressed</code>, <code>keyboard_buttons</code>, <code>labelslider!</code>, <code>labelslidergrid!</code>, <code>left</code>, <code>lift</code>, <code>limits!</code>, <code>lines</code>, <code>lines!</code>, <code>linesegments</code>, <code>linesegments!</code>, <code>linkaxes!</code>, <code>linkxaxes!</code>, <code>linkyaxes!</code>, <code>map_once</code>, <code>mesh</code>, <code>mesh!</code>, <code>meshscatter</code>, <code>meshscatter!</code>, <code>mouse_buttons</code>, <code>mouse_position</code>, <code>mouse_selection</code>, <code>mouseover</code>, <code>mouseposition</code>, <code>mouseposition_px</code>, <code>ncols</code>, <code>nrows</code>, <code>off</code>, <code>old_cam3d!</code>, <code>old_cam3d_cad!</code>, <code>on</code>, <code>onany</code>, <code>onmousedownoutside</code>, <code>onmouseenter</code>, <code>onmouseleftclick</code>, <code>onmouseleftdoubleclick</code>, <code>onmouseleftdown</code>, <code>onmouseleftdrag</code>, <code>onmouseleftdragstart</code>, <code>onmouseleftdragstop</code>, <code>onmouseleftup</code>, <code>onmousemiddleclick</code>, <code>onmousemiddledoubleclick</code>, <code>onmousemiddledown</code>, <code>onmousemiddledrag</code>, <code>onmousemiddledragstart</code>, <code>onmousemiddledragstop</code>, <code>onmousemiddleup</code>, <code>onmouseout</code>, <code>onmouseover</code>, <code>onmouserightclick</code>, <code>onmouserightdoubleclick</code>, <code>onmouserightdown</code>, <code>onmouserightdrag</code>, <code>onmouserightdragstart</code>, <code>onmouserightdragstop</code>, <code>onmouserightup</code>, <code>onpick</code>, <code>pick</code>, <code>pie</code>, <code>pie!</code>, <code>pixelarea</code>, <code>plot</code>, <code>plot!</code>, <code>plotkey</code>, <code>plots</code>, <code>poly</code>, <code>poly!</code>, <code>px</code>, <code>qqnorm</code>, <code>qqnorm!</code>, <code>qqplot</code>, <code>qqplot!</code>, <code>qrotation</code>, <code>quiver</code>, <code>quiver!</code>, <code>rainclouds</code>, <code>rainclouds!</code>, <code>rangebars</code>, <code>rangebars!</code>, <code>record</code>, <code>record_events</code>, <code>recordframe!</code>, <code>register_interaction!</code>, <code>replace_automatic!</code>, <code>replay_events</code>, <code>resample_cmap</code>, <code>reset_limits!</code>, <code>resize_to_layout!</code>, <code>rich</code>, <code>right</code>, <code>rlims!</code>, <code>rotate!</code>, <code>rotate_cam!</code>, <code>rowgap!</code>, <code>rowsize!</code>, <code>save</code>, <code>scale!</code>, <code>scatter</code>, <code>scatter!</code>, <code>scatterlines</code>, <code>scatterlines!</code>, <code>scroll</code>, <code>select_line</code>, <code>select_point</code>, <code>select_rectangle</code>, <code>series</code>, <code>series!</code>, <code>set_close_to!</code>, <code>set_theme!</code>, <code>showgradients</code>, <code>spy</code>, <code>spy!</code>, <code>stairs</code>, <code>stairs!</code>, <code>stem</code>, <code>stem!</code>, <code>stephist</code>, <code>stephist!</code>, <code>streamplot</code>, <code>streamplot!</code>, <code>subscript</code>, <code>superscript</code>, <code>surface</code>, <code>surface!</code>, <code>swap!</code>, <code>text</code>, <code>text!</code>, <code>theme</code>, <code>theme_black</code>, <code>theme_dark</code>, <code>theme_ggplot2</code>, <code>theme_latexfonts</code>, <code>theme_light</code>, <code>theme_minimal</code>, <code>thetalims!</code>, <code>tight_ticklabel_spacing!</code>, <code>tight_xticklabel_spacing!</code>, <code>tight_yticklabel_spacing!</code>, <code>tightlimits!</code>, <code>timeseries</code>, <code>timeseries!</code>, <code>to_align</code>, <code>to_color</code>, <code>to_colormap</code>, <code>to_font</code>, <code>to_fontsize</code>, <code>to_ndim</code>, <code>to_rotation</code>, <code>to_value</code>, <code>to_vector</code>, <code>to_world</code>, <code>tooltip</code>, <code>tooltip!</code>, <code>top</code>, <code>translate!</code>, <code>translate_cam!</code>, <code>translated</code>, <code>translation</code>, <code>tricontourf</code>, <code>tricontourf!</code>, <code>trim!</code>, <code>triplot</code>, <code>triplot!</code>, <code>unicode_input</code>, <code>update_cam!</code>, <code>update_theme!</code>, <code>used_attributes</code>, <code>vgrid!</code>, <code>violin</code>, <code>violin!</code>, <code>vlines</code>, <code>vlines!</code>, <code>volume</code>, <code>volume!</code>, <code>volumeslices</code>, <code>volumeslices!</code>, <code>voronoiplot</code>, <code>voronoiplot!</code>, <code>vspan</code>, <code>vspan!</code>, <code>waterfall</code>, <code>waterfall!</code>, <code>width</code>, <code>widths</code>, <code>window_area</code>, <code>window_open</code>, <code>wireframe</code>, <code>wireframe!</code>, <code>with_theme</code>, <code>with_updates_suspended</code>, <code>xlabel!</code>, <code>xlims!</code>, <code>xticklabels</code>, <code>xtickrange</code>, <code>xtickrotation</code>, <code>xtickrotation!</code>, <code>xticks!</code>, <code>ylabel!</code>, <code>ylims!</code>, <code>yticklabels</code>, <code>ytickrange</code>, <code>ytickrotation</code>, <code>ytickrotation!</code>, <code>yticks!</code>, <code>zlabel!</code>, <code>zlims!</code>, <code>zoom!</code>, <code>zticklabels</code>, <code>ztickrange</code>, <code>ztickrotation</code>, <code>ztickrotation!</code>, <code>zticks!</code></p><h1>Displaying contents of readme found at <code>/home/runner/work/Makie.jl/Makie.jl/README.md</code></h1><p>&lt;div align="center"&gt;     &lt;picture&gt;       &lt;source media="(prefers-color-scheme: dark)"          srcset="/assets/makie<em>logo</em>canvas<em>dark.svg" &gt;       &lt;img alt="Makie.jl logo"          src="/assets/makie</em>logo_canvas.svg" width="350"&gt;     &lt;/picture&gt; &lt;/div&gt;</p><p>&lt;div align="center"&gt;</p><p>[![][docs-stable-img]][docs-stable-url] [![][docs-master-img]][docs-master-url]</p><p><a href="https://github.com/MakieOrg/Makie.jl/actions/workflows/ci.yml?query=branch%3Amaster"><img alt="Build Status" src="https://github.com/MakieOrg/Makie.jl/actions/workflows/ci.yml/badge.svg?branch=master"/></a><a href="https://github.com/MakieOrg/Makie.jl/blob/main/LICENSE"><img alt="License: MIT" src="https://img.shields.io/badge/License-MIT-green.svg"/></a><a href="https://pkgs.genieframework.com?packages=Makie"><img alt="Downloads" src="https://shields.io/endpoint?url=https://pkgs.genieframework.com/api/v1/badge/Makie&amp;label=Downloads"/></a></p><p>[![JOSS][joss-img]][joss-url] <a href="https://juleskreuer.eu/projekte/citation-badge"><img alt="Citation Badge" src="https://api.juleskreuer.eu/citation-badge.php?doi=10.21105/joss.03349"/></a></p><p><a href="https://twitter.com/MakiePlots"><img alt="" src="https://img.shields.io/badge/Twitter-@MakiePlots-1DA1F2?&amp;logo=twitter&amp;logoColor=white"/></a> [![chat][discord-img]][discord-url]</p><p>&lt;/div&gt;</p><p>Makie is an interactive data visualization and plotting ecosystem for the <a href="https://julialang.org/">Julia programming language</a>, available on Windows, Linux and Mac. The backend packages <strong>GLMakie</strong>, <strong>WGLMakie</strong>, <strong>CairoMakie</strong> and <strong>RPRMakie</strong> add different functionalities: You can use Makie to interactively explore your data and create simple GUIs in native windows or web browsers, export high-quality vector graphics or even raytrace with physically accurate lighting.</p><p>The name Makie (we pronounce it Mah-kee) is derived from the japanese word <a href="https://en.wikipedia.org/wiki/Maki-e"><em>Maki-e</em></a>, which is a technique to sprinkle lacquer with gold and silver powder. Data is the gold and silver of our age, so let's spread it out beautifully on the screen!</p><p>To learn more, we invite you to visit the documentation at <a href="http://docs.makie.org/stable/">docs.makie.org</a>.</p><p>[gitlab-img]: https://gitlab.com/JuliaGPU/Makie.jl/badges/master/pipeline.svg [gitlab-url]: https://gitlab.com/JuliaGPU/Makie.jl/pipelines [docs-stable-img]: https://img.shields.io/badge/Docs-Stable-lightgrey.svg [docs-stable-url]: http://docs.makie.org/stable/ [docs-master-img]: https://img.shields.io/badge/Docs-Dev-blue.svg [docs-master-url]: http://docs.makie.org/dev/ [joss-url]: https://doi.org/10.21105/joss.03349 [joss-img]: http://joss.theoj.org/papers/10.21105/joss.03349/status.svg</p><p>[discord-url]: https://discord.com/invite/2FBjYAT3cY [discord-img]: https://img.shields.io/discord/996787732149981214.svg?logo=discord&amp;colorB=7289DA&amp;label=Discord</p><h2>Citing Makie</h2><p>If you use Makie for a scientific publication, please acknowledge and support our work by citing <a href="https://joss.theoj.org/papers/10.21105/joss.03349">our JOSS paper</a> the following way:</p><pre><code>Danisch &amp; Krumbiegel, (2021). Makie.jl: Flexible high-performance data visualization for Julia.
Journal of Open Source Software, 6(65), 3349, https://doi.org/10.21105/joss.03349</code></pre><p>&lt;details&gt;   &lt;summary&gt;BibTeX entry:&lt;/summary&gt;</p><pre><code class="language-bib">@article{DanischKrumbiegel2021,
  doi = {10.21105/joss.03349},
  url = {https://doi.org/10.21105/joss.03349},
  year = {2021},
  publisher = {The Open Journal},
  volume = {6},
  number = {65},
  pages = {3349},
  author = {Simon Danisch and Julius Krumbiegel},
  title = {{Makie.jl}: Flexible high-performance data visualization for {Julia}},
  journal = {Journal of Open Source Software}
}</code></pre><p>&lt;/details&gt;</p><p>or <a href="./assets/DanischKrumbiegel2021.bibtex">Download the BibTeX file</a>.</p><h2>Community Channels</h2><p>We are on <a href="https://discord.com/invite/2FBjYAT3cY">Discord</a> and <a href="https://discourse.julialang.org/c/17?tags=Makie">Discourse</a>! Community channels are a great way for you to ask questions and get help. Please join us!</p><h2>Installation</h2><p>Choose one or more backend packages: <strong>GLMakie</strong> (interactive OpenGL in native OS windows), <strong>WGLMakie</strong> (interactive WebGL in browsers, IDEs, notebooks), <strong>CairoMakie</strong> (static 2D vector graphics and images) and <strong>RPRMakie</strong> (raytracing). Each backend re-exports all of Makie.jl so you don't have to install or load it explicitly.</p><p>Install:</p><pre><code class="language-julia">julia&gt;]
pkg&gt; add GLMakie</code></pre><p>Check the installed version:</p><pre><code class="language-julia">]st GLMakie</code></pre><p>Start using the package:</p><pre><code class="language-julia">using GLMakie</code></pre><h2>Developing Makie</h2><p>&lt;details&gt;   &lt;summary&gt;&lt;span style="color:red"&gt; ð¥ Click for more ð¥&lt;/span&gt;&lt;/summary&gt;</p><p>Makie and its backends all live in the Makie monorepo. This makes it easier to change code across all packages. Therefore, dev'ing Makie almost works as with other Julia packages, just, that one needs to also dev the sub packages:</p><pre><code class="language-julia">]dev --local Makie # local will clone the repository at ./dev/Makie
]dev dev/Makie/MakieCore dev/Makie/GLMakie dev/Makie/CairoMakie dev/Makie/WGLMakie dev/Makie/RPRMakie</code></pre><p>To run the tests, you also should add:</p><pre><code class="language-julia">]dev dev/Makie/ReferenceTests</code></pre><p>For more info about ReferenceTests, check out its <a href="./ReferenceUpdater/README.md">README</a> &lt;/details&gt;</p><h2>Examples</h2><p>The following examples are supposed to be self-explanatory. For further information <a href="http://docs.makie.org/stable/">check out the documentation!</a></p><h3>A simple parabola</h3><pre><code class="language-julia">x = 1:0.1:10
fig = lines(x, x.^2; label = "Parabola",
    axis = (; xlabel = "x", ylabel = "y", title ="Title"),
    figure = (; resolution = (800,600), fontsize = 22))
axislegend(; position = :lt)
save("./assets/parabola.png", fig)
fig</code></pre><p>&lt;img src="./assets/parabola.png" width="600"&gt;</p><h3>A more complex plot with unicode characters and LaTeX strings:</h3><p><a href="&lt;https://github.com/gcalderone/Gnuplot.jl#a-slightly-more-complex-plot-with-unicode-on-x-tics&gt;">Similar to the one on this link</a></p><p>&lt;details&gt;   &lt;summary&gt;Show Code&lt;/summary&gt;</p><pre><code class="language-julia">x = -2pi:0.1:2pi
approx = fill(0.0, length(x))
cmap = [:gold, :deepskyblue3, :orangered, "#e82051"]
with_theme(palette = (; patchcolor = cgrad(cmap, alpha=0.45))) do
    fig, axis, lineplot = lines(x, sin.(x); label = L"sin(x)", linewidth = 3, color = :black,
        axis = (; title = "Polynomial approximation of sin(x)",
            xgridstyle = :dash, ygridstyle = :dash,
            xticksize = 10, yticksize = 10, xtickalign = 1, ytickalign = 1,
            xticks = (-Ï:Ï/2:Ï, ["Ï", "-Ï/2", "0", "Ï/2", "Ï"])
        ))
    translate!(lineplot, 0, 0, 2) # move line to foreground
    band!(x, sin.(x), approx .+= x; label = L"n = 0")
    band!(x, sin.(x), approx .+= -x .^ 3 / 6; label = L"n = 1")
    band!(x, sin.(x), approx .+= x .^ 5 / 120; label = L"n = 2")
    band!(x, sin.(x), approx .+= -x .^ 7 / 5040; label = L"n = 3")
    limits!(-3.8, 3.8, -1.5, 1.5)
    axislegend(; position = :ct, backgroundcolor = (:white, 0.75), framecolor = :orange)
    save("./assets/approxsin.png", fig, resolution = (800, 600))
    fig
end</code></pre><p>&lt;/details&gt;</p><p>&lt;img src="./assets/approxsin.png" width="600"&gt;</p><h3>Simple layout: Heatmap, contour and 3D surface plot</h3><p>&lt;details&gt;   &lt;summary&gt;Show Code&lt;/summary&gt;</p><p>```julia x = y = -5:0.5:5 z = x .^ 2 .+ y' .^ 2 cmap = :plasma with_theme(colormap = cmap) do     fig = Figure(fontsize = 22)     ax3d = Axis3(fig[1, 1]; aspect = (1, 1, 1),         perspectiveness = 0.5, azimuth = 2.19, elevation = 0.57)     ax2d = Axis(fig[1, 2]; aspect = 1, xlabel = "x", ylabel="y")     pltobj = surface!(ax3d, x, y, z; transparency = true)     heatmap!(ax2d, x, y, z; colormap = (cmap, 0.65))     contour!(ax2d, x, y, z; linewidth = 2, levels = 12, color = :black)     contour3d!(ax3d, x, y, z; linewidth = 4, levels = 12,         transparency = true)     Colorbar(fig[1, 3], pltobj; label="z", labelrotation=pi)     colsize!(fig.layout, 1, Aspect(1, 1.0))     colsize!(fig.layout, 2, Aspect(1, 1.0))</p><p>[output truncated to first 200 lines]</p></div></div><div class="docstring"><div class="doc-header" id="MakieScreen"><a href="#MakieScreen">MakieScreen</a></div><div class="doc-content"><p>Screen constructors implemented by all backends:</p><pre><code class="language-julia"># Constructor aimed at showing the plot in a window.
Screen(scene::Scene; screen_config...)

# Screen to save a png/jpeg to file or io
Screen(scene::Scene, io::IO, mime; screen_config...)

# Screen that is efficient for `colorbuffer(screen, format)`
Screen(scene::Scene, format::Makie.ImageStorageFormat; screen_config...)</code></pre><p>Interface implemented by all backends:</p><pre><code class="language-julia"># Needs to be overload:
size(screen) # Size in pixel
empty!(screen) # empties screen state to reuse the screen, or to close it

# Optional
wait(screen) # waits as long window is open

# Provided by Makie:
push_screen!(scene, screen)</code></pre></div></div><div class="docstring"><div class="doc-header" id="MarkerElement"><a href="#MarkerElement">MarkerElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct MarkerElement</code></pre><h1>Fields</h1><pre><code>attributes :: Attributes</code></pre><h1>Supertype Hierarchy</h1><pre><code>MarkerElement &lt;: LegendElement &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="MaximumIntensityProjection"><a href="#MaximumIntensityProjection">MaximumIntensityProjection</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Menu"><a href="#Menu">Menu</a></div><div class="doc-content"><p><strong><code>Menu &lt;: Block</code></strong></p><p>A drop-down menu with multiple selectable options. You can pass options with the keyword argument <code>options</code>.</p><p>Options are given as an iterable of elements. For each element, the option label in the menu is determined with <code>optionlabel(element)</code> and the option value with <code>optionvalue(element)</code>. These functions can be overloaded for custom types. The default is that tuples of two elements are expected to be label and value, where <code>string(label)</code> is used as the label, while for all other objects, label = <code>string(object)</code> and value = object.</p><p>When an item is selected in the menu, the menu's <code>selection</code> attribute is set to <code>optionvalue(selected_element)</code>. When nothing is selected, that value is <code>nothing</code>.</p><p>You can set the initial selection by passing one of the labels with the <code>default</code> keyword.</p><h2>Constructors</h2><pre><code class="language-julia">Menu(fig_or_scene; default = nothing, kwargs...)</code></pre><h2>Examples</h2><p>Menu with string entries, second preselected:</p><pre><code class="language-julia">menu1 = Menu(fig[1, 1], options = ["first", "second", "third"], default = "second")</code></pre><p>Menu with two-element entries, label and function:</p><pre><code class="language-julia">funcs = [sin, cos, tan]
labels = ["Sine", "Cosine", "Tangens"]

menu2 = Menu(fig[1, 1], options = zip(labels, funcs))</code></pre><p>Executing a function when a selection is made:</p><pre><code class="language-julia">on(menu2.selection) do selected_function
    # do something with the selected function
end</code></pre><p><strong>Attributes</strong></p><p>(type <code>?Menu.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>cell_color_active</code>, <code>cell_color_hover</code>, <code>cell_color_inactive_even</code>, <code>cell_color_inactive_odd</code>, <code>direction</code>, <code>dropdown_arrow_color</code>, <code>dropdown_arrow_size</code>, <code>fontsize</code>, <code>halign</code>, <code>height</code>, <code>i_selected</code>, <code>is_open</code>, <code>options</code>, <code>prompt</code>, <code>scroll_speed</code>, <code>selection</code>, <code>selection_cell_color_inactive</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>textcolor</code>, <code>textpadding</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Mesh"><a href="#Mesh">Mesh</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="MeshScatter"><a href="#MeshScatter">MeshScatter</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Mixed"><a href="#Mixed">Mixed</a></div><div class="doc-content"><p>AlignMode that is Inside where padding is Nothing, Outside where it is Real, and overrides the protrusion with a fixed value where it is a <code>Protrusion</code>.</p></div></div><div class="docstring"><div class="doc-header" id="Mouse"><a href="#Mouse">Mouse</a></div><div class="doc-content"><p>Backend independent enums and fields which represent mouse actions.</p></div></div><div class="docstring"><div class="doc-header" id="MouseEvent"><a href="#MouseEvent">MouseEvent</a></div><div class="doc-content"><pre><code>MouseEvent</code></pre><p>Describes a mouse state change. Fields:</p><ul><li><p><code>type</code>: MouseEventType</p></li><li><p><code>t</code>: Time of the event</p></li><li><p><code>data</code>: Mouse position in data coordinates</p></li><li><p><code>px</code>: Mouse position in px relative to scene origin</p></li><li><p><code>prev_t</code>: Time of previous event</p></li><li><p><code>prev_data</code>: Previous mouse position in data coordinates</p></li><li><p><code>prev_px</code>: Previous mouse position in data coordinates</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="MouseEventTypes"><a href="#MouseEventTypes">MouseEventTypes</a></div><div class="doc-content"><p>No docstring or readme file found for module <code>Makie.MouseEventTypes</code>.</p><h1>Exported names</h1><p><code>MouseEventType</code></p></div></div><div class="docstring"><div class="doc-header" id="MoveTo"><a href="#MoveTo">MoveTo</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct MoveTo</code></pre><h1>Fields</h1><pre><code>p :: Point2{Float64}</code></pre></div></div><div class="docstring"><div class="doc-header" id="MultiplesTicks"><a href="#MultiplesTicks">MultiplesTicks</a></div><div class="doc-content"><p>Like LinearTicks but for multiples of <code>multiple</code>. Example where approximately 5 numbers should be found that are multiples of pi, printed like "1Ï", "2Ï", etc.:</p><pre><code>MultiplesTicks(5, pi, "Ï")</code></pre></div></div><div class="docstring"><div class="doc-header" id="NoConversion"><a href="#NoConversion">NoConversion</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct NoConversion</code></pre><h1>Supertype Hierarchy</h1><pre><code>NoConversion &lt;: ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Observable"><a href="#Observable">Observable</a></div><div class="doc-content"><pre><code>obs = Observable(val; ignore_equal_values=false)
obs = Observable{T}(val; ignore_equal_values=false)</code></pre><p>Like a <code>Ref</code>, but updates can be watched by adding a handler using <a href="@ref"><code>on</code></a> or <a href="@ref"><code>map</code></a>. Set <code>ignore_equal_values=true</code> to not trigger an event for <code>observable[] = new_value</code> if <code>isequal(observable[], new_value)</code>.</p></div></div><div class="docstring"><div class="doc-header" id="OldAxis"><a href="#OldAxis">OldAxis</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct OldAxis</code></pre></div></div><div class="docstring"><div class="doc-header" id="Outside"><a href="#Outside">Outside</a></div><div class="doc-content"><p>AlignMode that includes the protrusions within the bounding box, plus paddings.</p></div></div><div class="docstring"><div class="doc-header" id="Pattern"><a href="#Pattern">Pattern</a></div><div class="doc-content"><pre><code>Pattern(image)
Pattern(mask[; color1, color2])</code></pre><p>Creates an <code>ImagePattern</code> from an <code>image</code> (a matrix of colors) or a <code>mask</code> (a matrix of real numbers). The pattern can be passed as a <code>color</code> to a plot to texture it. If a <code>mask</code> is passed, one can specify to colors between which colors are interpolated.</p><pre><code>Pattern(style::String = "/"; kwargs...)
Pattern(style::Char = '/'; kwargs...)</code></pre><p>Creates a line pattern based on the given argument. Available patterns are <code>'/'</code>, <code>'\'</code>, <code>'-'</code>, <code>'|'</code>, <code>'x'</code>, and <code>'+'</code>. All keyword arguments correspond to the keyword arguments for <a href="@ref"><code>LinePattern</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="Pie"><a href="#Pie">Pie</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Pixel"><a href="#Pixel">Pixel</a></div><div class="doc-content"><p>Unit in pixels on screen. This one is a bit tricky, since it refers to a static attribute (pixels on screen don't change) but since every visual is attached to a camera, the exact scale might change. So in the end, this is just relative to some normed camera - the value on screen, depending on the camera, will not actually sit on those pixels. Only camera that guarantees the correct mapping is the <code>:pixel</code> camera type.</p></div></div><div class="docstring"><div class="doc-header" id="PixelSpace"><a href="#PixelSpace">PixelSpace</a></div><div class="doc-content"><p>Unit in pixels on screen. This one is a bit tricky, since it refers to a static attribute (pixels on screen don't change) but since every visual is attached to a camera, the exact scale might change. So in the end, this is just relative to some normed camera - the value on screen, depending on the camera, will not actually sit on those pixels. Only camera that guarantees the correct mapping is the <code>:pixel</code> camera type.</p></div></div><div class="docstring"><div class="doc-header" id="PlotSpec"><a href="#PlotSpec">PlotSpec</a></div><div class="doc-content"><p><code>PlotSpec{P&lt;:AbstractPlot}(args...; kwargs...)</code></p><p>Object encoding positional arguments (<code>args</code>), a <code>NamedTuple</code> of attributes (<code>kwargs</code>) as well as plot type <code>P</code> of a basic plot.</p></div></div><div class="docstring"><div class="doc-header" id="Point"><a href="#Point">Point</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point2"><a href="#Point2">Point2</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point2f"><a href="#Point2f">Point2f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point3"><a href="#Point3">Point3</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point3f"><a href="#Point3f">Point3f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point4"><a href="#Point4">Point4</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point4f"><a href="#Point4f">Point4f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Point{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Point{S, T} &lt;: GeometryBasics.AbstractPoint{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="PointBased"><a href="#PointBased">PointBased</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct PointBased</code></pre><h1>Supertype Hierarchy</h1><pre><code>PointBased &lt;: ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="PointLight"><a href="#PointLight">PointLight</a></div><div class="doc-content"><p>A positional point light, shining at a certain color. Color values can be bigger than 1 for brighter lights.</p></div></div><div class="docstring"><div class="doc-header" id="PolarAxis"><a href="#PolarAxis">PolarAxis</a></div><div class="doc-content"><p><strong><code>PolarAxis &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?PolarAxis.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>axis_rotation_button</code>, <code>backgroundcolor</code>, <code>clip</code>, <code>clipcolor</code>, <code>direction</code>, <code>fixrmin</code>, <code>gridz</code>, <code>halign</code>, <code>height</code>, <code>normalize_theta_ticks</code>, <code>r_translation_button</code>, <code>radial_distortion_threshold</code>, <code>rautolimitmargin</code>, <code>reset_axis_orientation</code>, <code>reset_button</code>, <code>rgridcolor</code>, <code>rgridstyle</code>, <code>rgridvisible</code>, <code>rgridwidth</code>, <code>rlimits</code>, <code>rminorgridcolor</code>, <code>rminorgridstyle</code>, <code>rminorgridvisible</code>, <code>rminorgridwidth</code>, <code>rminorticks</code>, <code>rtickangle</code>, <code>rtickformat</code>, <code>rticklabelcolor</code>, <code>rticklabelfont</code>, <code>rticklabelpad</code>, <code>rticklabelrotation</code>, <code>rticklabelsize</code>, <code>rticklabelstrokecolor</code>, <code>rticklabelstrokewidth</code>, <code>rticklabelsvisible</code>, <code>rticks</code>, <code>rzoomkey</code>, <code>rzoomlock</code>, <code>sample_density</code>, <code>spinecolor</code>, <code>spinestyle</code>, <code>spinevisible</code>, <code>spinewidth</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>theta_0</code>, <code>theta_as_x</code>, <code>theta_translation_button</code>, <code>thetaautolimitmargin</code>, <code>thetagridcolor</code>, <code>thetagridstyle</code>, <code>thetagridvisible</code>, <code>thetagridwidth</code>, <code>thetalimits</code>, <code>thetaminorgridcolor</code>, <code>thetaminorgridstyle</code>, <code>thetaminorgridvisible</code>, <code>thetaminorgridwidth</code>, <code>thetaminorticks</code>, <code>thetatickformat</code>, <code>thetaticklabelcolor</code>, <code>thetaticklabelfont</code>, <code>thetaticklabelpad</code>, <code>thetaticklabelsize</code>, <code>thetaticklabelstrokecolor</code>, <code>thetaticklabelstrokewidth</code>, <code>thetaticklabelsvisible</code>, <code>thetaticks</code>, <code>thetazoomkey</code>, <code>thetazoomlock</code>, <code>title</code>, <code>titlealign</code>, <code>titlecolor</code>, <code>titlefont</code>, <code>titlegap</code>, <code>titlesize</code>, <code>titlevisible</code>, <code>valign</code>, <code>width</code>, <code>zoomspeed</code></p></div></div><div class="docstring"><div class="doc-header" id="Poly"><a href="#Poly">Poly</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="PolyElement"><a href="#PolyElement">PolyElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct PolyElement</code></pre><h1>Fields</h1><pre><code>attributes :: Attributes</code></pre><h1>Supertype Hierarchy</h1><pre><code>PolyElement &lt;: LegendElement &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="QQNorm"><a href="#QQNorm">QQNorm</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="QQPlot"><a href="#QQPlot">QQPlot</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Quaternion"><a href="#Quaternion">Quaternion</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Quaternion{T}</code></pre><h1>Fields</h1><pre><code>data :: NTuple{4, T}</code></pre></div></div><div class="docstring"><div class="doc-header" id="Quaternionf"><a href="#Quaternionf">Quaternionf</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Quaternion{T}</code></pre><h1>Fields</h1><pre><code>data :: NTuple{4, T}</code></pre></div></div><div class="docstring"><div class="doc-header" id="RGBAf"><a href="#RGBAf">RGBAf</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct ColorTypes.RGBA{T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}}</code></pre><h1>Fields</h1><pre><code>r     :: T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}
g     :: T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}
b     :: T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}
alpha :: T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}</code></pre><h1>Supertype Hierarchy</h1><pre><code>ColorTypes.RGBA{T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}} &lt;: ColorTypes.ColorAlpha{ColorTypes.RGB{T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}}, T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}, 4} &lt;: ColorTypes.TransparentColor{ColorTypes.RGB{T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}}, T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}, 4} &lt;: ColorTypes.Colorant{T&lt;:Union{AbstractFloat, FixedPointNumbers.FixedPoint}, 4} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="RGBf"><a href="#RGBf">RGBf</a></div><div class="doc-content"><p><code>RGB</code> is the standard Red-Green-Blue (sRGB) colorspace.  Values of the individual color channels range from 0 (black) to 1 (saturated). If you want "Integer" storage types (e.g., 255 for full color), use <code>N0f8(1)</code> instead (see FixedPointNumbers).</p></div></div><div class="docstring"><div class="doc-header" id="RainClouds"><a href="#RainClouds">RainClouds</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Rangebars"><a href="#Rangebars">Rangebars</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="RaymarchAlgorithm"><a href="#RaymarchAlgorithm">RaymarchAlgorithm</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type RaymarchAlgorithm</code></pre><h1>Supertype Hierarchy</h1><pre><code>RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="RealVector"><a href="#RealVector">RealVector</a></div><div class="doc-content"><pre><code>AbstractArray{T,N}</code></pre><p>Supertype for <code>N</code>-dimensional arrays (or array-like types) with elements of type <code>T</code>. <a href="@ref"><code>Array</code></a> and other types are subtypes of this. See the manual section on the <a href="@ref man-interface-array"><code>AbstractArray</code> interface</a>.</p><p>See also: <a href="@ref"><code>AbstractVector</code></a>, <a href="@ref"><code>AbstractMatrix</code></a>, <a href="@ref"><code>eltype</code></a>, <a href="@ref"><code>ndims</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="Record"><a href="#Record">Record</a></div><div class="doc-content"><pre><code>Record(func, figlike, [iter]; kw_args...)</code></pre><p>Check <a href="@ref"><code>Makie.record</code></a> for documentation.</p></div></div><div class="docstring"><div class="doc-header" id="RecordEvents"><a href="#RecordEvents">RecordEvents</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct RecordEvents</code></pre><h1>Fields</h1><pre><code>scene :: Scene
path  :: String</code></pre></div></div><div class="docstring"><div class="doc-header" id="Rect"><a href="#Rect">Rect</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect2"><a href="#Rect2">Rect2</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect2f"><a href="#Rect2f">Rect2f</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect2i"><a href="#Rect2i">Rect2i</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect3"><a href="#Rect3">Rect3</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect3f"><a href="#Rect3f">Rect3f</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect3i"><a href="#Rect3i">Rect3i</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rectf"><a href="#Rectf">Rectf</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Recti"><a href="#Recti">Recti</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Relative"><a href="#Relative">Relative</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Relative</code></pre><h1>Fields</h1><pre><code>x :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="Reverse"><a href="#Reverse">Reverse</a></div><div class="doc-content"><p>Reverses the attribute T upon conversion</p></div></div><div class="docstring"><div class="doc-header" id="ReversibleScale"><a href="#ReversibleScale">ReversibleScale</a></div><div class="doc-content"><pre><code>ReversibleScale</code></pre><p>Custom scale struct, taking a forward and inverse arbitrary scale function.</p><h2>Fields</h2><ul><li><p><code>forward::Function</code>: forward transformation (e.g. <code>log10</code>)</p></li></ul><ul><li><p><code>inverse::Function</code>: inverse transformation (e.g. <code>exp10</code> for <code>log10</code> such that inverse â forward â¡ identity)</p></li></ul><ul><li><p><code>limits::Tuple{Float32, Float32}</code>: default limits (optional)</p></li></ul><ul><li><p><code>interval::IntervalSets.AbstractInterval</code>: valid limits interval (optional)</p></li></ul><ul><li><p><code>name::Symbol</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Right"><a href="#Right">Right</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Right</code></pre><h1>Supertype Hierarchy</h1><pre><code>Right &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="SSAO"><a href="#SSAO">SSAO</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct SSAO</code></pre><h1>Fields</h1><pre><code>radius :: Observable{Float32}
bias   :: Observable{Float32}
blur   :: Observable{Int32}</code></pre></div></div><div class="docstring"><div class="doc-header" id="Scatter"><a href="#Scatter">Scatter</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="ScatterLines"><a href="#ScatterLines">ScatterLines</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Scene"><a href="#Scene">Scene</a></div><div class="doc-content"><pre><code>Scene TODO document this</code></pre><h2>Constructors</h2><h2>Fields</h2><ul><li><p><code>parent</code>: The parent of the Scene; if it is a top-level Scene, <code>parent == nothing</code>.</p></li><li><p><code>events</code>: <a href="@ref"><code>Events</code></a> associated with the Scene.</p></li><li><p><code>px_area</code>: The current pixel area of the Scene.</p></li><li><p><code>clear</code>: Whether the scene should be cleared.</p></li><li><p><code>camera</code>: The <code>Camera</code> associated with the Scene.</p></li><li><p><code>camera_controls</code>: The controls for the camera of the Scene.</p></li><li><p><code>transformation</code>: The <a href="@ref"><code>Transformation</code></a> of the Scene.</p></li><li><p><code>plots</code>: The plots contained in the Scene.</p></li><li><p><code>theme</code></p></li><li><p><code>children</code>: Children of the Scene inherit its transformation.</p></li><li><p><code>current_screens</code>: The Screens which the Scene is displayed to.</p></li></ul><ul><li><p><code>backgroundcolor</code></p></li><li><p><code>visible</code></p></li><li><p><code>ssao</code></p></li><li><p><code>lights</code></p></li><li><p><code>deregister_callbacks</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="SceneLike"><a href="#SceneLike">SceneLike</a></div><div class="doc-content"><pre><code>Union{Types...}</code></pre><p>A type union is an abstract type which includes all instances of any of its argument types. The empty union <a href="@ref"><code>Union{}</code></a> is the bottom type of Julia.</p><h1>Examples</h1><pre><code class="language-jldoctest">julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 isa IntOrString
true

julia&gt; "Hello!" isa IntOrString
true

julia&gt; 1.0 isa IntOrString
false</code></pre></div></div><div class="docstring"><div class="doc-header" id="SceneSpace"><a href="#SceneSpace">SceneSpace</a></div><div class="doc-content"><p>Unit space of the scene it's displayed on. Also referred to as data units</p></div></div><div class="docstring"><div class="doc-header" id="ScrollEvent"><a href="#ScrollEvent">ScrollEvent</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct ScrollEvent</code></pre><h1>Fields</h1><pre><code>x :: Float32
y :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="Series"><a href="#Series">Series</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Slider"><a href="#Slider">Slider</a></div><div class="doc-content"><p><strong><code>Slider &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Slider.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>color_active</code>, <code>color_active_dimmed</code>, <code>color_inactive</code>, <code>halign</code>, <code>height</code>, <code>horizontal</code>, <code>linewidth</code>, <code>range</code>, <code>snap</code>, <code>startvalue</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>value</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="SliderGrid"><a href="#SliderGrid">SliderGrid</a></div><div class="doc-content"><p><strong><code>SliderGrid &lt;: Block</code></strong></p><p>A grid of horizontal <code>Slider</code>s, where each slider has one name label on the left, and a value label on the right.</p><p>Each <code>NamedTuple</code> you pass specifies one <code>Slider</code>. You always have to pass <code>range</code> and <code>label</code>, and optionally a <code>format</code> for the value label. Beyond that, you can set any keyword that <code>Slider</code> takes, such as <code>startvalue</code>.</p><p>The <code>format</code> keyword can be a <code>String</code> with Formatting.jl style, such as "{:.2f}Hz", or a function.</p><h2>Constructors</h2><pre><code class="language-julia">SliderGrid(fig_or_scene, nts::NamedTuple...; kwargs...)</code></pre><h2>Examples</h2><pre><code class="language-julia">sg = SliderGrid(fig[1, 1],
    (label = "Amplitude", range = 0:0.1:10, startvalue = 5),
    (label = "Frequency", range = 0:0.5:50, format = "{:.1f}Hz", startvalue = 10),
    (label = "Phase", range = 0:0.01:2pi,
        format = x -&gt; string(round(x/pi, digits = 2), "Ï"))
)</code></pre><p>Working with slider values:</p><pre><code class="language-julia">on(sg.sliders[1].value) do val
    # do something with `val`
end</code></pre><p><strong>Attributes</strong></p><p>(type <code>?SliderGrid.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>halign</code>, <code>height</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>valign</code>, <code>value_column_width</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Sphere"><a href="#Sphere">Sphere</a></div><div class="doc-content"><pre><code>HyperSphere{N, T}</code></pre><p>A <code>HyperSphere</code> is a generalization of a sphere into N-dimensions. A <code>center</code> and radius, <code>r</code>, must be specified.</p></div></div><div class="docstring"><div class="doc-header" id="Spy"><a href="#Spy">Spy</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Stairs"><a href="#Stairs">Stairs</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Stem"><a href="#Stem">Stem</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="StepHist"><a href="#StepHist">StepHist</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Stepper"><a href="#Stepper">Stepper</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Stepper</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "Stepper" from Makie:
 [1] Stepper(figlike::Union{Figure, Makie.FigureAxisPlot, Scene}; backend, format, visible, connect, screen_kw...)
     @ ~/work/Makie.jl/Makie.jl/src/recording.jl:29
 [2] Stepper(figlike::Union{Figure, Makie.FigureAxisPlot, Scene}, path::String; kw...)
     @ ~/work/Makie.jl/Makie.jl/src/recording.jl:41
 [3] Stepper(figlike::Union{Figure, Makie.FigureAxisPlot, Scene}, path::String, step::Int64; format, backend, visible, connect, screen_kw...)
     @ ~/work/Makie.jl/Makie.jl/src/recording.jl:35</code></pre></div></div><div class="docstring"><div class="doc-header" id="StreamPlot"><a href="#StreamPlot">StreamPlot</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Surface"><a href="#Surface">Surface</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="SurfaceLike"><a href="#SurfaceLike">SurfaceLike</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type SurfaceLike</code></pre><h1>Subtypes</h1><pre><code>ContinuousSurface
DiscreteSurface</code></pre><h1>Supertype Hierarchy</h1><pre><code>SurfaceLike &lt;: ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Text"><a href="#Text">Text</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Textbox"><a href="#Textbox">Textbox</a></div><div class="doc-content"><p><strong><code>Textbox &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Textbox.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>alignmode</code>, <code>bordercolor</code>, <code>bordercolor_focused</code>, <code>bordercolor_focused_invalid</code>, <code>bordercolor_hover</code>, <code>borderwidth</code>, <code>boxcolor</code>, <code>boxcolor_focused</code>, <code>boxcolor_focused_invalid</code>, <code>boxcolor_hover</code>, <code>cornerradius</code>, <code>cornersegments</code>, <code>cursorcolor</code>, <code>defocus_on_submit</code>, <code>displayed_string</code>, <code>focused</code>, <code>font</code>, <code>fontsize</code>, <code>halign</code>, <code>height</code>, <code>placeholder</code>, <code>reset_on_defocus</code>, <code>restriction</code>, <code>stored_string</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>textcolor</code>, <code>textcolor_placeholder</code>, <code>textpadding</code>, <code>validator</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Theme"><a href="#Theme">Theme</a></div><div class="doc-content"><p>Main structure for holding attributes, for theming plots etc! Will turn all values into observables, so that they can be updated.</p></div></div><div class="docstring"><div class="doc-header" id="TimeSeries"><a href="#TimeSeries">TimeSeries</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Toggle"><a href="#Toggle">Toggle</a></div><div class="doc-content"><p><strong><code>Toggle &lt;: Block</code></strong></p><p><strong>Attributes</strong></p><p>(type <code>?Toggle.x</code> in the REPL for more information about attribute <code>x</code>)</p><p><code>active</code>, <code>alignmode</code>, <code>buttoncolor</code>, <code>cornersegments</code>, <code>framecolor_active</code>, <code>framecolor_inactive</code>, <code>halign</code>, <code>height</code>, <code>rimfraction</code>, <code>tellheight</code>, <code>tellwidth</code>, <code>toggleduration</code>, <code>valign</code>, <code>width</code></p></div></div><div class="docstring"><div class="doc-header" id="Tooltip"><a href="#Tooltip">Tooltip</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Top"><a href="#Top">Top</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Top</code></pre><h1>Supertype Hierarchy</h1><pre><code>Top &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="TopLeft"><a href="#TopLeft">TopLeft</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct TopLeft</code></pre><h1>Supertype Hierarchy</h1><pre><code>TopLeft &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="TopRight"><a href="#TopRight">TopRight</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct TopRight</code></pre><h1>Supertype Hierarchy</h1><pre><code>TopRight &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Transformation"><a href="#Transformation">Transformation</a></div><div class="doc-content"><p>Holds the transformations for Scenes.</p><h2>Fields</h2><ul><li><p><code>parent::Base.RefValue{Transformation}</code></p></li><li><p><code>translation::Observable{Vec{3, Float32}}</code></p></li><li><p><code>scale::Observable{Vec{3, Float32}}</code></p></li><li><p><code>rotation::Observable{Quaternionf}</code></p></li><li><p><code>model::Observable{StaticArraysCore.SMatrix{4, 4, Float32, 16}}</code></p></li><li><p><code>transform_func::Observable{Any}</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Tricontourf"><a href="#Tricontourf">Tricontourf</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Triplot"><a href="#Triplot">Triplot</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Unit"><a href="#Unit">Unit</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type Unit{T}</code></pre><h1>Subtypes</h1><pre><code>Makie.DeviceIndependentPixel{T&lt;:Number}
Makie.Millimeter{T}
Pixel{T}
SceneSpace{T}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Unit{T} &lt;: Number &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VLines"><a href="#VLines">VLines</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VSpan"><a href="#VSpan">VSpan</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec"><a href="#Vec">Vec</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec2"><a href="#Vec2">Vec2</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec2f"><a href="#Vec2f">Vec2f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec3"><a href="#Vec3">Vec3</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec3f"><a href="#Vec3f">Vec3f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec4"><a href="#Vec4">Vec4</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec4f"><a href="#Vec4f">Vec4f</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Vec{S, T}</code></pre><h1>Fields</h1><pre><code>data :: Tuple{Vararg{T, S}}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Vec{S, T} &lt;: StaticArraysCore.StaticArray{Tuple{S}, T, 1} &lt;: AbstractArray{T, 1} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VecTypes"><a href="#VecTypes">VecTypes</a></div><div class="doc-content"><pre><code>Union{Types...}</code></pre><p>A type union is an abstract type which includes all instances of any of its argument types. The empty union <a href="@ref"><code>Union{}</code></a> is the bottom type of Julia.</p><h1>Examples</h1><pre><code class="language-jldoctest">julia&gt; IntOrString = Union{Int,AbstractString}
Union{Int64, AbstractString}

julia&gt; 1 isa IntOrString
true

julia&gt; "Hello!" isa IntOrString
true

julia&gt; 1.0 isa IntOrString
false</code></pre></div></div><div class="docstring"><div class="doc-header" id="VideoStream"><a href="#VideoStream">VideoStream</a></div><div class="doc-content"><pre><code>VideoStream(fig::FigureLike;
        format="mp4", framerate=24, compression=nothing, profile=nothing, pixel_format=nothing, loop=nothing,
        loglevel="quiet", visible=false, connect=false, backend=current_backend(),
        screen_config...)</code></pre><p>Returns a <code>VideoStream</code> which can pipe new frames into the ffmpeg process with few allocations via <a href="@ref"><code>recordframe!(stream)</code></a>. When done, use <a href="@ref"><code>save(path, stream)</code></a> to write the video out to a file.</p><h1>Arguments</h1><h2>Video options</h2><ul><li><p><code>format = "mkv"</code>: The format of the video. If a path is present, will be inferred form the file extension.   Can be one of the following:</p><ul><li><p><code>"mkv"</code>  (open standard, the default)</p></li><li><p><code>"mp4"</code>  (good for Web, most supported format)</p></li><li><p><code>"webm"</code> (smallest file size)</p></li><li><p><code>"gif"</code>  (largest file size for the same quality)</p></li></ul><p><code>mp4</code> and <code>mk4</code> are marginally bigger than <code>webm</code>. <code>gif</code>s can be significantly (as much as   6x) larger with worse quality (due to the limited color palette) and only should be used   as a last resort, for playing in a context where videos aren't supported.</p></li><li><p><code>framerate = 24</code>: The target framerate.</p></li><li><p><code>compression = 20</code>: Controls the video compression via <code>ffmpeg</code>'s <code>-crf</code> option, with   smaller numbers giving higher quality and larger file sizes (lower compression), and and   higher numbers giving lower quality and smaller file sizes (higher compression). The   minimum value is <code>0</code> (lossless encoding).</p><ul><li><p>For <code>mp4</code>, <code>51</code> is the maximum. Note that <code>compression = 0</code> only works with <code>mp4</code> if</p></li></ul><p><code>profile = high444</code>.</p><ul><li><p>For <code>webm</code>, <code>63</code> is the maximum.</p></li><li><p><code>compression</code> has no effect on <code>mkv</code> and <code>gif</code> outputs.</p></li></ul></li><li><p><code>profile = "high422"</code>: A ffmpeg compatible profile. Currently only applies to <code>mp4</code>. If</p></li></ul><p>you have issues playing a video, try <code>profile = "high"</code> or <code>profile = "main"</code>.</p><ul><li><p><code>pixel_format = "yuv420p"</code>: A ffmpeg compatible pixel format (<code>-pix_fmt</code>). Currently only</p></li></ul><p>applies to <code>mp4</code>. Defaults to <code>yuv444p</code> for <code>profile = high444</code>.</p><ul><li><p><code>loop = 0</code>: Number of times the video is repeated, for a <code>gif</code>. Defaults to <code>0</code>, which</p></li></ul><p>means infinite looping. A value of <code>-1</code> turns off looping, and a value of <code>n &gt; 0</code> and above means <code>n</code> repetitions (i.e. the video is played <code>n+1</code> times).</p><pre><code>!!! warning
`profile` and `pixel_format` are only used when `format` is `"mp4"`; a warning will be issued if `format`
is not `"mp4"` and those two arguments are not `nothing`. Similarly, `compression` is only
valid when `format` is `"mp4"` or `"webm"`, and `loop` is only valid when `format` is `"gif"`.</code></pre><h2>Backend options</h2><ul><li><p><code>backend=current_backend()</code>: backend used to record frames</p></li><li><p><code>visible=false</code>: make window visible or not</p></li><li><p><code>connect=false</code>: connect window events or not</p></li><li><p><code>screen_config...</code>: See <code>?Backend.Screen</code> or <code>Base.doc(Backend.Screen)</code> for applicable options that can be passed and forwarded to the backend.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Violin"><a href="#Violin">Violin</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Volume"><a href="#Volume">Volume</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VolumeLike"><a href="#VolumeLike">VolumeLike</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct VolumeLike</code></pre><h1>Supertype Hierarchy</h1><pre><code>VolumeLike &lt;: ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VolumeSlices"><a href="#VolumeSlices">VolumeSlices</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Voronoiplot"><a href="#Voronoiplot">Voronoiplot</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Waterfall"><a href="#Waterfall">Waterfall</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="WilkinsonTicks"><a href="#WilkinsonTicks">WilkinsonTicks</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct WilkinsonTicks</code></pre><h1>Fields</h1><pre><code>k_ideal            :: Int64
k_min              :: Int64
k_max              :: Int64
Q                  :: Vector{Tuple{Float64, Float64}}
granularity_weight :: Float64
simplicity_weight  :: Float64
coverage_weight    :: Float64
niceness_weight    :: Float64
min_px_dist        :: Float64</code></pre></div></div><div class="docstring"><div class="doc-header" id="Wireframe"><a href="#Wireframe">Wireframe</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Combined{Typ, T}</code></pre><h1>Fields</h1><pre><code>parent               :: Union{AbstractScene, MakieCore.ScenePlot}
transformation       :: MakieCore.Transformable
attributes           :: Attributes
input_args           :: Tuple
converted            :: Tuple
plots                :: Vector{AbstractPlot}
deregister_callbacks :: Vector{Observables.ObserverFunction}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Combined{Typ, T} &lt;: MakieCore.ScenePlot{Typ} &lt;: AbstractPlot{Typ} &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="abline!"><a href="#abline!">abline!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.abline!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "abline!" from Makie:
 [1] abline!(args...; kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/ablines.jl:46</code></pre></div></div><div class="docstring"><div class="doc-header" id="ablines"><a href="#ablines">ablines</a></div><div class="doc-content"><pre><code>ablines(intercepts, slopes; attrs...)</code></pre><p>Creates a line defined by <code>f(x) = slope * x + intercept</code> crossing a whole <code>Scene</code> with 2D projection at its current limits. You can pass one or multiple intercepts or slopes.</p><p>All style attributes are the same as for <code>LineSegments</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ablines!"><a href="#ablines!">ablines!</a></div><div class="doc-content"><pre><code>ablines(intercepts, slopes; attrs...)</code></pre><p>Creates a line defined by <code>f(x) = slope * x + intercept</code> crossing a whole <code>Scene</code> with 2D projection at its current limits. You can pass one or multiple intercepts or slopes.</p><p>All style attributes are the same as for <code>LineSegments</code>.</p></div></div><div class="docstring"><div class="doc-header" id="activate_interaction!"><a href="#activate_interaction!">activate_interaction!</a></div><div class="doc-content"><pre><code>activate_interaction!(parent, name::Symbol)</code></pre><p>Activate the interaction named <code>name</code> registered in <code>parent</code>.</p></div></div><div class="docstring"><div class="doc-header" id="addmouseevents!"><a href="#addmouseevents!">addmouseevents!</a></div><div class="doc-content"><pre><code>addmouseevents!(scene, elements...)</code></pre><p>Returns a <code>MouseEventHandle</code> with an observable inside which is triggered by all mouse interactions with the <code>scene</code> and optionally restricted to all given plot objects in <code>elements</code>.</p><p>To react to mouse events, use the onmouse... handlers.</p><p>Example:</p><pre><code>mouseevents = addmouseevents!(scene, scatterplot)

onmouseleftclick(mouseevents) do event
    # do something with the mouseevent
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="annotations"><a href="#annotations">annotations</a></div><div class="doc-content"><pre><code>annotations(strings::Vector{String}, positions::Vector{Point})</code></pre><p>Plots an array of texts at each position in <code>positions</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.annotations}</code> are: </p><pre><code>  align            (:left, :bottom)
  alpha            1.0
  color            :black
  colormap         :viridis
  colorrange       MakieCore.Automatic()
  colorscale       identity
  depth_shift      0.0f0
  font             :regular
  fonts            Attributes with 4 entries:
  bold =&gt; TeX Gyre Heros Makie Bold
  bold_italic =&gt; TeX Gyre Heros Makie Bold Italic
  italic =&gt; TeX Gyre Heros Makie Italic
  regular =&gt; TeX Gyre Heros Makie
  fontsize         16
  highclip         MakieCore.Automatic()
  inspectable      true
  justification    MakieCore.Automatic()
  lineheight       1.0
  lowclip          MakieCore.Automatic()
  markerspace      :pixel
  nan_color        :transparent
  offset           (0.0, 0.0)
  overdraw         false
  position         (0.0, 0.0)
  rotation         0.0
  space            :data
  ssao             false
  strokecolor      (:black, 0.0)
  strokewidth      0
  transparency     false
  visible          true
  word_wrap_width  -1</code></pre></div></div><div class="docstring"><div class="doc-header" id="annotations!"><a href="#annotations!">annotations!</a></div><div class="doc-content"><pre><code>annotations(strings::Vector{String}, positions::Vector{Point})</code></pre><p>Plots an array of texts at each position in <code>positions</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.annotations!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="arc"><a href="#arc">arc</a></div><div class="doc-content"><pre><code>arc(origin, radius, start_angle, stop_angle; kwargs...)</code></pre><p>This function plots a circular arc, centered at <code>origin</code> with radius <code>radius</code>, from <code>start_angle</code> to <code>stop_angle</code>. <code>origin</code> must be a coordinate in 2 dimensions (i.e., a <code>Point2</code>); the rest of the arguments must be <code>&lt;: Number</code>.</p><p>Examples:</p><p><code>arc(Point2f(0), 1, 0.0, Ï)</code><code>arc(Point2f(1, 2), 0.3. Ï, -Ï)</code></p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.arc}</code> are: </p><pre><code>  alpha           1.0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  cycle           [:color]
  depth_shift     0.0f0
  highclip        MakieCore.Automatic()
  inspectable     true
  linestyle       "nothing"
  linewidth       1.5
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  resolution      361
  space           :data
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="arc!"><a href="#arc!">arc!</a></div><div class="doc-content"><pre><code>arc(origin, radius, start_angle, stop_angle; kwargs...)</code></pre><p>This function plots a circular arc, centered at <code>origin</code> with radius <code>radius</code>, from <code>start_angle</code> to <code>stop_angle</code>. <code>origin</code> must be a coordinate in 2 dimensions (i.e., a <code>Point2</code>); the rest of the arguments must be <code>&lt;: Number</code>.</p><p>Examples:</p><p><code>arc(Point2f(0), 1, 0.0, Ï)</code><code>arc(Point2f(1, 2), 0.3. Ï, -Ï)</code></p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.arc!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="arrows"><a href="#arrows">arrows</a></div><div class="doc-content"><pre><code>arrows(points, directions; kwargs...)
arrows(x, y, u, v)
arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)
arrows(x, y, z, u, v, w)
arrows(x, y, [z], f::Function)</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each 'row' is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p><p>If a <code>Function</code> is provided in place of <code>u, v, [w]</code>, then it must accept a <code>Point</code> as input, and return an appropriately dimensioned <code>Point</code>, <code>Vec</code>, or other array-like output.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Arrows</code> are: </p><pre><code>  align           :origin
  alpha           1.0
  arrowcolor      MakieCore.Automatic()
  arrowhead       MakieCore.Automatic()
  arrowsize       MakieCore.Automatic()
  arrowtail       MakieCore.Automatic()
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  depth_shift     0.0f0
  diffuse         0.4
  highclip        MakieCore.Automatic()
  inspectable     true
  lengthscale     1.0f0
  linecolor       MakieCore.Automatic()
  linestyle       "nothing"
  linewidth       MakieCore.Automatic()
  lowclip         MakieCore.Automatic()
  markerspace     :pixel
  nan_color       :transparent
  normalize       false
  overdraw        false
  quality         32
  shininess       32.0f0
  space           :data
  specular        0.2
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="arrows!"><a href="#arrows!">arrows!</a></div><div class="doc-content"><p>See <a href="@ref"><code>arrows</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="assetpath"><a href="#assetpath">assetpath</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.assetpath</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "assetpath" from Makie:
 [1] assetpath(files...)
     @ ~/work/Makie.jl/Makie.jl/src/Makie.jl:98</code></pre></div></div><div class="docstring"><div class="doc-header" id="attributes"><a href="#attributes">attributes</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.attributes</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "attributes" from MakieCore:
 [1] attributes(x::AbstractPlot)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/attributes.jl:35
 [2] attributes(x::Attributes)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/attributes.jl:34</code></pre></div></div><div class="docstring"><div class="doc-header" id="autolimits!"><a href="#autolimits!">autolimits!</a></div><div class="doc-content"><pre><code>autolimits!(la::Axis)</code></pre><p>Reset manually specified limits of <code>la</code> to an automatically determined rectangle, that depends on the data limits of all plot objects in the axis, as well as the autolimit margins for x and y axis.</p><pre><code>autolimits!(ax::PolarAxis[, unlock_zoom = true])</code></pre><p>Calling this tells the PolarAxis to derive limits freely from the plotted data, which allows rmin &gt; 0 and thetalimits spanning less than a full circle. If <code>unlock_zoom = true</code> this also unlocks zooming in r and theta direction and allows for translations in r direction.</p></div></div><div class="docstring"><div class="doc-header" id="available_gradients"><a href="#available_gradients">available_gradients</a></div><div class="doc-content"><pre><code>available_gradients()</code></pre><p>Prints all available gradient names.</p></div></div><div class="docstring"><div class="doc-header" id="axis3d"><a href="#axis3d">axis3d</a></div><div class="doc-content"><pre><code class="language-julia">axis3d(args; attributes...)
</code></pre><p>Plots a 3-dimensional OldAxis.</p><h2>Attributes</h2><p>OldAxis attributes and their defaults for <code>Combined{Makie.axis3d}</code> are: </p><pre><code>    showaxis: (true, true, true)
    visible: true
    ticks: 
        rotation: (-0.7071067811865475 + -0.0im + -0.0jm - 0.7071067811865476km, -4.371139e-8 + 0.0im + 0.0jm + 1.0km, -3.090861907263062e-8 + 3.090861907263061e-8im + 0.7071067811865475jm + 0.7071067811865476km)
        font: (:regular, :regular, :regular)
        ranges_labels: (MakieCore.Automatic(), MakieCore.Automatic())
        formatter: plain
        textcolor: (RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0))
        fontsize: (5, 5, 5)
        align: ((:left, :center), (:right, :center), (:right, :center))
        gap: 3
    fonts: 
        bold: TeX Gyre Heros Makie Bold
        italic: TeX Gyre Heros Makie Italic
        bold_italic: TeX Gyre Heros Makie Bold Italic
        regular: TeX Gyre Heros Makie
    names: 
        axisnames: ("x", "y", "z")
        rotation: (-0.7071067811865475 + -0.0im + -0.0jm - 0.7071067811865476km, -4.371139e-8 + 0.0im + 0.0jm + 1.0km, -3.090861907263062e-8 + 3.090861907263061e-8im + 0.7071067811865475jm + 0.7071067811865476km)
        font: (:regular, :regular, :regular)
        textcolor: (:black, :black, :black)
        fontsize: (6.0, 6.0, 6.0)
        align: ((:left, :center), (:right, :center), (:right, :center))
        gap: 3
    scale: Float32[1.0, 1.0, 1.0]
    showgrid: (true, true, true)
    padding: 0.1
    frame: 
        axiscolor: (:black, :black, :black)
        axislinewidth: (1.5, 1.5, 1.5)
        linewidth: (1, 1, 1)
        linecolor: (RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0))
    inspectable: false
    showticks: (true, true, true)</code></pre></div></div><div class="docstring"><div class="doc-header" id="axis3d!"><a href="#axis3d!">axis3d!</a></div><div class="doc-content"><pre><code class="language-julia">axis3d!(args; attributes...)
</code></pre><p>Plots a 3-dimensional OldAxis.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.axis3d!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="axislegend"><a href="#axislegend">axislegend</a></div><div class="doc-content"><pre><code>axislegend(ax, args...; position = :rt, kwargs...)
axislegend(ax, args...; position = (1, 1), kwargs...)
axislegend(ax = current_axis(); kwargs...)
axislegend(title::AbstractString; kwargs...)</code></pre><p>Create a legend that sits inside an Axis's plot area.</p><p>The position can be a Symbol where the first letter controls the horizontal alignment and can be l, r or c, and the second letter controls the vertical alignment and can be t, b or c. Or it can be a tuple where the first element is set as the Legend's halign and the second element as its valign.</p><p>With the keywords merge and unique you can control how plot objects with the same labels are treated. If merge is true, all plot objects with the same label will be layered on top of each other into one legend entry. If unique is true, all plot objects with the same plot type and label will be reduced to one occurrence.</p></div></div><div class="docstring"><div class="doc-header" id="band"><a href="#band">band</a></div><div class="doc-content"><pre><code>band(x, ylower, yupper; kwargs...)
band(lower, upper; kwargs...)</code></pre><p>Plots a band from <code>ylower</code> to <code>yupper</code> along <code>x</code>. The form <code>band(lower, upper)</code> plots a <a href="https://en.wikipedia.org/wiki/Ruled_surface">ruled surface</a> between the points in <code>lower</code> and <code>upper</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.band}</code> are: </p><pre><code>  alpha           1.0
  backlight       0.0f0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  cycle           [:color =&gt; :patchcolor]
  depth_shift     0.0f0
  diffuse         0.4
  highclip        MakieCore.Automatic()
  inspectable     true
  interpolate     true
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  shading         false
  shininess       32.0f0
  space           :data
  specular        0.2
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="band!"><a href="#band!">band!</a></div><div class="doc-content"><pre><code>band(x, ylower, yupper; kwargs...)
band(lower, upper; kwargs...)</code></pre><p>Plots a band from <code>ylower</code> to <code>yupper</code> along <code>x</code>. The form <code>band(lower, upper)</code> plots a <a href="https://en.wikipedia.org/wiki/Ruled_surface">ruled surface</a> between the points in <code>lower</code> and <code>upper</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.band!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="barplot"><a href="#barplot">barplot</a></div><div class="doc-content"><pre><code>barplot(x, y; kwargs...)</code></pre><p>Plots a barplot; <code>y</code> defines the height. <code>x</code> and <code>y</code> should be 1 dimensional. Bar width is determined by the attribute <code>width</code>, shrunk by <code>gap</code> in the following way: <code>width -&gt; width * (1 - gap)</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.barplot}</code> are: </p><pre><code>  alpha                  1.0
  bar_labels             "nothing"
  color                  RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  color_over_background  MakieCore.Automatic()
  color_over_bar         MakieCore.Automatic()
  colormap               :viridis
  colorrange             MakieCore.Automatic()
  colorscale             identity
  cycle                  [:color =&gt; :patchcolor]
  direction              :y
  dodge                  MakieCore.Automatic()
  dodge_gap              0.03
  fillto                 MakieCore.Automatic()
  flip_labels_at         Inf
  gap                    0.2
  highclip               MakieCore.Automatic()
  inspectable            true
  label_align            MakieCore.Automatic()
  label_color            :black
  label_font             :regular
  label_formatter        Makie.bar_label_formatter
  label_offset           5
  label_rotation         0.0
  label_size             16
  lowclip                MakieCore.Automatic()
  marker                 GeometryBasics.HyperRectangle
  n_dodge                MakieCore.Automatic()
  nan_color              :transparent
  offset                 0.0
  stack                  MakieCore.Automatic()
  strokecolor            :black
  strokewidth            0
  transparency           false
  visible                true
  width                  MakieCore.Automatic()</code></pre></div></div><div class="docstring"><div class="doc-header" id="barplot!"><a href="#barplot!">barplot!</a></div><div class="doc-content"><pre><code>barplot(x, y; kwargs...)</code></pre><p>Plots a barplot; <code>y</code> defines the height. <code>x</code> and <code>y</code> should be 1 dimensional. Bar width is determined by the attribute <code>width</code>, shrunk by <code>gap</code> in the following way: <code>width -&gt; width * (1 - gap)</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.barplot!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="bottom"><a href="#bottom">bottom</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.bottom</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "bottom" from Makie:
 [1] bottom(rect::Rect2)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:4</code></pre></div></div><div class="docstring"><div class="doc-header" id="boundingbox"><a href="#boundingbox">boundingbox</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.boundingbox</code> is a <code>Function</code>.</p><pre><code># 8 methods for generic function "boundingbox" from Makie:
 [1] boundingbox(glyphcollection::Makie.GlyphCollection, position::Point{3, Float32}, rotation::Quaternion)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:51
 [2] boundingbox(glyphcollection::Makie.GlyphCollection, rotation::Quaternion)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:55
 [3] boundingbox(layouts::AbstractArray{&lt;:Makie.GlyphCollection}, positions, rotations)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:76
 [4] boundingbox(x::MakieCore.Text{&lt;:Tuple{var"#s36"} where var"#s36"&lt;:Makie.GlyphCollection})
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:93
 [5] boundingbox(x::MakieCore.Text{&lt;:Tuple{var"#s36"} where var"#s36"&lt;:(AbstractArray{&lt;:Makie.GlyphCollection})})
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:104
 [6] boundingbox(plot::MakieCore.Text)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:115
 [7] boundingbox(x)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:6
 [8] boundingbox(x, exclude)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:6</code></pre></div></div><div class="docstring"><div class="doc-header" id="boxplot"><a href="#boxplot">boxplot</a></div><div class="doc-content"><pre><code>boxplot(x, y; kwargs...)</code></pre><p>Draw a Tukey style boxplot. The boxplot has 3 components:</p><ul><li><p>a <code>crossbar</code> spanning the interquartile (IQR) range with a midline marking the   median</p></li><li><p>an <code>errorbar</code> whose whiskers span <code>range * iqr</code></p></li><li><p>points marking outliers, that is, data outside the whiskers</p></li></ul><h1>Arguments</h1><ul><li><p><code>x</code>: positions of the categories</p></li><li><p><code>y</code>: variables within the boxes</p></li></ul><h1>Keywords</h1><ul><li><p><code>weights</code>: vector of statistical weights (length of data). By default, each observation has weight <code>1</code>.</p></li><li><p><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=1</code>: width of the box before shrinking</p></li><li><p><code>gap=0.2</code>: shrinking factor, <code>width -&gt; width * (1 - gap)</code></p></li><li><p><code>show_notch=false</code>: draw the notch</p></li><li><p><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</p></li><li><p><code>show_median=true</code>: show median as midline</p></li><li><p><code>range</code>: multiple of IQR controlling whisker length</p></li><li><p><code>whiskerwidth</code>: multiplier of <code>width</code> for width of T's on whiskers, or   <code>:match</code> to match <code>width</code></p></li><li><p><code>show_outliers</code>: show outliers as points</p></li><li><p><code>dodge</code>: vector of <code>Integer</code> (length of data) of grouping variable to create multiple side-by-side boxes at the same <code>x</code> position</p></li><li><p><code>dodge_gap = 0.03</code>: spacing between dodged boxes</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="boxplot!"><a href="#boxplot!">boxplot!</a></div><div class="doc-content"><pre><code>boxplot(x, y; kwargs...)</code></pre><p>Draw a Tukey style boxplot. The boxplot has 3 components:</p><ul><li><p>a <code>crossbar</code> spanning the interquartile (IQR) range with a midline marking the   median</p></li><li><p>an <code>errorbar</code> whose whiskers span <code>range * iqr</code></p></li><li><p>points marking outliers, that is, data outside the whiskers</p></li></ul><h1>Arguments</h1><ul><li><p><code>x</code>: positions of the categories</p></li><li><p><code>y</code>: variables within the boxes</p></li></ul><h1>Keywords</h1><ul><li><p><code>weights</code>: vector of statistical weights (length of data). By default, each observation has weight <code>1</code>.</p></li><li><p><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=1</code>: width of the box before shrinking</p></li><li><p><code>gap=0.2</code>: shrinking factor, <code>width -&gt; width * (1 - gap)</code></p></li><li><p><code>show_notch=false</code>: draw the notch</p></li><li><p><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</p></li><li><p><code>show_median=true</code>: show median as midline</p></li><li><p><code>range</code>: multiple of IQR controlling whisker length</p></li><li><p><code>whiskerwidth</code>: multiplier of <code>width</code> for width of T's on whiskers, or   <code>:match</code> to match <code>width</code></p></li><li><p><code>show_outliers</code>: show outliers as points</p></li><li><p><code>dodge</code>: vector of <code>Integer</code> (length of data) of grouping variable to create multiple side-by-side boxes at the same <code>x</code> position</p></li><li><p><code>dodge_gap = 0.03</code>: spacing between dodged boxes</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="bracket"><a href="#bracket">bracket</a></div><div class="doc-content"><pre><code>bracket(x1, y1, x2, y2; kwargs...)
bracket(x1s, y1s, x2s, y2s; kwargs...)
bracket(point1, point2; kwargs...)
bracket(vec_of_point_tuples; kwargs...)</code></pre><p>Draws a bracket between each pair of points (x1, y1) and (x2, y2) with a text label at the midpoint.</p><p>By default each label is rotated parallel to the line between the bracket points.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.bracket}</code> are: </p><pre><code>  align          (:center, :center)
  color          :black
  font           :regular
  fontsize       16
  justification  MakieCore.Automatic()
  linestyle      :solid
  linewidth      1.5
  offset         0
  orientation    :up
  rotation       MakieCore.Automatic()
  style          :curly
  text           ""
  textcolor      :black
  textoffset     MakieCore.Automatic()
  width          15</code></pre></div></div><div class="docstring"><div class="doc-header" id="bracket!"><a href="#bracket!">bracket!</a></div><div class="doc-content"><pre><code>bracket(x1, y1, x2, y2; kwargs...)
bracket(x1s, y1s, x2s, y2s; kwargs...)
bracket(point1, point2; kwargs...)
bracket(vec_of_point_tuples; kwargs...)</code></pre><p>Draws a bracket between each pair of points (x1, y1) and (x2, y2) with a text label at the midpoint.</p><p>By default each label is rotated parallel to the line between the bracket points.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.bracket!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="broadcast_foreach"><a href="#broadcast_foreach">broadcast_foreach</a></div><div class="doc-content"><pre><code>broadcast_foreach(f, args...)</code></pre><p>Like broadcast but for foreach. Doesn't care about shape and treats Tuples &amp;&amp; StaticVectors as scalars. This method is meant for broadcasting across attributes that can either have scalar or vector / array form. An example would be a collection of scatter markers that have different sizes but a single color. The length of an attribute is determined with <code>attr_broadcast_length</code> and elements are accessed with <code>attr_broadcast_getindex</code>.</p></div></div><div class="docstring"><div class="doc-header" id="cam2d"><a href="#cam2d">cam2d</a></div><div class="doc-content"><p>Creates a subscene with a pixel camera</p></div></div><div class="docstring"><div class="doc-header" id="cam2d!"><a href="#cam2d!">cam2d!</a></div><div class="doc-content"><pre><code>cam2d!(scene::SceneLike, kwargs...)</code></pre><p>Creates a 2D camera for the given Scene.</p></div></div><div class="docstring"><div class="doc-header" id="cam3d!"><a href="#cam3d!">cam3d!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.cam3d!</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "cam3d!" from Makie:
 [1] cam3d!(ax::LScene; kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/blocks/scene.jl:69
 [2] cam3d!(scene; zoom_shift_lookat, fixed_axis, kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/camera/camera3d.jl:229</code></pre></div></div><div class="docstring"><div class="doc-header" id="cam3d_cad!"><a href="#cam3d_cad!">cam3d_cad!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.cam3d_cad!</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "cam3d_cad!" from Makie:
 [1] cam3d_cad!(ax::LScene; kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/blocks/scene.jl:70
 [2] cam3d_cad!(scene; cad, zoom_shift_lookat, fixed_axis, kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/camera/camera3d.jl:232</code></pre></div></div><div class="docstring"><div class="doc-header" id="cam_relative!"><a href="#cam_relative!">cam_relative!</a></div><div class="doc-content"><pre><code>cam_relative!(scene)</code></pre><p>Creates a pixel-level camera for the <code>Scene</code>.  No controls!</p></div></div><div class="docstring"><div class="doc-header" id="camera"><a href="#camera">camera</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.camera</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "camera" from Makie:
 [1] camera(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:531
 [2] camera(scene::Union{AbstractScene, MakieCore.ScenePlot})
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:532
 [3] camera(x)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:530</code></pre></div></div><div class="docstring"><div class="doc-header" id="cameracontrols"><a href="#cameracontrols">cameracontrols</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.cameracontrols</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "cameracontrols" from Makie:
 [1] cameracontrols(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:535
 [2] cameracontrols(scene::Union{AbstractScene, MakieCore.ScenePlot})
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:536
 [3] cameracontrols(x)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:534</code></pre></div></div><div class="docstring"><div class="doc-header" id="cameracontrols!"><a href="#cameracontrols!">cameracontrols!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.cameracontrols!</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "cameracontrols!" from Makie:
 [1] cameracontrols!(scene::Scene, cam)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:538
 [2] cameracontrols!(scene::Union{AbstractScene, MakieCore.ScenePlot}, cam)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:542
 [3] cameracontrols!(x, cam)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:543</code></pre></div></div><div class="docstring"><div class="doc-header" id="campixel"><a href="#campixel">campixel</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.campixel</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "campixel" from Makie:
 [1] campixel(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:403</code></pre></div></div><div class="docstring"><div class="doc-header" id="campixel!"><a href="#campixel!">campixel!</a></div><div class="doc-content"><pre><code>campixel!(scene; nearclip=-1000f0, farclip=1000f0)</code></pre><p>Creates a pixel-level camera for the <code>Scene</code>.  No controls!</p></div></div><div class="docstring"><div class="doc-header" id="categorical_colors"><a href="#categorical_colors">categorical_colors</a></div><div class="doc-content"><pre><code>categorical_colors(colormaplike, categories::Integer)</code></pre><p>Creates categorical colors and tries to match <code>categories</code>. Will error if color scheme doesn't contain enough categories. Will drop the n last colors, if request less colors than contained in scheme.</p></div></div><div class="docstring"><div class="doc-header" id="center!"><a href="#center!">center!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.center!</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "center!" from Makie:
 [1] center!(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:579
 [2] center!(scene::Scene, padding)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:579
 [3] center!(scene::Scene, padding, exclude)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:579</code></pre></div></div><div class="docstring"><div class="doc-header" id="cgrad"><a href="#cgrad">cgrad</a></div><div class="doc-content"><pre><code>cgrad(colors, [values]; categorical = nothing, scale = nothing, rev = false, alpha = nothing)</code></pre><p>Construct a Colorgradient from <code>colors</code> and <code>values</code>.</p><p><code>colors</code> can be a symbol for ColorSchemes.jl <code>ColorScheme</code>s, a <code>ColorScheme</code>, a vector of colors, a <code>ColorGradient</code> or a <code>ColorPalette</code>. If <code>values</code> is an integer, it specifies the numbers of colors chosen equidistantly from the colorscheme specified by colors. Otherwise vectors are accepted. For continuous color gradients <code>values</code> indicate where between 0 and 1 the colors are positioned. For categorical color gradients <code>values</code> indicate where a color ends and where a new one begins between 0 and 1. 0 and 1 are added to <code>values</code> if not already present.</p><p>If <code>rev</code> is <code>true</code> colors are reversed. <code>scale</code> accepts the symbols <code>:log</code>, <code>:log10</code>, <code>:log2</code>, <code>:ln</code>, <code>:exp</code>, <code>:exp10</code> or functions. If <code>alpha</code> is set, it is applied to all colors.</p></div></div><div class="docstring"><div class="doc-header" id="colgap!"><a href="#colgap!">colgap!</a></div><div class="doc-content"><pre><code>colgap!(gl::GridLayout, i::Integer, s::Union{Fixed, Relative, Real})
colgap!(gl::GridLayout, s::Union{Fixed, Relative, Real})</code></pre><p>Set the gap between columns in <code>gl</code>.  The two-argument version sets all column gaps in <code>gl</code>.  The three-argument version sets the gap between columns <code>i</code> and <code>i+1</code>. Passing a real number to <code>s</code> has the same behaviour as passing <code>Fixed(s)</code>.</p><p>See also <a href="@ref">Fixed</a> and <a href="@ref">Relative</a>.</p></div></div><div class="docstring"><div class="doc-header" id="colorbuffer"><a href="#colorbuffer">colorbuffer</a></div><div class="doc-content"><pre><code>colorbuffer(scene, format::ImageStorageFormat = JuliaNative; update=true, backend=current_backend(), screen_config...)</code></pre><p>Returns the content of the given scene or screen rasterised to a Matrix of Colors. The return type is backend-dependent, but will be some form of RGB or RGBA.</p><ul><li><p><code>backend::Module</code>: A module which is a Makie backend.  For example, <code>backend = GLMakie</code>, <code>backend = CairoMakie</code>, etc.</p></li><li><p><code>format = JuliaNative</code> : Returns a buffer in the format of standard julia images (dims permuted and one reversed)</p></li><li><p><code>format = GLNative</code> : Returns a more efficient format buffer for GLMakie which can be directly                       used in FFMPEG without conversion</p></li><li><p><code>screen_config</code>: Backend dependend, look up via <code>?Backend.Screen</code>/<code>Base.doc(Backend.Screen)</code></p></li><li><p><code>update=true</code>: resets/updates limits. Set to false, if you want to preserver camera movements.</p></li></ul><pre><code>colorbuffer(ax::Axis; include_decorations=true, colorbuffer_kws...)</code></pre><p>Gets the colorbuffer of the <code>Axis</code> in <code>JuliaNative</code> image format. If <code>include_decorations=false</code>, only the inside of the axis is fetched.</p></div></div><div class="docstring"><div class="doc-header" id="colsize!"><a href="#colsize!">colsize!</a></div><div class="doc-content"><pre><code>colsize!(gl::GridLayout, i::Integer, s::Union{Aspect, Auto, Fixed, Relative, Real})</code></pre><p>Set the size of the <code>i</code>th column in <code>gl</code>, i.e., <code>gl[:, i]</code>. Passing a real number to <code>s</code> has the same behaviour as passing <code>Fixed(s)</code>.</p><p>See also <a href="@ref">Aspect</a>, <a href="@ref">Auto</a>, <a href="@ref">Fixed</a>, and <a href="@ref">Relative</a>.</p></div></div><div class="docstring"><div class="doc-header" id="connect!"><a href="#connect!">connect!</a></div><div class="doc-content"><pre><code>connect!(o1::AbstractObservable, o2::AbstractObservable)</code></pre><p>Forwards all updates from <code>o2</code> to <code>o1</code>.</p><p>See also <a href="@ref"><code>Observables.ObservablePair</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="connect_screen"><a href="#connect_screen">connect_screen</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.connect_screen</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "connect_screen" from Makie:
 [1] connect_screen(scene::Scene, screen)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/events.jl:14</code></pre></div></div><div class="docstring"><div class="doc-header" id="content"><a href="#content">content</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.content</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "content" from GridLayoutBase:
 [1] content(g::Union{GridPosition, GridSubposition})
     @ ~/.julia/packages/GridLayoutBase/kiave/src/gridlayout.jl:1673</code></pre></div></div><div class="docstring"><div class="doc-header" id="contents"><a href="#contents">contents</a></div><div class="doc-content"><pre><code>contents(gp::GridPosition; exact::Bool = false)</code></pre><p>Retrieve all objects placed in the <code>GridLayout</code> at the <code>Span</code> and <code>Side</code> stored in the <code>GridPosition</code><code>gp</code>. If <code>exact == true</code>, elements are only included if they match the <code>Span</code> exactly, otherwise they can also be contained within the spanned layout area.</p><pre><code>contents(g::GridLayout)</code></pre><p>Retrieve all objects placed in the <code>GridLayout</code><code>g</code>, in the order they are stored, extracted from their containing <code>GridContent</code>s.</p></div></div><div class="docstring"><div class="doc-header" id="contour"><a href="#contour">contour</a></div><div class="doc-content"><pre><code>contour(x, y, z)
contour(z::Matrix)</code></pre><p>Creates a contour plot of the plane spanning <code>x::Vector</code>, <code>y::Vector</code>, <code>z::Matrix</code>. If only <code>z::Matrix</code> is supplied, the indices of the elements in <code>z</code> will be used as the <code>x</code> and <code>y</code> locations when plotting the contour.</p><p>The attribute levels can be either</p><pre><code>an Int that produces n equally wide levels or bands

an AbstractVector{&lt;:Real} that lists n consecutive edges from low to high, which result in n-1 levels or bands</code></pre><p>To add contour labels, use <code>labels = true</code>, and pass additional label attributes such as <code>labelcolor</code>, <code>labelsize</code>, <code>labelfont</code> or <code>labelformatter</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.contour}</code> are: </p><pre><code>  alpha           1.0
  color           "nothing"
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  depth_shift     0.0f0
  enable_depth    true
  inspectable     true
  labelcolor      "nothing"
  labelfont       :regular
  labelformatter  Makie.contour_label_formatter
  labels          false
  labelsize       10
  levels          5
  linestyle       "nothing"
  linewidth       1.0
  overdraw        false
  space           :data
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="contour!"><a href="#contour!">contour!</a></div><div class="doc-content"><pre><code>contour(x, y, z)
contour(z::Matrix)</code></pre><p>Creates a contour plot of the plane spanning <code>x::Vector</code>, <code>y::Vector</code>, <code>z::Matrix</code>. If only <code>z::Matrix</code> is supplied, the indices of the elements in <code>z</code> will be used as the <code>x</code> and <code>y</code> locations when plotting the contour.</p><p>The attribute levels can be either</p><pre><code>an Int that produces n equally wide levels or bands

an AbstractVector{&lt;:Real} that lists n consecutive edges from low to high, which result in n-1 levels or bands</code></pre><p>To add contour labels, use <code>labels = true</code>, and pass additional label attributes such as <code>labelcolor</code>, <code>labelsize</code>, <code>labelfont</code> or <code>labelformatter</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.contour!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="contour3d"><a href="#contour3d">contour3d</a></div><div class="doc-content"><pre><code>contour3d(x, y, z)</code></pre><p>Creates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.contour3d}</code> are: </p><pre><code>  alpha           1.0
  color           "nothing"
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  depth_shift     0.0f0
  enable_depth    true
  inspectable     true
  labelcolor      "nothing"
  labelfont       :regular
  labelformatter  Makie.contour_label_formatter
  labels          false
  labelsize       10
  levels          5
  linestyle       "nothing"
  linewidth       1.0
  overdraw        false
  space           :data
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="contour3d!"><a href="#contour3d!">contour3d!</a></div><div class="doc-content"><pre><code>contour3d(x, y, z)</code></pre><p>Creates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.contour3d!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="contourf"><a href="#contourf">contourf</a></div><div class="doc-content"><pre><code>contourf(xs, ys, zs; kwargs...)</code></pre><p>Plots a filled contour of the height information in <code>zs</code> at horizontal grid positions <code>xs</code> and vertical grid positions <code>ys</code>.</p><p>The attribute <code>levels</code> can be either</p><ul><li><p>an <code>Int</code> that produces n equally wide levels or bands</p></li><li><p>an <code>AbstractVector{&lt;:Real}</code> that lists n consecutive edges from low to high, which result in n-1 levels or bands</p></li></ul><p>You can also set the <code>mode</code> attribute to <code>:relative</code>. In this mode you specify edges by the fraction between minimum and maximum value of <code>zs</code>. This can be used for example to draw bands for the upper 90% while excluding the lower 10% with <code>levels = 0.1:0.1:1.0, mode = :relative</code>.</p><p>In :normal mode, if you want to show a band from <code>-Inf</code> to the low edge, set <code>extendlow</code> to <code>:auto</code> for the same color as the first level, or specify a different color (default <code>nothing</code> means no extended band) If you want to show a band from the high edge to <code>Inf</code>, set <code>extendhigh</code> to <code>:auto</code> for the same color as the last level, or specify a different color (default <code>nothing</code> means no extended band).</p><p>If <code>levels</code> is an <code>Int</code>, the contour plot will be rectangular as all <code>zs</code> will be covered. This is why <code>Axis</code> defaults to tight limits for such contourf plots. If you specify <code>levels</code> as an <code>AbstractVector{&lt;:Real}</code>, however, note that the axis limits include the default margins because the contourf plot can have an irregular shape. You can use <code>tightlimits!(ax)</code> to tighten the limits similar to the <code>Int</code> behavior.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.contourf}</code> are: </p><pre><code>  colormap      :viridis
  colorscale    identity
  extendhigh    "nothing"
  extendlow     "nothing"
  inspectable   true
  levels        10
  mode          :normal
  nan_color     :transparent
  transparency  false</code></pre></div></div><div class="docstring"><div class="doc-header" id="contourf!"><a href="#contourf!">contourf!</a></div><div class="doc-content"><pre><code>contourf(xs, ys, zs; kwargs...)</code></pre><p>Plots a filled contour of the height information in <code>zs</code> at horizontal grid positions <code>xs</code> and vertical grid positions <code>ys</code>.</p><p>The attribute <code>levels</code> can be either</p><ul><li><p>an <code>Int</code> that produces n equally wide levels or bands</p></li><li><p>an <code>AbstractVector{&lt;:Real}</code> that lists n consecutive edges from low to high, which result in n-1 levels or bands</p></li></ul><p>You can also set the <code>mode</code> attribute to <code>:relative</code>. In this mode you specify edges by the fraction between minimum and maximum value of <code>zs</code>. This can be used for example to draw bands for the upper 90% while excluding the lower 10% with <code>levels = 0.1:0.1:1.0, mode = :relative</code>.</p><p>In :normal mode, if you want to show a band from <code>-Inf</code> to the low edge, set <code>extendlow</code> to <code>:auto</code> for the same color as the first level, or specify a different color (default <code>nothing</code> means no extended band) If you want to show a band from the high edge to <code>Inf</code>, set <code>extendhigh</code> to <code>:auto</code> for the same color as the last level, or specify a different color (default <code>nothing</code> means no extended band).</p><p>If <code>levels</code> is an <code>Int</code>, the contour plot will be rectangular as all <code>zs</code> will be covered. This is why <code>Axis</code> defaults to tight limits for such contourf plots. If you specify <code>levels</code> as an <code>AbstractVector{&lt;:Real}</code>, however, note that the axis limits include the default margins because the contourf plot can have an irregular shape. You can use <code>tightlimits!(ax)</code> to tighten the limits similar to the <code>Int</code> behavior.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.contourf!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="convert_arguments"><a href="#convert_arguments">convert_arguments</a></div><div class="doc-content"><p>Wrap a single point or equivalent object in a single-element array.</p><p>Enables to use scatter like a surface plot with x::Vector, y::Vector, z::Matrix spanning z over the grid spanned by x y</p><pre><code>convert_arguments(P, x, y, z)::(Vector)</code></pre><p>Takes vectors <code>x</code>, <code>y</code>, and <code>z</code> and turns it into a vector of 3D points of the values from <code>x</code>, <code>y</code>, and <code>z</code>. <code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input GeometryPrimitive <code>x</code> and decomposes it to points. <code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, y)::Vector</code></pre><p>Takes vector <code>y</code> and generates a range from 1 to the length of <code>y</code>, for plotting on an arbitrary <code>x</code> axis.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input <code>Rect</code><code>x</code> and decomposes it to points.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(PB, LineString)</code></pre><p>Takes an input <code>LineString</code> and decomposes it to points.</p><pre><code>convert_arguments(PB, Union{Array{&lt;:LineString}, MultiLineString})</code></pre><p>Takes an input <code>Array{LineString}</code> or a <code>MultiLineString</code> and decomposes it to points.</p><pre><code>convert_arguments(PB, Polygon)</code></pre><p>Takes an input <code>Polygon</code> and decomposes it to points.</p><pre><code>convert_arguments(PB, Union{Array{&lt;:Polygon}, MultiPolygon})</code></pre><p>Takes an input <code>Array{Polygon}</code> or a <code>MultiPolygon</code> and decomposes it to points.</p><pre><code>convert_arguments(SL::SurfaceLike, x::VecOrMat, y::VecOrMat, z::Matrix)</code></pre><p>If <code>SL</code> is <code>Heatmap</code> and <code>x</code> and <code>y</code> are vectors, infer from length of <code>x</code> and <code>y</code> whether they represent edges or centers of the heatmap bins. If they are centers, convert to edges. Convert eltypes to <code>Float32</code> and return outputs as a <code>Tuple</code>.</p><pre><code>convert_arguments(P, x, y, z)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes 2 ClosedIntervals's <code>x</code>, <code>y</code>, and an AbstractMatrix <code>z</code>, and converts the closed range to linspaces with size(z, 1/2) <code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an <code>AbstractMatrix</code>, converts the dimesions <code>n</code> and <code>m</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code> and <code>m</code>, plus the original matrix in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x, y, f)::(Vector, Vector, Matrix)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and the function <code>f</code>, and applies <code>f</code> on the grid that <code>x</code> and <code>y</code> span. This is equivalent to <code>f.(x, y')</code>. <code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an array of <code>{T, 3} where T</code>, converts the dimesions <code>n</code>, <code>m</code> and <code>k</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code>, <code>m</code> and <code>k</code>, plus the original array in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x, y, z, i)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes 3 <code>AbstractVector</code><code>x</code>, <code>y</code>, and <code>z</code> and the <code>AbstractMatrix</code><code>i</code>, and puts everything in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x, y, z, f)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes <code>AbstractVector</code><code>x</code>, <code>y</code>, and <code>z</code> and the function <code>f</code>, evaluates <code>f</code> on the volume spanned by <code>x</code>, <code>y</code> and <code>z</code>, and puts <code>x</code>, <code>y</code>, <code>z</code> and <code>f(x,y,z)</code> in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p><p>Accepts a Vector of Pair of Points (e.g. <code>[Point(0, 0) =&gt; Point(1, 1), ...]</code>) to encode e.g. linesegments or directions.</p><pre><code>convert_arguments(Mesh, x, y, z)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a mesh out of those, under the assumption that every 3 points form a triangle.</p><pre><code>convert_arguments(Mesh, xyz::AbstractVector)::GLNormalMesh</code></pre><p>Takes an input mesh and a vector <code>xyz</code> representing the vertices of the mesh, and creates indices under the assumption, that each triplet in <code>xyz</code> forms a triangle.</p><pre><code>convert_arguments(Mesh, x, y, z, indices)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a triangle mesh out of those, using the faces in <code>indices</code>, which can be integers (every 3 -&gt; one triangle), or GeometryBasics.NgonFace{N, &lt;: Integer}.</p><pre><code>convert_arguments(Mesh, vertices, indices)::GLNormalMesh</code></pre><p>Takes <code>vertices</code> and <code>indices</code>, and creates a triangle mesh out of those. See <a href="@ref"><code>to_vertices</code></a> and <a href="@ref"><code>to_triangles</code></a> for more information about accepted types.</p></div></div><div class="docstring"><div class="doc-header" id="convert_attribute"><a href="#convert_attribute">convert_attribute</a></div><div class="doc-content"><pre><code>convert_attribute(value, attribute::Key[, plottype::Key])</code></pre><p>Convert <code>value</code> into a suitable domain for use as <code>attribute</code>.</p><h1>Example</h1><pre><code class="language-jldoctest">julia&gt; using Makie

julia&gt; Makie.convert_attribute(:black, key"color"())
RGBA{Float32}(0.0f0,0.0f0,0.0f0,1.0f0)</code></pre></div></div><div class="docstring"><div class="doc-header" id="crossbar"><a href="#crossbar">crossbar</a></div><div class="doc-content"><pre><code>crossbar(x, y, ymin, ymax; kwargs...)</code></pre><p>Draw a crossbar. A crossbar represents a range with a (potentially notched) box. It is most commonly used as part of the <code>boxplot</code>.</p><h1>Arguments</h1><ul><li><p><code>x</code>: position of the box</p></li><li><p><code>y</code>: position of the midline within the box</p></li><li><p><code>ymin</code>: lower limit of the box</p></li><li><p><code>ymax</code>: upper limit of the box</p></li></ul><h1>Keywords</h1><ul><li><p><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=1</code>: width of the box before shrinking</p></li><li><p><code>gap=0.2</code>: shrinking factor, <code>width -&gt; width * (1 - gap)</code></p></li><li><p><code>show_notch=false</code>: draw the notch</p></li><li><p><code>notchmin=automatic</code>: lower limit of the notch</p></li><li><p><code>notchmax=automatic</code>: upper limit of the notch</p></li><li><p><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</p></li><li><p><code>show_midline=true</code>: show midline</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="crossbar!"><a href="#crossbar!">crossbar!</a></div><div class="doc-content"><pre><code>crossbar(x, y, ymin, ymax; kwargs...)</code></pre><p>Draw a crossbar. A crossbar represents a range with a (potentially notched) box. It is most commonly used as part of the <code>boxplot</code>.</p><h1>Arguments</h1><ul><li><p><code>x</code>: position of the box</p></li><li><p><code>y</code>: position of the midline within the box</p></li><li><p><code>ymin</code>: lower limit of the box</p></li><li><p><code>ymax</code>: upper limit of the box</p></li></ul><h1>Keywords</h1><ul><li><p><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=1</code>: width of the box before shrinking</p></li><li><p><code>gap=0.2</code>: shrinking factor, <code>width -&gt; width * (1 - gap)</code></p></li><li><p><code>show_notch=false</code>: draw the notch</p></li><li><p><code>notchmin=automatic</code>: lower limit of the notch</p></li><li><p><code>notchmax=automatic</code>: upper limit of the notch</p></li><li><p><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</p></li><li><p><code>show_midline=true</code>: show midline</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="current_axis"><a href="#current_axis">current_axis</a></div><div class="doc-content"><pre><code>current_axis()</code></pre><p>Returns the current active axis (or the last axis created). Returns <code>nothing</code> if there is no current active axis.</p></div></div><div class="docstring"><div class="doc-header" id="current_axis!"><a href="#current_axis!">current_axis!</a></div><div class="doc-content"><pre><code>current_axis!(fig::Figure, ax)</code></pre><p>Set <code>ax</code> as the current active axis in <code>fig</code>.</p><pre><code>current_axis!(ax)</code></pre><p>Set an axis <code>ax</code>, which must be part of a figure, as the figure's current active axis.</p></div></div><div class="docstring"><div class="doc-header" id="current_figure"><a href="#current_figure">current_figure</a></div><div class="doc-content"><pre><code>current_figure()</code></pre><p>Returns the current active figure (or the last figure created). Returns <code>nothing</code> if there is no current active figure.</p></div></div><div class="docstring"><div class="doc-header" id="current_figure!"><a href="#current_figure!">current_figure!</a></div><div class="doc-content"><pre><code>current_figure!(fig)</code></pre><p>Set <code>fig</code> as the current active figure.</p></div></div><div class="docstring"><div class="doc-header" id="data_limits"><a href="#data_limits">data_limits</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.data_limits</code> is a <code>Function</code>.</p><pre><code># 13 methods for generic function "data_limits" from Makie:
  [1] data_limits(pl::Combined{Makie.bracket})
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/bracket.jl:119
  [2] data_limits(p::Combined{Makie.datashader})
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/datashader.jl:469
  [3] data_limits(bars::Union{Combined{Makie.errorbars}, Combined{Makie.rangebars}})
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/error_and_rangebars.jl:290
  [4] data_limits(p::Combined{Makie.voronoiplot, &lt;:Tuple{var"#s36"} where var"#s36"&lt;:(Vector{&lt;:Point{N}})}) where N
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/voronoiplot.jl:171
  [5] data_limits(text::MakieCore.Text{&lt;:Tuple{var"#s36"} where var"#s36"&lt;:Union{Makie.GlyphCollection, AbstractVector{Makie.GlyphCollection}}})
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:43
  [6] data_limits(text::MakieCore.Text)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:56
  [7] data_limits(plot::Surface)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:215
  [8] data_limits(plot::Heatmap)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:222
  [9] data_limits(plot::Image)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:229
 [10] data_limits(hb::Combined{Makie.hexbin})
     @ ~/work/Makie.jl/Makie.jl/src/stats/hexbin.jl:65
 [11] data_limits(plot::AbstractPlot)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:169
 [12] data_limits(scenelike)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:204
 [13] data_limits(scenelike, exclude)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/data_limits.jl:204</code></pre></div></div><div class="docstring"><div class="doc-header" id="datashader"><a href="#datashader">datashader</a></div><div class="doc-content"><pre><code>datashader(points::AbstractVector{&lt;: Point})</code></pre><div class="admonition warning"><p class="admonition-title">Warning</p><p>This feature might change outside breaking releases, since the API is not yet finalized. Please be vary of bugs in the implementation and open issues if you encounter odd behaviour.</p></div><p>Points can be any array type supporting iteration &amp; getindex, including memory mapped arrays. If you have separate arrays for x and y coordinates and want to avoid conversion and copy, consider using:</p><pre><code class="language-Julia">using Makie.StructArrays
points = StructArray{Point2f}((x, y))
datashader(points)</code></pre><p>Do pay attention though, that if x and y don't have a fast iteration/getindex implemented, this might be slower then just copying it into a new array.</p><p>For best performance, use <code>method=Makie.AggThreads()</code> and make sure to start julia with <code>julia -tauto</code> or have the environment variable <code>JULIA_NUM_THREADS</code> set to the number of cores you have.</p><h2>Attributes</h2><h3>Specific to <code>DataShader</code></h3><ul><li><p><code>agg = AggCount()</code> can be <code>AggCount()</code>, <code>AggAny()</code> or <code>AggMean()</code>. User extendable by overloading:</p></li></ul><pre><code>```Julia
    struct MyAgg{T} &lt;: Makie.AggOp end
    MyAgg() = MyAgg{Float64}()
    Makie.Aggregation.null(::MyAgg{T}) where {T} = zero(T)
    Makie.Aggregation.embed(::MyAgg{T}, x) where {T} = convert(T, x)
    Makie.Aggregation.merge(::MyAgg{T}, x::T, y::T) where {T} = x + y
    Makie.Aggregation.value(::MyAgg{T}, x::T) where {T} = x
```</code></pre><ul><li><p><code>method = AggThreads()</code> can be <code>AggThreads()</code> or <code>AggSerial()</code>.</p></li><li><p><code>async::Bool = true</code> will calculate get_aggregation in a task, and skip any zoom/pan updates while busy. Great for interaction, but must be disabled for saving to e.g. png or when inlining in documenter.</p></li><li><p><code>operation::Function = automatic</code> Defaults to <code>Makie.equalize_histogram</code> function which gets called on the whole get<em>aggregation array before display (`operation(final</em>aggregation_result)`).</p></li><li><p><code>local_operation::Function = identity</code> function which gets call on each element after the aggregation (<code>map!(x-&gt; local_operation(x), final_aggregation_result)</code>).</p></li><li><p><code>point_transform::Function = identity</code> function which gets applied to every point before aggregating it.</p></li><li><p><code>binsize::Number = 1</code> factor defining how many bins one wants per screen pixel. Set to n &gt; 1 if you want a corser image.</p></li><li><p><code>show_timings::Bool = false</code> show how long it takes to aggregate each frame.</p></li><li><p><code>interpolate::Bool = true</code> If the resulting image should be displayed interpolated.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="datashader!"><a href="#datashader!">datashader!</a></div><div class="doc-content"><pre><code>datashader(points::AbstractVector{&lt;: Point})</code></pre><div class="admonition warning"><p class="admonition-title">Warning</p><p>This feature might change outside breaking releases, since the API is not yet finalized. Please be vary of bugs in the implementation and open issues if you encounter odd behaviour.</p></div><p>Points can be any array type supporting iteration &amp; getindex, including memory mapped arrays. If you have separate arrays for x and y coordinates and want to avoid conversion and copy, consider using:</p><pre><code class="language-Julia">using Makie.StructArrays
points = StructArray{Point2f}((x, y))
datashader(points)</code></pre><p>Do pay attention though, that if x and y don't have a fast iteration/getindex implemented, this might be slower then just copying it into a new array.</p><p>For best performance, use <code>method=Makie.AggThreads()</code> and make sure to start julia with <code>julia -tauto</code> or have the environment variable <code>JULIA_NUM_THREADS</code> set to the number of cores you have.</p><h2>Attributes</h2><h3>Specific to <code>DataShader</code></h3><ul><li><p><code>agg = AggCount()</code> can be <code>AggCount()</code>, <code>AggAny()</code> or <code>AggMean()</code>. User extendable by overloading:</p></li></ul><pre><code>```Julia
    struct MyAgg{T} &lt;: Makie.AggOp end
    MyAgg() = MyAgg{Float64}()
    Makie.Aggregation.null(::MyAgg{T}) where {T} = zero(T)
    Makie.Aggregation.embed(::MyAgg{T}, x) where {T} = convert(T, x)
    Makie.Aggregation.merge(::MyAgg{T}, x::T, y::T) where {T} = x + y
    Makie.Aggregation.value(::MyAgg{T}, x::T) where {T} = x
```</code></pre><ul><li><p><code>method = AggThreads()</code> can be <code>AggThreads()</code> or <code>AggSerial()</code>.</p></li><li><p><code>async::Bool = true</code> will calculate get_aggregation in a task, and skip any zoom/pan updates while busy. Great for interaction, but must be disabled for saving to e.g. png or when inlining in documenter.</p></li><li><p><code>operation::Function = automatic</code> Defaults to <code>Makie.equalize_histogram</code> function which gets called on the whole get<em>aggregation array before display (`operation(final</em>aggregation_result)`).</p></li><li><p><code>local_operation::Function = identity</code> function which gets call on each element after the aggregation (<code>map!(x-&gt; local_operation(x), final_aggregation_result)</code>).</p></li><li><p><code>point_transform::Function = identity</code> function which gets applied to every point before aggregating it.</p></li><li><p><code>binsize::Number = 1</code> factor defining how many bins one wants per screen pixel. Set to n &gt; 1 if you want a corser image.</p></li><li><p><code>show_timings::Bool = false</code> show how long it takes to aggregate each frame.</p></li><li><p><code>interpolate::Bool = true</code> If the resulting image should be displayed interpolated.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="deactivate_interaction!"><a href="#deactivate_interaction!">deactivate_interaction!</a></div><div class="doc-content"><pre><code>deactivate_interaction!(parent, name::Symbol)</code></pre><p>Deactivate the interaction named <code>name</code> registered in <code>parent</code>. It can be reactivated with <code>activate_interaction!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="decompose"><a href="#decompose">decompose</a></div><div class="doc-content"><pre><code>decompose(facetype, contour::AbstractArray{&lt;:AbstractPoint})</code></pre><p>Triangulate a Polygon without hole.</p><p>Returns a Vector{<code>facetype</code>} defining indexes into <code>contour</code>.</p></div></div><div class="docstring"><div class="doc-header" id="default_theme"><a href="#default_theme">default_theme</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.default_theme</code> is a <code>Function</code>.</p><pre><code># 59 methods for generic function "default_theme" from MakieCore:
  [1] default_theme(scene)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/basic_plots.jl:1
  [2] default_theme(scene, ::Type{&lt;:Arrows})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
  [3] default_theme(scene, ::Type{&lt;:Wireframe})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
  [4] default_theme(scene, ::Type{&lt;:Image})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
  [5] default_theme(scene, ::Type{&lt;:Heatmap})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
  [6] default_theme(scene, ::Type{&lt;:Volume})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
  [7] default_theme(scene, ::Type{&lt;:Surface})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
  [8] default_theme(scene, ::Type{&lt;:Lines})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
  [9] default_theme(scene, ::Type{&lt;:LineSegments})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [10] default_theme(scene, ::Type{&lt;:Mesh})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [11] default_theme(scene, ::Type{&lt;:Scatter})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [12] default_theme(scene, ::Type{&lt;:MeshScatter})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [13] default_theme(scene, ::Type{&lt;:MakieCore.Text})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [14] default_theme(scene, ::Type{&lt;:Poly})
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [15] default_theme(scene, ::Type{&lt;:Combined{Makie.rainclouds}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [16] default_theme(scene, ::Type{&lt;:Combined{Makie.series}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [17] default_theme(scene, ::Type{&lt;:Combined{Makie.hexbin}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [18] default_theme(scene, ::Type{&lt;:Combined{Makie.violin}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [19] default_theme(scene, ::Type{&lt;:Combined{Makie.boxplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [20] default_theme(scene, ::Type{&lt;:Combined{Makie.crossbar}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [21] default_theme(scene, ::Type{&lt;:Combined{Makie.qqnorm}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [22] default_theme(scene, ::Type{&lt;:Combined{Makie.qqplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [23] default_theme(scene, ::Type{&lt;:Combined{Makie.ecdfplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [24] default_theme(scene, ::Type{&lt;:Combined{Makie.density}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [25] default_theme(scene, ::Type{&lt;:Combined{Makie.hist}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [26] default_theme(scene, ::Type{&lt;:Combined{Makie.stephist}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [27] default_theme(scene, ::Type{&lt;:Combined{Makie.tooltip}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [28] default_theme(scene, ::Type{&lt;:Combined{Makie.waterfall}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [29] default_theme(scene, ::Type{&lt;:Combined{Makie.voronoiplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [30] default_theme(scene, ::Type{&lt;:Combined{Makie.volumeslices}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [31] default_theme(scene, ::Type{&lt;:Combined{Makie.triplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [32] default_theme(scene, ::Type{&lt;:Combined{Makie.tricontourf}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [33] default_theme(scene, ::Type{&lt;:Combined{Makie.timeseries}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [34] default_theme(scene, ::Type{&lt;:Combined{Makie.streamplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [35] default_theme(scene, ::Type{&lt;:Combined{Makie.stem}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [36] default_theme(scene, ::Type{&lt;:Combined{Makie.stairs}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [37] default_theme(scene, ::Type{&lt;:Combined{Makie.spy}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [38] default_theme(scene, ::Type{&lt;:Combined{Makie.scatterlines}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [39] default_theme(scene, ::Type{&lt;:Combined{Makie.pie}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [40] default_theme(scene, ::Type{&lt;:Combined{Makie.vspan}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [41] default_theme(scene, ::Type{&lt;:Combined{Makie.hspan}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [42] default_theme(scene, ::Type{&lt;:Combined{Makie.vlines}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [43] default_theme(scene, ::Type{&lt;:Combined{Makie.hlines}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [44] default_theme(scene, ::Type{&lt;:Combined{Makie.rangebars}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [45] default_theme(scene, ::Type{&lt;:Combined{Makie.errorbars}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [46] default_theme(scene, ::Type{&lt;:Combined{Makie.datashader}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [47] default_theme(scene, ::Type{&lt;:Combined{Makie.contourf}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [48] default_theme(scene, ::Type{&lt;:Combined{Makie.contour3d}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [49] default_theme(scene, ::Type{&lt;:Combined{Makie.contour}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [50] default_theme(scene, ::Type{&lt;:Combined{Makie.bracket}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [51] default_theme(scene, ::Type{&lt;:Combined{Makie.barplot}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [52] default_theme(scene, ::Type{&lt;:Combined{Makie.band}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [53] default_theme(scene, ::Type{&lt;:Combined{Makie.axis3d}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [54] default_theme(scene, ::Type{&lt;:Combined{Makie.arc}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [55] default_theme(scene, ::Type{&lt;:Combined{Makie.annotations}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [56] default_theme(scene, ::Type{&lt;:Combined{Makie.ablines}})
     @ Makie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [57] default_theme(scene, ::Type{&lt;:Combined{RPRMakie.matball}})
     @ RPRMakie ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [58] default_theme(scene, ::Type{&lt;:Combined{Main.FD_SANDBOX_12283929528957551597.stockchart}})
     @ Main.FD_SANDBOX_12283929528957551597 ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:178
 [59] default_theme(scene, T)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:64</code></pre></div></div><div class="docstring"><div class="doc-header" id="density"><a href="#density">density</a></div><div class="doc-content"><pre><code>density(values; npoints = 200, offset = 0.0, direction = :x)</code></pre><p>Plot a kernel density estimate of <code>values</code>. <code>npoints</code> controls the resolution of the estimate, the baseline can be shifted with <code>offset</code> and the <code>direction</code> set to <code>:x</code> or <code>:y</code>. <code>bandwidth</code> and <code>boundary</code> are determined automatically by default.</p><p>Statistical weights can be provided via the <code>weights</code> keyword argument.</p><p><code>color</code> is usually set to a single color, but can also be set to <code>:x</code> or <code>:y</code> to color with a gradient. If you use <code>:y</code> when <code>direction = :x</code> (or vice versa), note that only 2-element colormaps can work correctly.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.density}</code> are: </p><pre><code>  bandwidth     MakieCore.Automatic()
  boundary      MakieCore.Automatic()
  color         RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  colormap      :viridis
  colorrange    MakieCore.Automatic()
  colorscale    identity
  cycle         [:color =&gt; :patchcolor]
  direction     :x
  inspectable   true
  linestyle     "nothing"
  npoints       200
  offset        0.0
  strokearound  false
  strokecolor   :black
  strokewidth   0
  weights       MakieCore.Automatic()</code></pre></div></div><div class="docstring"><div class="doc-header" id="density!"><a href="#density!">density!</a></div><div class="doc-content"><pre><code>density(values; npoints = 200, offset = 0.0, direction = :x)</code></pre><p>Plot a kernel density estimate of <code>values</code>. <code>npoints</code> controls the resolution of the estimate, the baseline can be shifted with <code>offset</code> and the <code>direction</code> set to <code>:x</code> or <code>:y</code>. <code>bandwidth</code> and <code>boundary</code> are determined automatically by default.</p><p>Statistical weights can be provided via the <code>weights</code> keyword argument.</p><p><code>color</code> is usually set to a single color, but can also be set to <code>:x</code> or <code>:y</code> to color with a gradient. If you use <code>:y</code> when <code>direction = :x</code> (or vice versa), note that only 2-element colormaps can work correctly.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.density!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="deregister_interaction!"><a href="#deregister_interaction!">deregister_interaction!</a></div><div class="doc-content"><pre><code>deregister_interaction!(parent, name::Symbol)</code></pre><p>Deregister the interaction named <code>name</code> registered in <code>parent</code>.</p></div></div><div class="docstring"><div class="doc-header" id="disconnect!"><a href="#disconnect!">disconnect!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.disconnect!</code> is a <code>Function</code>.</p><pre><code># 16 methods for generic function "disconnect!" from Makie:
  [1] disconnect!(screen::GLMakie.Screen, ::typeof(mouse_position))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:230
  [2] disconnect!(screen::GLMakie.Screen, ::typeof(window_area))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:82
  [3] disconnect!(window::MakieScreen, signal)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/events.jl:35
  [4] disconnect!(observables::Vector)
     @ ~/work/Makie.jl/Makie.jl/src/camera/camera.jl:36
  [5] disconnect!(c::EmptyCamera)
     @ ~/work/Makie.jl/Makie.jl/src/camera/camera.jl:32
  [6] disconnect!(window::GLFW.Window, ::typeof(entered_window))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:310
  [7] disconnect!(window::GLFW.Window, ::typeof(hasfocus))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:288
  [8] disconnect!(window::GLFW.Window, ::typeof(scroll))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:265
  [9] disconnect!(window::GLFW.Window, ::typeof(mouse_position))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:234
 [10] disconnect!(window::GLFW.Window, ::typeof(unicode_input))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:167
 [11] disconnect!(window::GLFW.Window, ::typeof(dropped_files))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:144
 [12] disconnect!(window::GLFW.Window, ::typeof(keyboard_buttons))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:123
 [13] disconnect!(window::GLFW.Window, ::typeof(mouse_buttons))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:108
 [14] disconnect!(::GLFW.Window, ::typeof(window_area))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:86
 [15] disconnect!(window::GLFW.Window, ::typeof(window_open))
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:36
 [16] disconnect!(c::Camera)
     @ ~/work/Makie.jl/Makie.jl/src/camera/camera.jl:24</code></pre></div></div><div class="docstring"><div class="doc-header" id="dropped_files"><a href="#dropped_files">dropped_files</a></div><div class="doc-content"><p>Registers a callback for drag and drop of files. returns <code>Observable{Vector{String}}</code>, which are absolute file paths <a href="http://www.glfw.org/docs/latest/group__input.html#gacc95e259ad21d4f666faa6280d4018fd">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="ecdfplot"><a href="#ecdfplot">ecdfplot</a></div><div class="doc-content"><pre><code>ecdfplot(values; npoints=10_000[, weights])</code></pre><p>Plot the empirical cumulative distribution function (ECDF) of <code>values</code>.</p><p><code>npoints</code> controls the resolution of the plot. If <code>weights</code> for the values are provided, a weighted ECDF is plotted.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.ecdfplot}</code> are: </p><pre><code>  alpha           1.0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  cycle           [:color]
  depth_shift     0.0f0
  highclip        MakieCore.Automatic()
  inspectable     true
  linestyle       "nothing"
  linewidth       1.5
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  space           :data
  ssao            false
  step            :pre
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="ecdfplot!"><a href="#ecdfplot!">ecdfplot!</a></div><div class="doc-content"><pre><code>ecdfplot(values; npoints=10_000[, weights])</code></pre><p>Plot the empirical cumulative distribution function (ECDF) of <code>values</code>.</p><p><code>npoints</code> controls the resolution of the plot. If <code>weights</code> for the values are provided, a weighted ECDF is plotted.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.ecdfplot!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="entered_window"><a href="#entered_window">entered_window</a></div><div class="doc-content"><p>Registers a callback for if the mouse has entered the window. returns an <code>Observable{Bool}</code>, which is true whenever the cursor enters the window. <a href="http://www.glfw.org/docs/latest/group__input.html#ga762d898d9b0241d7e3e3b767c6cf318f">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="errorbars"><a href="#errorbars">errorbars</a></div><div class="doc-content"><pre><code>errorbars(x, y, error_both; kwargs...)
errorbars(x, y, error_low, error_high; kwargs...)
errorbars(x, y, error_low_high; kwargs...)

errorbars(xy, error_both; kwargs...)
errorbars(xy, error_low, error_high; kwargs...)
errorbars(xy, error_low_high; kwargs...)

errorbars(xy_error_both; kwargs...)
errorbars(xy_error_low_high; kwargs...)</code></pre><p>Plots errorbars at xy positions, extending by errors in the given <code>direction</code>.</p><p>If you want to plot intervals from low to high values instead of relative errors, use <code>rangebars</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.errorbars}</code> are: </p><pre><code>  color         :black
  colormap      :viridis
  colorrange    MakieCore.Automatic()
  colorscale    identity
  direction     :y
  inspectable   true
  linewidth     1.5
  transparency  false
  visible       true
  whiskerwidth  0</code></pre></div></div><div class="docstring"><div class="doc-header" id="errorbars!"><a href="#errorbars!">errorbars!</a></div><div class="doc-content"><pre><code>errorbars(x, y, error_both; kwargs...)
errorbars(x, y, error_low, error_high; kwargs...)
errorbars(x, y, error_low_high; kwargs...)

errorbars(xy, error_both; kwargs...)
errorbars(xy, error_low, error_high; kwargs...)
errorbars(xy, error_low_high; kwargs...)

errorbars(xy_error_both; kwargs...)
errorbars(xy_error_low_high; kwargs...)</code></pre><p>Plots errorbars at xy positions, extending by errors in the given <code>direction</code>.</p><p>If you want to plot intervals from low to high values instead of relative errors, use <code>rangebars</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.errorbars!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="events"><a href="#events">events</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.events</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "events" from Makie:
 [1] events(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:527
 [2] events(scene::Union{AbstractScene, MakieCore.ScenePlot})
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:528
 [3] events(x)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:526</code></pre></div></div><div class="docstring"><div class="doc-header" id="fill_between!"><a href="#fill_between!">fill_between!</a></div><div class="doc-content"><pre><code>fill_between!(scenelike, x, y1, y2; where = nothing, kw_args...)</code></pre><p>fill the section between 2 lines with the condition <code>where</code></p></div></div><div class="docstring"><div class="doc-header" id="flatten_plots"><a href="#flatten_plots">flatten_plots</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.flatten_plots</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "flatten_plots" from Makie:
 [1] flatten_plots(scenelike)
     @ deprecated.jl:103</code></pre></div></div><div class="docstring"><div class="doc-header" id="grid!"><a href="#grid!">grid!</a></div><div class="doc-content"><pre><code>grid!(content::Vararg{Pair}; kwargs...)</code></pre><p>Creates a GridLayout with all pairs contained in <code>content</code>. Each pair consists of an iterable with row and column spans, and a content object. Each content object is then placed in the GridLayout at the span from its pair.</p><p>Example:</p><p>grid!(     [1, 1] =&gt; obj1,     [1, 2] =&gt; obj2,     [2, :] =&gt; obj3, )</p><pre><code>grid!(content::AbstractMatrix; kwargs...)</code></pre><p>Creates a GridLayout filled with matrix-like content. The size of the grid will be the size of the matrix.</p></div></div><div class="docstring"><div class="doc-header" id="gridnest!"><a href="#gridnest!">gridnest!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.gridnest!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "gridnest!" from GridLayoutBase:
 [1] gridnest!(gl::GridLayout, rows::Union{Colon, Int64, UnitRange}, cols::Union{Colon, Int64, UnitRange})
     @ ~/.julia/packages/GridLayoutBase/kiave/src/gridlayout.jl:583</code></pre></div></div><div class="docstring"><div class="doc-header" id="hasfocus"><a href="#hasfocus">hasfocus</a></div><div class="doc-content"><p>Registers a callback for the focus of a window. returns an <code>Observable{Bool}</code>, which is true whenever the window has focus. <a href="http://www.glfw.org/docs/latest/group__window.html#ga6b5f973531ea91663ad707ba4f2ac104">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="heatmap"><a href="#heatmap">heatmap</a></div><div class="doc-content"><pre><code>heatmap(x, y, values)
heatmap(values)</code></pre><p>Plots a heatmap as an image on <code>x, y</code> (defaults to interpretation as dimensions).</p><h2>Attributes</h2><h3>Specific to <code>Heatmap</code></h3><ul><li><p><code>interpolate::Bool = false</code> sets whether colors should be interpolated.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="heatmap!"><a href="#heatmap!">heatmap!</a></div><div class="doc-content"><pre><code>heatmap(x, y, values)
heatmap(values)</code></pre><p>Plots a heatmap as an image on <code>x, y</code> (defaults to interpretation as dimensions).</p><h2>Attributes</h2><h3>Specific to <code>Heatmap</code></h3><ul><li><p><code>interpolate::Bool = false</code> sets whether colors should be interpolated.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="height"><a href="#height">height</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.height</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "height" from GeometryBasics:
 [1] height(prim::GeometryBasics.HyperRectangle)
     @ ~/.julia/packages/GeometryBasics/b8075/src/primitives/rectangles.jl:165
 [2] height(c::GeometryBasics.Cylinder{N, T}) where {N, T}
     @ ~/.julia/packages/GeometryBasics/b8075/src/primitives/cylinders.jl:26</code></pre></div></div><div class="docstring"><div class="doc-header" id="help"><a href="#help">help</a></div><div class="doc-content"><pre><code>help(func[; extended = false])</code></pre><p>Welcome to the main help function of <code>Makie.jl</code> / <code>Makie.jl</code>.</p><p>For help on a specific function's arguments, type <code>help_arguments(function_name)</code>.</p><p>For help on a specific function's attributes, type <code>help_attributes(plot_Type)</code>.</p><p>Use the optional <code>extended = true</code> keyword argument to see more details.</p></div></div><div class="docstring"><div class="doc-header" id="help_arguments"><a href="#help_arguments">help_arguments</a></div><div class="doc-content"><pre><code>help_arguments([io], func)</code></pre><p>Returns a list of signatures for function <code>func</code>.</p></div></div><div class="docstring"><div class="doc-header" id="help_attributes"><a href="#help_attributes">help_attributes</a></div><div class="doc-content"><pre><code>help_attributes([io], Union{PlotType, PlotFunction}; extended = false)</code></pre><p>Returns a list of attributes for the plot type <code>Typ</code>. The attributes returned extend those attributes found in the <code>default_theme</code>.</p><p>Use the optional keyword argument <code>extended</code> (default = <code>false</code>) to show in addition the default values of each attribute. usage:</p><pre><code class="language-julia">&gt;help_attributes(scatter)
    alpha
    color
    colormap
    colorrange
    distancefield
    glowcolor
    glowwidth
    linewidth
    marker
    marker_offset
    markersize
    overdraw
    rotations
    strokecolor
    strokewidth
    transform_marker
    transparency
    uv_offset_width
    visible</code></pre></div></div><div class="docstring"><div class="doc-header" id="hexbin"><a href="#hexbin">hexbin</a></div><div class="doc-content"><pre><code>hexbin(xs, ys; kwargs...)</code></pre><p>Plots a heatmap with hexagonal bins for the observations <code>xs</code> and <code>ys</code>.</p><h2>Attributes</h2><h3>Specific to <code>Hexbin</code></h3><ul><li><p><code>weights = nothing</code>: Weights for each observation.  Can be <code>nothing</code> (each observation carries weight 1) or any <code>AbstractVector{&lt;: Real}</code> or <code>StatsBase.AbstractWeights</code>.</p></li><li><p><code>bins = 20</code>: If an <code>Int</code>, sets the number of bins in x and y direction. If a <code>Tuple{Int, Int}</code>, sets the number of bins for x and y separately.</p></li><li><p><code>cellsize = nothing</code>: If a <code>Real</code>, makes equally-sided hexagons with width <code>cellsize</code>. If a <code>Tuple{Real, Real}</code> specifies hexagon width and height separately.</p></li><li><p><code>threshold::Int = 1</code>: The minimal number of observations in the bin to be shown. If 0, all zero-count hexagons fitting into the data limits will be shown.</p></li><li><p><code>colorscale = identity</code>: A function to scale the number of observations in a bin, eg. log10.</p></li></ul><h3>Generic</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code></p></li><li><p><code>colorrange::Tuple(&lt;:Real,&lt;:Real} = Makie.automatic</code>  sets the values representing the start and end points of <code>colormap</code>.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="hexbin!"><a href="#hexbin!">hexbin!</a></div><div class="doc-content"><pre><code>hexbin(xs, ys; kwargs...)</code></pre><p>Plots a heatmap with hexagonal bins for the observations <code>xs</code> and <code>ys</code>.</p><h2>Attributes</h2><h3>Specific to <code>Hexbin</code></h3><ul><li><p><code>weights = nothing</code>: Weights for each observation.  Can be <code>nothing</code> (each observation carries weight 1) or any <code>AbstractVector{&lt;: Real}</code> or <code>StatsBase.AbstractWeights</code>.</p></li><li><p><code>bins = 20</code>: If an <code>Int</code>, sets the number of bins in x and y direction. If a <code>Tuple{Int, Int}</code>, sets the number of bins for x and y separately.</p></li><li><p><code>cellsize = nothing</code>: If a <code>Real</code>, makes equally-sided hexagons with width <code>cellsize</code>. If a <code>Tuple{Real, Real}</code> specifies hexagon width and height separately.</p></li><li><p><code>threshold::Int = 1</code>: The minimal number of observations in the bin to be shown. If 0, all zero-count hexagons fitting into the data limits will be shown.</p></li><li><p><code>colorscale = identity</code>: A function to scale the number of observations in a bin, eg. log10.</p></li></ul><h3>Generic</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code></p></li><li><p><code>colorrange::Tuple(&lt;:Real,&lt;:Real} = Makie.automatic</code>  sets the values representing the start and end points of <code>colormap</code>.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="hgrid!"><a href="#hgrid!">hgrid!</a></div><div class="doc-content"><pre><code>hbox!(content::Vararg; kwargs...)</code></pre><p>Creates a single-row GridLayout with all elements contained in <code>content</code> placed from left to right.</p></div></div><div class="docstring"><div class="doc-header" id="hidedecorations!"><a href="#hidedecorations!">hidedecorations!</a></div><div class="doc-content"><pre><code>hidedecorations!(la::Axis)</code></pre><p>Hide decorations of both x and y-axis: label, ticklabels, ticks and grid.</p></div></div><div class="docstring"><div class="doc-header" id="hidespines!"><a href="#hidespines!">hidespines!</a></div><div class="doc-content"><pre><code>hidespines!(la::Axis, spines::Symbol... = (:l, :r, :b, :t)...)</code></pre><p>Hide all specified axis spines. Hides all spines by default, otherwise choose with the symbols :l, :r, :b and :t.</p></div></div><div class="docstring"><div class="doc-header" id="hidexdecorations!"><a href="#hidexdecorations!">hidexdecorations!</a></div><div class="doc-content"><pre><code>hidexdecorations!(la::Axis; label = true, ticklabels = true, ticks = true, grid = true,
    minorgrid = true, minorticks = true)</code></pre><p>Hide decorations of the x-axis: label, ticklabels, ticks and grid.</p></div></div><div class="docstring"><div class="doc-header" id="hideydecorations!"><a href="#hideydecorations!">hideydecorations!</a></div><div class="doc-content"><pre><code>hideydecorations!(la::Axis; label = true, ticklabels = true, ticks = true, grid = true,
    minorgrid = true, minorticks = true)</code></pre><p>Hide decorations of the y-axis: label, ticklabels, ticks and grid.</p></div></div><div class="docstring"><div class="doc-header" id="hidezdecorations!"><a href="#hidezdecorations!">hidezdecorations!</a></div><div class="doc-content"><pre><code>hidezdecorations!(la::Axis; label = true, ticklabels = true, ticks = true, grid = true,
    minorgrid = true, minorticks = true)</code></pre><p>Hide decorations of the z-axis: label, ticklabels, ticks and grid.</p></div></div><div class="docstring"><div class="doc-header" id="hist"><a href="#hist">hist</a></div><div class="doc-content"><pre><code>hist(values; bins = 15, normalization = :none)</code></pre><p>Plot a histogram of <code>values</code>. <code>bins</code> can be an <code>Int</code> to create that number of equal-width bins over the range of <code>values</code>. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting <code>normalization</code>. Possible values are:</p><ul><li><p><code>:pdf</code>: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.</p></li><li><p><code>:density</code>: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1. Will not modify the  histogram if it already represents a density (<code>h.isdensity == 1</code>).</p></li><li><p><code>:probability</code>: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.</p></li><li><p><code>:none</code>: Do not normalize.</p></li></ul><p>Statistical weights can be provided via the <code>weights</code> keyword argument.</p><p>The following attributes can move the histogram around, which comes in handy when placing multiple histograms into one plot:</p><ul><li><p><code>offset = 0.0</code>: adds an offset to every value</p></li><li><p><code>fillto = 0.0</code>: defines where the bar starts</p></li><li><p><code>scale_to = nothing</code>: allows to scale all values to a certain height</p></li><li><p><code>flip = false</code>: flips all values</p></li></ul><p>Color can either be:</p><ul><li><p>a vector of <code>bins</code> colors</p></li><li><p>a single color</p></li><li><p><code>:values</code>, to color the bars with the values from the histogram</p></li></ul><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.hist}</code> are: </p><pre><code>  bar_labels             "nothing"
  bins                   15
  color                  RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  cycle                  [:color =&gt; :patchcolor]
  fillto                 MakieCore.Automatic()
  flip_labels_at         Inf
  label_color            :black
  label_font             :regular
  label_formatter        Makie.bar_label_formatter
  label_offset           5
  label_size             20
  normalization          :none
  offset                 0.0
  over_background_color  MakieCore.Automatic()
  over_bar_color         MakieCore.Automatic()
  scale_to               "nothing"
  weights                MakieCore.Automatic()</code></pre></div></div><div class="docstring"><div class="doc-header" id="hist!"><a href="#hist!">hist!</a></div><div class="doc-content"><pre><code>hist(values; bins = 15, normalization = :none)</code></pre><p>Plot a histogram of <code>values</code>. <code>bins</code> can be an <code>Int</code> to create that number of equal-width bins over the range of <code>values</code>. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting <code>normalization</code>. Possible values are:</p><ul><li><p><code>:pdf</code>: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.</p></li><li><p><code>:density</code>: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1. Will not modify the  histogram if it already represents a density (<code>h.isdensity == 1</code>).</p></li><li><p><code>:probability</code>: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.</p></li><li><p><code>:none</code>: Do not normalize.</p></li></ul><p>Statistical weights can be provided via the <code>weights</code> keyword argument.</p><p>The following attributes can move the histogram around, which comes in handy when placing multiple histograms into one plot:</p><ul><li><p><code>offset = 0.0</code>: adds an offset to every value</p></li><li><p><code>fillto = 0.0</code>: defines where the bar starts</p></li><li><p><code>scale_to = nothing</code>: allows to scale all values to a certain height</p></li><li><p><code>flip = false</code>: flips all values</p></li></ul><p>Color can either be:</p><ul><li><p>a vector of <code>bins</code> colors</p></li><li><p>a single color</p></li><li><p><code>:values</code>, to color the bars with the values from the histogram</p></li></ul><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.hist!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="hlines"><a href="#hlines">hlines</a></div><div class="doc-content"><pre><code>hlines(ys; xmin = 0.0, xmax = 1.0, attrs...)</code></pre><p>Create horizontal lines across a <code>Scene</code> with 2D projection. The lines will be placed at <code>ys</code> in data coordinates and <code>xmin</code> to <code>xmax</code> in scene coordinates (0 to 1). All three of these can have single or multiple values because they are broadcast to calculate the final line segments.</p><p>All style attributes are the same as for <code>LineSegments</code>.</p></div></div><div class="docstring"><div class="doc-header" id="hlines!"><a href="#hlines!">hlines!</a></div><div class="doc-content"><pre><code>hlines(ys; xmin = 0.0, xmax = 1.0, attrs...)</code></pre><p>Create horizontal lines across a <code>Scene</code> with 2D projection. The lines will be placed at <code>ys</code> in data coordinates and <code>xmin</code> to <code>xmax</code> in scene coordinates (0 to 1). All three of these can have single or multiple values because they are broadcast to calculate the final line segments.</p><p>All style attributes are the same as for <code>LineSegments</code>.</p></div></div><div class="docstring"><div class="doc-header" id="hovered_scene"><a href="#hovered_scene">hovered_scene</a></div><div class="doc-content"><pre><code>hovered_scene()</code></pre><p>Returns the <code>scene</code> that the mouse is currently hovering over.</p><p>Properly identifies the scene for a plot with multiple sub-plots.</p></div></div><div class="docstring"><div class="doc-header" id="hspan"><a href="#hspan">hspan</a></div><div class="doc-content"><pre><code>hspan(ys_low, ys_high; xmin = 0.0, xmax = 1.0, attrs...)</code></pre><p>Create horizontal bands spanning across a <code>Scene</code> with 2D projection. The bands will be placed from <code>ys_low</code> to <code>ys_high</code> in data coordinates and <code>xmin</code> to <code>xmax</code> in scene coordinates (0 to 1). All four of these can have single or multiple values because they are broadcast to calculate the final spans.</p><p>All style attributes are the same as for <code>Poly</code>.</p></div></div><div class="docstring"><div class="doc-header" id="hspan!"><a href="#hspan!">hspan!</a></div><div class="doc-content"><pre><code>hspan(ys_low, ys_high; xmin = 0.0, xmax = 1.0, attrs...)</code></pre><p>Create horizontal bands spanning across a <code>Scene</code> with 2D projection. The bands will be placed from <code>ys_low</code> to <code>ys_high</code> in data coordinates and <code>xmin</code> to <code>xmax</code> in scene coordinates (0 to 1). All four of these can have single or multiple values because they are broadcast to calculate the final spans.</p><p>All style attributes are the same as for <code>Poly</code>.</p></div></div><div class="docstring"><div class="doc-header" id="image"><a href="#image">image</a></div><div class="doc-content"><pre><code>image(x, y, image)
image(image)</code></pre><p>Plots an image on range <code>x, y</code> (defaults to dimensions).</p><h2>Attributes</h2><h3>Specific to <code>Image</code></h3><ul><li><p><code>interpolate::Bool = true</code> sets whether colors should be interpolated.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="image!"><a href="#image!">image!</a></div><div class="doc-content"><pre><code>image(x, y, image)
image(image)</code></pre><p>Plots an image on range <code>x, y</code> (defaults to dimensions).</p><h2>Attributes</h2><h3>Specific to <code>Image</code></h3><ul><li><p><code>interpolate::Bool = true</code> sets whether colors should be interpolated.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="insertplots!"><a href="#insertplots!">insertplots!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.insertplots!</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "insertplots!" from Makie:
 [1] insertplots!(screen::GLMakie.Screen, scene::Scene)
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/screen.jl:432
 [2] insertplots!(screen::AbstractDisplay, scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:565</code></pre></div></div><div class="docstring"><div class="doc-header" id="interactions"><a href="#interactions">interactions</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.interactions</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "interactions" from Makie:
 [1] interactions(ax::Axis)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/interactions.jl:4
 [2] interactions(ax3::Axis3)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/interactions.jl:5</code></pre></div></div><div class="docstring"><div class="doc-header" id="is_mouseinside"><a href="#is_mouseinside">is_mouseinside</a></div><div class="doc-content"><pre><code>is_mouseinside(scene)</code></pre><p>Returns true if the current mouseposition is inside the given scene.</p></div></div><div class="docstring"><div class="doc-header" id="ispressed"><a href="#ispressed">ispressed</a></div><div class="doc-content"><pre><code>ispressed(parent, result::Bool)
ispressed(parent, button::Union{Mouse.Button, Keyboard.Button)
ispressed(parent, collection::Union{Set, Vector, Tuple})
ispressed(parent, op::BooleanOperator)</code></pre><p>This function checks if a button or combination of buttons is pressed.</p><p>If given a true or false, <code>ispressed</code> will return true or false respectively. This provides a way to turn an interaction "always on" or "always off" from the outside.</p><p>Passing a button or collection of buttons such as <code>Keyboard.enter</code> or <code>Mouse.left</code> will return true if all of the given buttons are pressed.</p><p>Parent can be any object that has <code>get_scene</code> method implemented, which includes e.g. Figure, Axis, Axis3, Lscene, FigureAxisPlot, and AxisPlot.</p><p>For more complicated combinations of buttons they can be combined into boolean expression with <code>&amp;</code>, <code>|</code> and <code>!</code>. For example, you can have <code>ispressed(parent, !Keyboard.left_control &amp; Keyboard.c))</code> and <code>ispressed(parent, Keyboard.left_control &amp; Keyboard.c)</code> to avoid triggering both cases at the same time.</p><p>Furthermore you can also make any button, button collection or boolean expression exclusive by wrapping it in <code>Exclusively(...)</code>. With that <code>ispressed</code> will only return true if the currently pressed buttons match the request exactly.</p><p>See also: <a href="@ref"><code>And</code></a>, <a href="@ref"><code>Or</code></a>, <a href="@ref"><code>Not</code></a>, <a href="@ref"><code>Exclusively</code></a>, <a href="@ref"><code>&amp;</code></a>, <a href="@ref"><code>|</code></a>, <a href="@ref"><code>!</code></a></p></div></div><div class="docstring"><div class="doc-header" id="keyboard_buttons"><a href="#keyboard_buttons">keyboard_buttons</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.keyboard_buttons</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "keyboard_buttons" from Makie:
 [1] keyboard_buttons(scene::Scene, window::GLFW.Window)
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:112
 [2] keyboard_buttons(scene::Scene, screen)
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:111
 [3] keyboard_buttons(scene, native_window)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/events.jl:8</code></pre></div></div><div class="docstring"><div class="doc-header" id="labelslider!"><a href="#labelslider!">labelslider!</a></div><div class="doc-content"><pre><code>labelslider!(scene, label, range; format = string, sliderkw = Dict(),
labelkw = Dict(), valuekw = Dict(), value_column_width = automatic, layoutkw...)</code></pre><p><strong><code>labelslider!</code> is deprecated, use <code>SliderGrid</code> instead</strong></p><p>Construct a horizontal GridLayout with a label, a slider and a value label in <code>scene</code>.</p><p>Returns a <code>NamedTuple</code>:</p><p><code>(slider = slider, label = label, valuelabel = valuelabel, layout = layout)</code></p><p>Specify a format function for the value label with the <code>format</code> keyword or pass a format string used by <code>Formatting.format</code>. The slider is forwarded the keywords from <code>sliderkw</code>. The label is forwarded the keywords from <code>labelkw</code>. The value label is forwarded the keywords from <code>valuekw</code>. You can set the column width for the value label column with the keyword <code>value_column_width</code>. By default, the width is determined heuristically by sampling a few values from the slider range. All other keywords are forwarded to the <code>GridLayout</code>.</p><p>Example:</p><pre><code>ls = labelslider!(scene, "Voltage:", 0:10; format = x -&gt; "$(x)V")
layout[1, 1] = ls.layout</code></pre></div></div><div class="docstring"><div class="doc-header" id="labelslidergrid!"><a href="#labelslidergrid!">labelslidergrid!</a></div><div class="doc-content"><pre><code>labelslidergrid!(scene, labels, ranges; formats = [string],
    sliderkw = Dict(), labelkw = Dict(), valuekw = Dict(),
    value_column_width = automatic, layoutkw...)</code></pre><p><strong><code>labelslidergrid!</code> is deprecated, use <code>SliderGrid</code> instead</strong></p><p>Construct a GridLayout with a column of label, a column of sliders and a column of value labels in <code>scene</code>. The argument values are broadcast, so you can use scalars if you want to keep labels, ranges or formats constant across rows.</p><p>Returns a <code>NamedTuple</code>:</p><p><code>(sliders = sliders, labels = labels, valuelabels = valuelabels, layout = layout)</code></p><p>Specify format functions for the value labels with the <code>formats</code> keyword or pass format strings used by <code>Formatting.format</code>. The sliders are forwarded the keywords from <code>sliderkw</code>. The labels are forwarded the keywords from <code>labelkw</code>. The value labels are forwarded the keywords from <code>valuekw</code>. You can set the column width for the value label column with the keyword <code>value_column_width</code>. By default, the width is determined heuristically by sampling a few values from the slider ranges. All other keywords are forwarded to the <code>GridLayout</code>.</p><p>Example:</p><pre><code>ls = labelslidergrid!(scene, ["Voltage", "Ampere"], Ref(0:0.1:100); format = x -&gt; "$(x)V")
layout[1, 1] = ls.layout</code></pre></div></div><div class="docstring"><div class="doc-header" id="left"><a href="#left">left</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.left</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "left" from Makie:
 [1] left(rect::Rect2)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:2</code></pre></div></div><div class="docstring"><div class="doc-header" id="lift"><a href="#lift">lift</a></div><div class="doc-content"><pre><code>map(f, c...) -&gt; collection</code></pre><p>Transform collection <code>c</code> by applying <code>f</code> to each element. For multiple collection arguments, apply <code>f</code> elementwise, and stop when when any of them is exhausted.</p><p>See also <a href="@ref"><code>map!</code></a>, <a href="@ref"><code>foreach</code></a>, <a href="@ref"><code>mapreduce</code></a>, <a href="@ref"><code>mapslices</code></a>, <a href="@ref"><code>zip</code></a>, <a href="@ref"><code>Iterators.map</code></a>.</p><h1>Examples</h1><pre><code class="language-jldoctest">julia&gt; map(x -&gt; x * 2, [1, 2, 3])
3-element Vector{Int64}:
 2
 4
 6

julia&gt; map(+, [1, 2, 3], [10, 20, 30, 400, 5000])
3-element Vector{Int64}:
 11
 22
 33</code></pre><pre><code>map(f, A::AbstractArray...) -&gt; N-array</code></pre><p>When acting on multi-dimensional arrays of the same <a href="@ref"><code>ndims</code></a>, they must all have the same <a href="@ref"><code>axes</code></a>, and the answer will too.</p><p>See also <a href="@ref"><code>broadcast</code></a>, which allows mismatched sizes.</p><h1>Examples</h1><pre><code>julia&gt; map(//, [1 2; 3 4], [4 3; 2 1])
2Ã2 Matrix{Rational{Int64}}:
 1//4  2//3
 3//2  4//1

julia&gt; map(+, [1 2; 3 4], zeros(2,1))
ERROR: DimensionMismatch

julia&gt; map(+, [1 2; 3 4], [1,10,100,1000], zeros(3,1))  # iterates until 3rd is exhausted
3-element Vector{Float64}:
   2.0
  13.0
 102.0</code></pre><pre><code>obs = map(f, arg1::AbstractObservable, args...; ignore_equal_values=false)</code></pre><p>Creates a new observable <code>obs</code> which contains the result of <code>f</code> applied to values extracted from <code>arg1</code> and <code>args</code> (i.e., <code>f(arg1[], ...)</code>. <code>arg1</code> must be an observable for dispatch reasons. <code>args</code> may contain any number of <code>Observable</code> objects. <code>f</code> will be passed the values contained in the observables as the respective argument. All other objects in <code>args</code> are passed as-is.</p><p>If you don't need the value of <code>obs</code>, and just want to run <code>f</code> whenever the arguments update, use <a href="@ref"><code>on</code></a> or <a href="@ref"><code>onany</code></a> instead.</p><h1>Example</h1><pre><code class="language-jldoctest; setup=:(using Observables)">julia&gt; obs = Observable([1,2,3]);

julia&gt; map(length, obs)
Observable(3)</code></pre><pre><code>map(fn, p::AbstractPolynomial, args...)</code></pre><p>Transform coefficients of <code>p</code> by applying a function (or other callables) <code>fn</code> to each of them.</p><p>You can implement <code>real</code>, etc., to a <code>Polynomial</code> by using <code>map</code>. The type of <code>p</code> may narrow using this function.</p></div></div><div class="docstring"><div class="doc-header" id="limits!"><a href="#limits!">limits!</a></div><div class="doc-content"><pre><code>limits!(ax::Axis, xlims, ylims)</code></pre><p>Set the axis limits to <code>xlims</code> and <code>ylims</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis, x1, x2, y1, y2)</code></pre><p>Set the axis x-limits to <code>x1</code> and <code>x2</code> and the y-limits to <code>y1</code> and <code>y2</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis, rect::Rect2)</code></pre><p>Set the axis limits to <code>rect</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis3, xlims, ylims, zlims)</code></pre><p>Set the axis limits to <code>xlims</code>, <code>ylims</code>, and <code>zlims</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis3, x1, x2, y1, y2, z1, z2)</code></pre><p>Set the axis x-limits to <code>x1</code> and <code>x2</code>, the y-limits to <code>y1</code> and <code>y2</code>, and the z-limits to <code>z1</code> and <code>z2</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis3, rect::Rect3)</code></pre><p>Set the axis limits to <code>rect</code>. If limits are ordered high-low, this reverses the axis orientation.</p></div></div><div class="docstring"><div class="doc-header" id="lines"><a href="#lines">lines</a></div><div class="doc-content"><pre><code>lines(positions)
lines(x, y)
lines(x, y, z)</code></pre><p>Creates a connected line plot for each element in <code>(x, y, z)</code>, <code>(x, y)</code> or <code>positions</code>.</p><p><code>NaN</code> values are displayed as gaps in the line.</p><h2>Attributes</h2><h3>Specific to <code>Lines</code></h3><ul><li><p><code>color=theme(scene, :linecolor)</code> sets the color of the line. If no color is set, multiple calls to <code>line!</code> will cycle through the axis color palette. Otherwise, one can set one color per line point by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole line. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>linestyle::Union{Nothing, Symbol, Linestyle} = nothing</code> sets the pattern of the line e.g. <code>:solid</code>, <code>:dot</code>, <code>:dashdot</code>. For custom patterns look at <code>Linestyle(Number[...])</code>.</p></li><li><p><code>linewidth::Union{Real, Vector} = 1.5</code> sets the width of the line in pixel units.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="lines!"><a href="#lines!">lines!</a></div><div class="doc-content"><pre><code>lines(positions)
lines(x, y)
lines(x, y, z)</code></pre><p>Creates a connected line plot for each element in <code>(x, y, z)</code>, <code>(x, y)</code> or <code>positions</code>.</p><p><code>NaN</code> values are displayed as gaps in the line.</p><h2>Attributes</h2><h3>Specific to <code>Lines</code></h3><ul><li><p><code>color=theme(scene, :linecolor)</code> sets the color of the line. If no color is set, multiple calls to <code>line!</code> will cycle through the axis color palette. Otherwise, one can set one color per line point by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole line. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>linestyle::Union{Nothing, Symbol, Linestyle} = nothing</code> sets the pattern of the line e.g. <code>:solid</code>, <code>:dot</code>, <code>:dashdot</code>. For custom patterns look at <code>Linestyle(Number[...])</code>.</p></li><li><p><code>linewidth::Union{Real, Vector} = 1.5</code> sets the width of the line in pixel units.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="linesegments"><a href="#linesegments">linesegments</a></div><div class="doc-content"><pre><code>linesegments(positions)
linesegments(vector_of_2tuples_of_points)
linesegments(x, y)
linesegments(x, y, z)</code></pre><p>Plots a line for each pair of points in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><h2>Attributes</h2><h3>Specific to <code>LineSegments</code></h3><ul><li><p><code>color=theme(scene, :linecolor)</code> sets the color of the linesegments. If no color is set, multiple calls to <code>linesegments!</code> will cycle through the axis color palette. Otherwise, one can set one color per line point or one color per linesegment by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole line. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>linestyle::Union{Nothing, Symbol, Vector} = nothing</code> sets the pattern of the line (e.g. <code>:solid</code>, <code>:dot</code>, <code>:dashdot</code>)</p></li><li><p><code>linewidth::Union{Real, Vector} = 1.5</code> sets the width of the line in pixel units.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="linesegments!"><a href="#linesegments!">linesegments!</a></div><div class="doc-content"><pre><code>linesegments(positions)
linesegments(vector_of_2tuples_of_points)
linesegments(x, y)
linesegments(x, y, z)</code></pre><p>Plots a line for each pair of points in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><h2>Attributes</h2><h3>Specific to <code>LineSegments</code></h3><ul><li><p><code>color=theme(scene, :linecolor)</code> sets the color of the linesegments. If no color is set, multiple calls to <code>linesegments!</code> will cycle through the axis color palette. Otherwise, one can set one color per line point or one color per linesegment by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole line. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>linestyle::Union{Nothing, Symbol, Vector} = nothing</code> sets the pattern of the line (e.g. <code>:solid</code>, <code>:dot</code>, <code>:dashdot</code>)</p></li><li><p><code>linewidth::Union{Real, Vector} = 1.5</code> sets the width of the line in pixel units.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="linkaxes!"><a href="#linkaxes!">linkaxes!</a></div><div class="doc-content"><pre><code>linkaxes!(a::Axis, others...)</code></pre><p>Link both x and y axes of all given <code>Axis</code> so that they stay synchronized.</p></div></div><div class="docstring"><div class="doc-header" id="linkxaxes!"><a href="#linkxaxes!">linkxaxes!</a></div><div class="doc-content"><pre><code>linkxaxes!(a::Axis, others...)</code></pre><p>Link the x axes of all given <code>Axis</code> so that they stay synchronized.</p></div></div><div class="docstring"><div class="doc-header" id="linkyaxes!"><a href="#linkyaxes!">linkyaxes!</a></div><div class="doc-content"><pre><code>linkyaxes!(a::Axis, others...)</code></pre><p>Link the y axes of all given <code>Axis</code> so that they stay synchronized.</p></div></div><div class="docstring"><div class="doc-header" id="map_once"><a href="#map_once">map_once</a></div><div class="doc-content"><pre><code>map_once(closure, inputs::Observable....)::Observable</code></pre><p>Like Reactive.foreach, in the sense that it will be preserved even if no reference is kept. The difference is, that you can call map once multiple times with the same closure and it will close the old result Observable and register a new one instead.</p><p>``` function test(s1::Observable)     s3 = map<em>once(x-&gt; (println("1 ", x); x), s1)     s3 = map</em>once(x-&gt; (println("2 ", x); x), s1)</p><p>end test(Observable(1), Observable(2))</p><blockquote></blockquote></div></div><div class="docstring"><div class="doc-header" id="mesh"><a href="#mesh">mesh</a></div><div class="doc-content"><pre><code>mesh(x, y, z)
mesh(mesh_object)
mesh(x, y, z, faces)
mesh(xyz, faces)</code></pre><p>Plots a 3D or 2D mesh. Supported <code>mesh_object</code>s include <code>Mesh</code> types from <a href="https://github.com/JuliaGeometry/GeometryBasics.jl">GeometryBasics.jl</a>.</p><h2>Attributes</h2><h3>Specific to <code>Mesh</code></h3><ul><li><p><code>color=theme(scene, :patchcolor)</code> sets the color of the mesh. Can be a <code>Vector{&lt;:Colorant}</code> for per vertex colors or a single <code>Colorant</code>.  A <code>Matrix{&lt;:Colorant}</code> can be used to color the mesh with a texture, which requires the mesh to contain texture coordinates.  Vector or Matrices of numbers can be used as well, which will use the colormap arguments to map the numbers to colors.</p></li><li><p><code>interpolate::Bool = false</code> sets whether colors should be interpolated.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = true</code> enables lighting.</p></li><li><p><code>diffuse::Vec3f = Vec3f(0.4)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.2)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="mesh!"><a href="#mesh!">mesh!</a></div><div class="doc-content"><pre><code>mesh(x, y, z)
mesh(mesh_object)
mesh(x, y, z, faces)
mesh(xyz, faces)</code></pre><p>Plots a 3D or 2D mesh. Supported <code>mesh_object</code>s include <code>Mesh</code> types from <a href="https://github.com/JuliaGeometry/GeometryBasics.jl">GeometryBasics.jl</a>.</p><h2>Attributes</h2><h3>Specific to <code>Mesh</code></h3><ul><li><p><code>color=theme(scene, :patchcolor)</code> sets the color of the mesh. Can be a <code>Vector{&lt;:Colorant}</code> for per vertex colors or a single <code>Colorant</code>.  A <code>Matrix{&lt;:Colorant}</code> can be used to color the mesh with a texture, which requires the mesh to contain texture coordinates.  Vector or Matrices of numbers can be used as well, which will use the colormap arguments to map the numbers to colors.</p></li><li><p><code>interpolate::Bool = false</code> sets whether colors should be interpolated.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = true</code> enables lighting.</p></li><li><p><code>diffuse::Vec3f = Vec3f(0.4)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.2)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="meshscatter"><a href="#meshscatter">meshscatter</a></div><div class="doc-content"><pre><code>meshscatter(positions)
meshscatter(x, y)
meshscatter(x, y, z)</code></pre><p>Plots a mesh for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code> (similar to <code>scatter</code>). <code>markersize</code> is a scaling applied to the primitive passed as <code>marker</code>.</p><h2>Attributes</h2><h3>Specific to <code>MeshScatter</code></h3><ul><li><p><code>color = theme(scene, :markercolor)</code> sets the color of the marker. If no color is set, multiple calls to <code>meshscatter!</code> will cycle through the axis color palette. Otherwise, one can set one color per point by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole meshscatterplot. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>marker::Union{Symbol, GeometryBasics.GeometryPrimitive, GeometryBasics.Mesh}</code> sets the scattered mesh.</p></li><li><p><code>markersize::Union{&lt;:Real, Vec3f} = 0.1</code> sets the scale of the mesh. This can be given as a Vector to apply to each scattered mesh individually.</p></li><li><p><code>rotations::Union{Real, Vec3f, Quaternion} = 0</code> sets the rotation of the mesh. A numeric rotation is around the z-axis, a <code>Vec3f</code> causes the mesh to rotate such that the the z-axis is now that vector, and a quaternion describes a general rotation. This can be given as a Vector to apply to each scattered mesh individually.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = true</code> enables lighting.</p></li><li><p><code>diffuse::Vec3f = Vec3f(0.4)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.2)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="meshscatter!"><a href="#meshscatter!">meshscatter!</a></div><div class="doc-content"><pre><code>meshscatter(positions)
meshscatter(x, y)
meshscatter(x, y, z)</code></pre><p>Plots a mesh for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code> (similar to <code>scatter</code>). <code>markersize</code> is a scaling applied to the primitive passed as <code>marker</code>.</p><h2>Attributes</h2><h3>Specific to <code>MeshScatter</code></h3><ul><li><p><code>color = theme(scene, :markercolor)</code> sets the color of the marker. If no color is set, multiple calls to <code>meshscatter!</code> will cycle through the axis color palette. Otherwise, one can set one color per point by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole meshscatterplot. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>marker::Union{Symbol, GeometryBasics.GeometryPrimitive, GeometryBasics.Mesh}</code> sets the scattered mesh.</p></li><li><p><code>markersize::Union{&lt;:Real, Vec3f} = 0.1</code> sets the scale of the mesh. This can be given as a Vector to apply to each scattered mesh individually.</p></li><li><p><code>rotations::Union{Real, Vec3f, Quaternion} = 0</code> sets the rotation of the mesh. A numeric rotation is around the z-axis, a <code>Vec3f</code> causes the mesh to rotate such that the the z-axis is now that vector, and a quaternion describes a general rotation. This can be given as a Vector to apply to each scattered mesh individually.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = true</code> enables lighting.</p></li><li><p><code>diffuse::Vec3f = Vec3f(0.4)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.2)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="mouse_buttons"><a href="#mouse_buttons">mouse_buttons</a></div><div class="doc-content"><p>Registers a callback for the mouse buttons + modifiers returns <code>Observable{NTuple{4, Int}}</code><a href="http://www.glfw.org/docs/latest/group__input.html#ga1e008c7a8751cea648c8f42cc91104cf">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="mouse_position"><a href="#mouse_position">mouse_position</a></div><div class="doc-content"><p>Registers a callback for the mouse cursor position. returns an <code>Observable{Vec{2, Float64}}</code>, which is not in scene coordinates, with the upper left window corner being 0 <a href="http://www.glfw.org/docs/latest/group__input.html#ga1e008c7a8751cea648c8f42cc91104cf">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="mouse_selection"><a href="#mouse_selection">mouse_selection</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.mouse_selection</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "mouse_selection" from Makie:
 [1] mouse_selection(args...; kwargs...)
     @ deprecated.jl:113</code></pre></div></div><div class="docstring"><div class="doc-header" id="mouseover"><a href="#mouseover">mouseover</a></div><div class="doc-content"><pre><code>mouseover(fig/ax/scene, plots::AbstractPlot...)</code></pre><p>Returns true if the mouse currently hovers any of <code>plots</code>.</p></div></div><div class="docstring"><div class="doc-header" id="mouseposition"><a href="#mouseposition">mouseposition</a></div><div class="doc-content"><pre><code>mouseposition(scene = hovered_scene())</code></pre><p>Return the current position of the mouse in <em>data coordinates</em> of the given <code>scene</code>.</p><p>By default uses the <code>scene</code> that the mouse is currently hovering over.</p></div></div><div class="docstring"><div class="doc-header" id="mouseposition_px"><a href="#mouseposition_px">mouseposition_px</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.mouseposition_px</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "mouseposition_px" from Makie:
 [1] mouseposition_px()
     @ ~/work/Makie.jl/Makie.jl/src/interaction/interactive_api.jl:196
 [2] mouseposition_px(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/interactive_api.jl:196
 [3] mouseposition_px(x)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/interactive_api.jl:195</code></pre></div></div><div class="docstring"><div class="doc-header" id="ncols"><a href="#ncols">ncols</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.ncols</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "ncols" from GridLayoutBase:
 [1] ncols(g::GridLayout)
     @ ~/.julia/packages/GridLayoutBase/kiave/src/gridlayout.jl:1583</code></pre></div></div><div class="docstring"><div class="doc-header" id="nrows"><a href="#nrows">nrows</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.nrows</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "nrows" from GridLayoutBase:
 [1] nrows(g::GridLayout)
     @ ~/.julia/packages/GridLayoutBase/kiave/src/gridlayout.jl:1582</code></pre></div></div><div class="docstring"><div class="doc-header" id="off"><a href="#off">off</a></div><div class="doc-content"><pre><code>off(observable::AbstractObservable, f)</code></pre><p>Removes <code>f</code> from listeners of <code>observable</code>.</p><p>Returns <code>true</code> if <code>f</code> could be removed, otherwise <code>false</code>.</p><pre><code>off(obsfunc::ObserverFunction)</code></pre><p>Remove the listener function <code>obsfunc.f</code> from the listeners of <code>obsfunc.observable</code>. Once <code>obsfunc</code> goes out of scope, this should allow <code>obsfunc.f</code> and all the values it might have closed over to be garbage collected (unless there are other references to it).</p></div></div><div class="docstring"><div class="doc-header" id="old_cam3d!"><a href="#old_cam3d!">old_cam3d!</a></div><div class="doc-content"><pre><code>old_cam3d_turntable!(scene; kw_args...)</code></pre><p>Creates a 3D camera for <code>scene</code>, which rotates around the plot's axis.</p></div></div><div class="docstring"><div class="doc-header" id="old_cam3d_cad!"><a href="#old_cam3d_cad!">old_cam3d_cad!</a></div><div class="doc-content"><pre><code>old_cam3d_cad!(scene; kw_args...)</code></pre><p>Creates a 3D camera for <code>scene</code> which rotates around the <em>viewer</em>'s "up" axis - similarly to how it's done in CAD software cameras.</p></div></div><div class="docstring"><div class="doc-header" id="on"><a href="#on">on</a></div><div class="doc-content"><pre><code>on(f, observable::AbstractObservable; weak = false, priority=0, update=false)::ObserverFunction</code></pre><p>Adds function <code>f</code> as listener to <code>observable</code>. Whenever <code>observable</code>'s value is set via <code>observable[] = val</code>, <code>f</code> is called with <code>val</code>.</p><p>Returns an <a href="@ref"><code>ObserverFunction</code></a> that wraps <code>f</code> and <code>observable</code> and allows to disconnect easily by calling <code>off(observerfunction)</code> instead of <code>off(f, observable)</code>. If instead you want to compute a new <code>Observable</code> from an old one, use <a href="@ref"><code>map(f, ::Observable)</code></a>.</p><p>If <code>weak = true</code> is set, the new connection will be removed as soon as the returned <code>ObserverFunction</code> is not referenced anywhere and is garbage collected. This is useful if some parent object makes connections to outside observables and stores the resulting <code>ObserverFunction</code> instances. Then, once that parent object is garbage collected, the weak observable connections are removed automatically.</p><h1>Example</h1><pre><code class="language-julia">julia&gt; obs = Observable(0)
Observable(0)

julia&gt; on(obs) do val
           println("current value is ", val)
       end
ObserverFunction defined at REPL[17]:2 operating on Observable(0)
julia&gt; obs[] = 5;
current value is 5</code></pre><p>One can also give the callback a priority, to enable always calling a specific callback before/after others, independent of the order of registration. The callback with the highest priority gets called first, the default is zero, and the whole range of Int can be used. So one can do:</p><pre><code class="language-julia">julia&gt; obs = Observable(0)
julia&gt; on(obs; priority=-1) do x
           println("Hi from first added")
       end
julia&gt; on(obs) do x
           println("Hi from second added")
       end
julia&gt; obs[] = 2
Hi from second added
Hi from first added</code></pre><p>If you set <code>update=true</code>, on will call f(obs[]) immediately:</p><pre><code class="language-julia">julia&gt; on(Observable(1); update=true) do x
    println("hi")
end
hi</code></pre><pre><code>on(f, c::Camera, observables::Observable...)</code></pre><p>When mapping over observables for the camera, we store them in the <code>steering_node</code> vector, to make it easier to disconnect the camera steering signals later!</p></div></div><div class="docstring"><div class="doc-header" id="onany"><a href="#onany">onany</a></div><div class="doc-content"><pre><code>onany(f, args...)</code></pre><p>Calls <code>f</code> on updates to any observable refs in <code>args</code>. <code>args</code> may contain any number of <code>Observable</code> objects. <code>f</code> will be passed the values contained in the refs as the respective argument. All other objects in <code>args</code> are passed as-is.</p><p>See also: <a href="@ref"><code>on</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousedownoutside"><a href="#onmousedownoutside">onmousedownoutside</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === downoutside</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseenter"><a href="#onmouseenter">onmouseenter</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === enter</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftclick"><a href="#onmouseleftclick">onmouseleftclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdoubleclick"><a href="#onmouseleftdoubleclick">onmouseleftdoubleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdoubleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdown"><a href="#onmouseleftdown">onmouseleftdown</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdown</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdrag"><a href="#onmouseleftdrag">onmouseleftdrag</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdrag</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdragstart"><a href="#onmouseleftdragstart">onmouseleftdragstart</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdragstart</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdragstop"><a href="#onmouseleftdragstop">onmouseleftdragstop</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdragstop</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftup"><a href="#onmouseleftup">onmouseleftup</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftup</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddleclick"><a href="#onmousemiddleclick">onmousemiddleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledoubleclick"><a href="#onmousemiddledoubleclick">onmousemiddledoubleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledoubleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledown"><a href="#onmousemiddledown">onmousemiddledown</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledown</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledrag"><a href="#onmousemiddledrag">onmousemiddledrag</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledrag</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledragstart"><a href="#onmousemiddledragstart">onmousemiddledragstart</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledragstart</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledragstop"><a href="#onmousemiddledragstop">onmousemiddledragstop</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledragstop</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddleup"><a href="#onmousemiddleup">onmousemiddleup</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middleup</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseout"><a href="#onmouseout">onmouseout</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === out</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseover"><a href="#onmouseover">onmouseover</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === over</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightclick"><a href="#onmouserightclick">onmouserightclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdoubleclick"><a href="#onmouserightdoubleclick">onmouserightdoubleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdoubleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdown"><a href="#onmouserightdown">onmouserightdown</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdown</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdrag"><a href="#onmouserightdrag">onmouserightdrag</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdrag</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdragstart"><a href="#onmouserightdragstart">onmouserightdragstart</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdragstart</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdragstop"><a href="#onmouserightdragstop">onmouserightdragstop</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdragstop</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightup"><a href="#onmouserightup">onmouserightup</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightup</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onpick"><a href="#onpick">onpick</a></div><div class="doc-content"><pre><code>onpick(func, plot)</code></pre><p>Calls <code>func</code> if one clicks on <code>plot</code>.  Implemented by the backend.</p><pre><code>onpick(f, fig/ax/scene, plots::AbstractPlot...)</code></pre><p>Calls <code>f(plot, idx)</code> whenever the mouse is over any of <code>plots</code>. <code>idx</code> is an index, e.g. when over a scatter plot, it will be the index of the hovered element</p></div></div><div class="docstring"><div class="doc-header" id="pick"><a href="#pick">pick</a></div><div class="doc-content"><p>Picks a mouse position.  Implemented by the backend.</p><pre><code>pick(fig/ax/scene, x, y)</code></pre><p>Returns the plot under pixel position <code>(x, y)</code>.</p><pre><code>pick(fig/ax/scene, xy::VecLike)</code></pre><p>Return the plot under pixel position xy.</p><pre><code>pick(fig/ax/scene, xy::VecLike, range)</code></pre><p>Return the plot closest to xy within a given range.</p><pre><code>pick(scene::Scene, rect::Rect2i)</code></pre><p>Return all <code>(plot, index)</code> pairs within the given rect. The rect must be within screen boundaries.</p></div></div><div class="docstring"><div class="doc-header" id="pie"><a href="#pie">pie</a></div><div class="doc-content"><pre><code>pie(fractions; kwargs...)</code></pre><p>Creates a pie chart with the given <code>fractions</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.pie}</code> are: </p><pre><code>  color           :gray
  inner_radius    0
  inspectable     true
  normalize       true
  offset          0
  radius          1
  strokecolor     :black
  strokewidth     1
  transparency    false
  vertex_per_deg  1
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="pie!"><a href="#pie!">pie!</a></div><div class="doc-content"><pre><code>pie(fractions; kwargs...)</code></pre><p>Creates a pie chart with the given <code>fractions</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.pie!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="pixelarea"><a href="#pixelarea">pixelarea</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.pixelarea</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "pixelarea" from Makie:
 [1] pixelarea(scene::Scene)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:546
 [2] pixelarea(scene::Union{AbstractScene, MakieCore.ScenePlot})
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:547
 [3] pixelarea(x)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:545</code></pre></div></div><div class="docstring"><div class="doc-header" id="plot"><a href="#plot">plot</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.plot</code> is a <code>Function</code>.</p><pre><code># 5 methods for generic function "plot" from MakieCore:
 [1] plot(P::Union{Type{Any}, Type{&lt;:AbstractPlot}}, gsp::GridSubposition, args...; axis, kw_attributes...)
     @ Makie ~/work/Makie.jl/Makie.jl/src/figureplotting.jl:115
 [2] plot(P::Union{Type{Any}, Type{&lt;:AbstractPlot}}, gp::GridPosition, args...; axis, kw_attributes...)
     @ Makie ~/work/Makie.jl/Makie.jl/src/figureplotting.jl:82
 [3] plot(P::Union{Type{Any}, Type{&lt;:AbstractPlot}}, args...; axis, figure, kw_attributes...)
     @ Makie ~/work/Makie.jl/Makie.jl/src/figureplotting.jl:58
 [4] plot(scene::Scene, plot::AbstractPlot)
     @ Makie ~/work/Makie.jl/Makie.jl/src/interfaces.jl:163
 [5] plot(args...; attributes...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:34</code></pre></div></div><div class="docstring"><div class="doc-header" id="plot!"><a href="#plot!">plot!</a></div><div class="doc-content"><p>Main plotting signatures that plot/plot! route to if no Plot Type is given</p></div></div><div class="docstring"><div class="doc-header" id="plotkey"><a href="#plotkey">plotkey</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.plotkey</code> is a <code>Function</code>.</p><pre><code># 4 methods for generic function "plotkey" from MakieCore:
 [1] plotkey(::Type{&lt;:AbstractPlot{Typ}}) where Typ
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:21
 [2] plotkey(::T) where T&lt;:AbstractPlot
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:22
 [3] plotkey(::Nothing)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:23
 [4] plotkey(any)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:24</code></pre></div></div><div class="docstring"><div class="doc-header" id="plots"><a href="#plots">plots</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.plots</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "plots" from Makie:
 [1] plots(scene::Union{AbstractScene, MakieCore.ScenePlot})
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:550
 [2] plots(x)
     @ ~/work/Makie.jl/Makie.jl/src/scenes.jl:549</code></pre></div></div><div class="docstring"><div class="doc-header" id="poly"><a href="#poly">poly</a></div><div class="doc-content"><pre><code>poly(vertices, indices; kwargs...)
poly(points; kwargs...)
poly(shape; kwargs...)
poly(mesh; kwargs...)</code></pre><p>Plots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to <code>mesh</code>. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by <code>GeometryBasics</code>), it will plot <code>decompose(shape)</code>.</p><pre><code>poly(coordinates, connectivity; kwargs...)</code></pre><p>Plots polygons, which are defined by <code>coordinates</code> (the coordinates of the vertices) and <code>connectivity</code> (the edges between the vertices).</p><h2>Attributes</h2><h3>Specific to <code>Poly</code></h3><ul><li><p><code>color=theme(scene, :patchcolor)</code> sets the color of the poly. Can be a <code>Vector{&lt;:Colorant}</code> for per vertex colors or a single <code>Colorant</code>.  A <code>Matrix{&lt;:Colorant}</code> can be used to color the mesh with a texture, which requires the mesh to contain texture coordinates.  Vector or Matrices of numbers can be used as well, which will use the colormap arguments to map the numbers to colors.  One can also use <code>Makie.LinePattern</code>, to cover the poly with a regular stroke pattern.</p></li><li><p><code>strokecolor::Union{Symbol, &lt;:Colorant} = :black</code> sets the color of the outline around a marker.</p></li><li><p><code>strokecolormap</code>::Union{Symbol, Vector{&lt;:Colorant}} = :viridis<code>sets the colormap that is sampled for numeric</code>color`s.</p></li><li><p><code>strokewidth::Real = 0</code> sets the width of the outline around a marker.</p></li><li><p><code>linestyle::Union{Nothing, Symbol, Vector} = nothing</code> sets the pattern of the line (e.g. <code>:solid</code>, <code>:dot</code>, <code>:dashdot</code>)</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="poly!"><a href="#poly!">poly!</a></div><div class="doc-content"><pre><code>poly(vertices, indices; kwargs...)
poly(points; kwargs...)
poly(shape; kwargs...)
poly(mesh; kwargs...)</code></pre><p>Plots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to <code>mesh</code>. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by <code>GeometryBasics</code>), it will plot <code>decompose(shape)</code>.</p><pre><code>poly(coordinates, connectivity; kwargs...)</code></pre><p>Plots polygons, which are defined by <code>coordinates</code> (the coordinates of the vertices) and <code>connectivity</code> (the edges between the vertices).</p><h2>Attributes</h2><h3>Specific to <code>Poly</code></h3><ul><li><p><code>color=theme(scene, :patchcolor)</code> sets the color of the poly. Can be a <code>Vector{&lt;:Colorant}</code> for per vertex colors or a single <code>Colorant</code>.  A <code>Matrix{&lt;:Colorant}</code> can be used to color the mesh with a texture, which requires the mesh to contain texture coordinates.  Vector or Matrices of numbers can be used as well, which will use the colormap arguments to map the numbers to colors.  One can also use <code>Makie.LinePattern</code>, to cover the poly with a regular stroke pattern.</p></li><li><p><code>strokecolor::Union{Symbol, &lt;:Colorant} = :black</code> sets the color of the outline around a marker.</p></li><li><p><code>strokecolormap</code>::Union{Symbol, Vector{&lt;:Colorant}} = :viridis<code>sets the colormap that is sampled for numeric</code>color`s.</p></li><li><p><code>strokewidth::Real = 0</code> sets the width of the outline around a marker.</p></li><li><p><code>linestyle::Union{Nothing, Symbol, Vector} = nothing</code> sets the pattern of the line (e.g. <code>:solid</code>, <code>:dot</code>, <code>:dashdot</code>)</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="px"><a href="#px">px</a></div><div class="doc-content"><p>Unit in pixels on screen. This one is a bit tricky, since it refers to a static attribute (pixels on screen don't change) but since every visual is attached to a camera, the exact scale might change. So in the end, this is just relative to some normed camera - the value on screen, depending on the camera, will not actually sit on those pixels. Only camera that guarantees the correct mapping is the <code>:pixel</code> camera type.</p></div></div><div class="docstring"><div class="doc-header" id="qqnorm"><a href="#qqnorm">qqnorm</a></div><div class="doc-content"><pre><code>qqnorm(y; kwargs...)</code></pre><p>Shorthand for <code>qqplot(Normal(0,1), y)</code>, i.e., draw a Q-Q plot of <code>y</code> against the standard normal distribution. See <code>qqplot</code> for more details.</p></div></div><div class="docstring"><div class="doc-header" id="qqnorm!"><a href="#qqnorm!">qqnorm!</a></div><div class="doc-content"><pre><code>qqnorm(y; kwargs...)</code></pre><p>Shorthand for <code>qqplot(Normal(0,1), y)</code>, i.e., draw a Q-Q plot of <code>y</code> against the standard normal distribution. See <code>qqplot</code> for more details.</p></div></div><div class="docstring"><div class="doc-header" id="qqplot"><a href="#qqplot">qqplot</a></div><div class="doc-content"><pre><code>qqplot(x, y; kwargs...)</code></pre><p>Draw a Q-Q plot, comparing quantiles of two distributions. <code>y</code> must be a list of samples, i.e., <code>AbstractVector{&lt;:Real}</code>, whereas <code>x</code> can be</p><ul><li><p>a list of samples,</p></li><li><p>an abstract distribution, e.g. <code>Normal(0, 1)</code>,</p></li><li><p>a distribution type, e.g. <code>Normal</code>.</p></li></ul><p>In the last case, the distribution type is fitted to the data <code>y</code>.</p><p>The attribute <code>qqline</code> (defaults to <code>:none</code>) determines how to compute a fit line for the Q-Q plot. Possible values are the following.</p><ul><li><p><code>:identity</code> draws the identity line.</p></li><li><p><code>:fit</code> computes a least squares line fit of the quantile pairs.</p></li><li><p><code>:fitrobust</code> computes the line that passes through the first and third quartiles of the distributions.</p></li><li><p><code>:none</code> omits drawing the line.</p></li></ul><p>Broadly speaking, <code>qqline = :identity</code> is useful to see if <code>x</code> and <code>y</code> follow the same distribution, whereas <code>qqline = :fit</code> and <code>qqline = :fitrobust</code> are useful to see if the distribution of <code>y</code> can be obtained from the distribution of <code>x</code> via an affine transformation.</p><p>Graphical attributes are</p><ul><li><p><code>color</code> to control color of both line and markers (if <code>markercolor</code> is not specified)</p></li><li><p><code>linestyle</code></p></li><li><p><code>linewidth</code></p></li><li><p><code>markercolor</code></p></li><li><p><code>strokecolor</code></p></li><li><p><code>strokewidth</code></p></li><li><p><code>marker</code></p></li><li><p><code>markersize</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="qqplot!"><a href="#qqplot!">qqplot!</a></div><div class="doc-content"><pre><code>qqplot(x, y; kwargs...)</code></pre><p>Draw a Q-Q plot, comparing quantiles of two distributions. <code>y</code> must be a list of samples, i.e., <code>AbstractVector{&lt;:Real}</code>, whereas <code>x</code> can be</p><ul><li><p>a list of samples,</p></li><li><p>an abstract distribution, e.g. <code>Normal(0, 1)</code>,</p></li><li><p>a distribution type, e.g. <code>Normal</code>.</p></li></ul><p>In the last case, the distribution type is fitted to the data <code>y</code>.</p><p>The attribute <code>qqline</code> (defaults to <code>:none</code>) determines how to compute a fit line for the Q-Q plot. Possible values are the following.</p><ul><li><p><code>:identity</code> draws the identity line.</p></li><li><p><code>:fit</code> computes a least squares line fit of the quantile pairs.</p></li><li><p><code>:fitrobust</code> computes the line that passes through the first and third quartiles of the distributions.</p></li><li><p><code>:none</code> omits drawing the line.</p></li></ul><p>Broadly speaking, <code>qqline = :identity</code> is useful to see if <code>x</code> and <code>y</code> follow the same distribution, whereas <code>qqline = :fit</code> and <code>qqline = :fitrobust</code> are useful to see if the distribution of <code>y</code> can be obtained from the distribution of <code>x</code> via an affine transformation.</p><p>Graphical attributes are</p><ul><li><p><code>color</code> to control color of both line and markers (if <code>markercolor</code> is not specified)</p></li><li><p><code>linestyle</code></p></li><li><p><code>linewidth</code></p></li><li><p><code>markercolor</code></p></li><li><p><code>strokecolor</code></p></li><li><p><code>strokewidth</code></p></li><li><p><code>marker</code></p></li><li><p><code>markersize</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="qrotation"><a href="#qrotation">qrotation</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.qrotation</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "qrotation" from Makie:
 [1] qrotation(axis::StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, theta::Number)
     @ ~/work/Makie.jl/Makie.jl/src/utilities/quaternions.jl:39</code></pre></div></div><div class="docstring"><div class="doc-header" id="quiver"><a href="#quiver">quiver</a></div><div class="doc-content"><pre><code>arrows(points, directions; kwargs...)
arrows(x, y, u, v)
arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)
arrows(x, y, z, u, v, w)
arrows(x, y, [z], f::Function)</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each 'row' is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p><p>If a <code>Function</code> is provided in place of <code>u, v, [w]</code>, then it must accept a <code>Point</code> as input, and return an appropriately dimensioned <code>Point</code>, <code>Vec</code>, or other array-like output.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Arrows</code> are: </p><pre><code>  align           :origin
  alpha           1.0
  arrowcolor      MakieCore.Automatic()
  arrowhead       MakieCore.Automatic()
  arrowsize       MakieCore.Automatic()
  arrowtail       MakieCore.Automatic()
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  depth_shift     0.0f0
  diffuse         0.4
  highclip        MakieCore.Automatic()
  inspectable     true
  lengthscale     1.0f0
  linecolor       MakieCore.Automatic()
  linestyle       "nothing"
  linewidth       MakieCore.Automatic()
  lowclip         MakieCore.Automatic()
  markerspace     :pixel
  nan_color       :transparent
  normalize       false
  overdraw        false
  quality         32
  shininess       32.0f0
  space           :data
  specular        0.2
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="quiver!"><a href="#quiver!">quiver!</a></div><div class="doc-content"><p>See <a href="@ref"><code>arrows</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="rainclouds"><a href="#rainclouds">rainclouds</a></div><div class="doc-content"><pre><code>rainclouds!(ax, category_labels, data_array; plot_boxplots=true, plot_clouds=true, kwargs...)</code></pre><p>Plot a violin (/histogram), boxplot and individual data points with appropriate spacing between each.</p><h1>Arguments</h1><ul><li><p><code>ax</code>: Axis used to place all these plots onto.</p></li><li><p><code>category_labels</code>: Typically <code>Vector{String}</code> with a label for each element in <code>data_array</code></p></li><li><p><code>data_array</code>: Typically <code>Vector{Float64}</code> used for to represent the datapoints to plot.</p></li></ul><h1>Keywords</h1><ul><li><p><code>gap=0.2</code>: Distance between elements of x-axis.</p></li><li><p><code>side=:left</code>: Can take values of <code>:left</code>, <code>:right</code>, determines where the violin plot will be, relative to the scatter points</p></li><li><p><code>dodge</code>: vector of <code>Integer</code>` (length of data) of grouping variable to create multiple side-by-side boxes at the same x position</p></li><li><p><code>dodge_gap = 0.03</code>: spacing between dodged boxes</p></li><li><p><code>n_dodge</code>: the number of categories to dodge (defaults to maximum(dodge))</p></li><li><p><code>color</code>: a single color, or a vector of colors, one for each point</p></li></ul><h2>Violin/Histogram Plot Specific Keywords</h2><ul><li><p><code>clouds=violin</code>: [violin, hist, nothing] to show cloud plots either as violin or histogram plot, or no cloud plot.</p></li><li><p><code>hist_bins=30</code>: if <code>clouds=hist</code>, this passes down the number of bins to the histogram call.</p></li><li><p><code>cloud_width=1.0</code>: Determines size of violin plot. Corresponds to <code>width</code> keyword arg in</p></li></ul><p><code>violin</code>.</p><ul><li><p><code>orientation=:vertical</code> orientation of raindclouds (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>violin_limits=(-Inf, Inf)</code>: specify values to trim the <code>violin</code>. Can be a <code>Tuple</code> or a <code>Function</code> (e.g. <code>datalimits=extrema</code>)</p></li></ul><h2>Box Plot Specific Keywords</h2><ul><li><p><code>plot_boxplots=true</code>: Boolean to show boxplots to summarize distribution of data.</p></li><li><p><code>boxplot_width=0.1</code>: Width of the boxplot in category x-axis absolute terms.</p></li><li><p><code>center_boxplot=true</code>: Determines whether or not to have the boxplot be centered in the category.</p></li><li><p><code>whiskerwidth=0.5</code>: The width of the Q1, Q3 whisker in the boxplot. Value as a portion of the <code>boxplot_width</code>.</p></li><li><p><code>strokewidth=1.0</code>: Determines the stroke width for the outline of the boxplot.</p></li><li><p><code>show_median=true</code>: Determines whether or not to have a line should the median value in the boxplot.</p></li><li><p><code>boxplot_nudge=0.075</code>: Determines the distance away the boxplot should be placed from the   center line when <code>center_boxplot</code> is <code>false</code>. This is the value used to recentering the   boxplot.</p></li><li><p><code>show_boxplot_outliers</code>: show outliers in the boxplot as points (usually confusing when</p></li></ul><p>paired with the scatter plot so the default is to not show them)</p><h2>Scatter Plot Specific Keywords</h2><ul><li><p><code>side_nudge</code>: Default value is 0.02 if <code>plot_boxplots</code> is true, otherwise <code>0.075</code> default.</p></li><li><p><code>jitter_width=0.05</code>: Determines the width of the scatter-plot bar in category x-axis absolute terms.</p></li><li><p><code>markersize=2</code>: Size of marker used for the scatter plot.</p></li></ul><h2>Axis General Keywords</h2><ul><li><p><code>title</code></p></li><li><p><code>xlabel</code></p></li><li><p><code>ylabel</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="rainclouds!"><a href="#rainclouds!">rainclouds!</a></div><div class="doc-content"><pre><code>rainclouds!(ax, category_labels, data_array; plot_boxplots=true, plot_clouds=true, kwargs...)</code></pre><p>Plot a violin (/histogram), boxplot and individual data points with appropriate spacing between each.</p><h1>Arguments</h1><ul><li><p><code>ax</code>: Axis used to place all these plots onto.</p></li><li><p><code>category_labels</code>: Typically <code>Vector{String}</code> with a label for each element in <code>data_array</code></p></li><li><p><code>data_array</code>: Typically <code>Vector{Float64}</code> used for to represent the datapoints to plot.</p></li></ul><h1>Keywords</h1><ul><li><p><code>gap=0.2</code>: Distance between elements of x-axis.</p></li><li><p><code>side=:left</code>: Can take values of <code>:left</code>, <code>:right</code>, determines where the violin plot will be, relative to the scatter points</p></li><li><p><code>dodge</code>: vector of <code>Integer</code>` (length of data) of grouping variable to create multiple side-by-side boxes at the same x position</p></li><li><p><code>dodge_gap = 0.03</code>: spacing between dodged boxes</p></li><li><p><code>n_dodge</code>: the number of categories to dodge (defaults to maximum(dodge))</p></li><li><p><code>color</code>: a single color, or a vector of colors, one for each point</p></li></ul><h2>Violin/Histogram Plot Specific Keywords</h2><ul><li><p><code>clouds=violin</code>: [violin, hist, nothing] to show cloud plots either as violin or histogram plot, or no cloud plot.</p></li><li><p><code>hist_bins=30</code>: if <code>clouds=hist</code>, this passes down the number of bins to the histogram call.</p></li><li><p><code>cloud_width=1.0</code>: Determines size of violin plot. Corresponds to <code>width</code> keyword arg in</p></li></ul><p><code>violin</code>.</p><ul><li><p><code>orientation=:vertical</code> orientation of raindclouds (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>violin_limits=(-Inf, Inf)</code>: specify values to trim the <code>violin</code>. Can be a <code>Tuple</code> or a <code>Function</code> (e.g. <code>datalimits=extrema</code>)</p></li></ul><h2>Box Plot Specific Keywords</h2><ul><li><p><code>plot_boxplots=true</code>: Boolean to show boxplots to summarize distribution of data.</p></li><li><p><code>boxplot_width=0.1</code>: Width of the boxplot in category x-axis absolute terms.</p></li><li><p><code>center_boxplot=true</code>: Determines whether or not to have the boxplot be centered in the category.</p></li><li><p><code>whiskerwidth=0.5</code>: The width of the Q1, Q3 whisker in the boxplot. Value as a portion of the <code>boxplot_width</code>.</p></li><li><p><code>strokewidth=1.0</code>: Determines the stroke width for the outline of the boxplot.</p></li><li><p><code>show_median=true</code>: Determines whether or not to have a line should the median value in the boxplot.</p></li><li><p><code>boxplot_nudge=0.075</code>: Determines the distance away the boxplot should be placed from the   center line when <code>center_boxplot</code> is <code>false</code>. This is the value used to recentering the   boxplot.</p></li><li><p><code>show_boxplot_outliers</code>: show outliers in the boxplot as points (usually confusing when</p></li></ul><p>paired with the scatter plot so the default is to not show them)</p><h2>Scatter Plot Specific Keywords</h2><ul><li><p><code>side_nudge</code>: Default value is 0.02 if <code>plot_boxplots</code> is true, otherwise <code>0.075</code> default.</p></li><li><p><code>jitter_width=0.05</code>: Determines the width of the scatter-plot bar in category x-axis absolute terms.</p></li><li><p><code>markersize=2</code>: Size of marker used for the scatter plot.</p></li></ul><h2>Axis General Keywords</h2><ul><li><p><code>title</code></p></li><li><p><code>xlabel</code></p></li><li><p><code>ylabel</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="rangebars"><a href="#rangebars">rangebars</a></div><div class="doc-content"><pre><code>rangebars(val, low, high; kwargs...)
rangebars(val, low_high; kwargs...)
rangebars(val_low_high; kwargs...)</code></pre><p>Plots rangebars at <code>val</code> in one dimension, extending from <code>low</code> to <code>high</code> in the other dimension given the chosen <code>direction</code>.</p><p>If you want to plot errors relative to a reference value, use <code>errorbars</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.rangebars}</code> are: </p><pre><code>  color         :black
  colormap      :viridis
  colorrange    MakieCore.Automatic()
  colorscale    identity
  direction     :y
  inspectable   true
  linewidth     1.5
  transparency  false
  visible       true
  whiskerwidth  0</code></pre></div></div><div class="docstring"><div class="doc-header" id="rangebars!"><a href="#rangebars!">rangebars!</a></div><div class="doc-content"><pre><code>rangebars(val, low, high; kwargs...)
rangebars(val, low_high; kwargs...)
rangebars(val_low_high; kwargs...)</code></pre><p>Plots rangebars at <code>val</code> in one dimension, extending from <code>low</code> to <code>high</code> in the other dimension given the chosen <code>direction</code>.</p><p>If you want to plot errors relative to a reference value, use <code>errorbars</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.rangebars!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="record"><a href="#record">record</a></div><div class="doc-content"><pre><code>record(func, figurelike, path; backend=current_backend(), kwargs...)
record(func, figurelike, path, iter; backend=current_backend(), kwargs...)</code></pre><p>The first signature provides <code>func</code> with a VideoStream, which it should call <code>recordframe!(io)</code> on when recording a frame.</p><p>The second signature iterates <code>iter</code>, calling <code>recordframe!(io)</code> internally after calling <code>func</code> with the current iteration element.</p><p>Both notations require a Figure, FigureAxisPlot or Scene <code>figure</code> to work. The animation is then saved to <code>path</code>, with the format determined by <code>path</code>'s extension.</p><p>Under the hood, <code>record</code> is just <code>video_io = Record(func, figurelike, [iter]; same_kw...); save(path, video_io)</code>. <code>Record</code> can be used directly as well to do the saving at a later point, or to inline a video directly into a Notebook (the video supports, <code>show(video_io, "text/html")</code> for that purpose).</p><h1>Options one can pass via <code>kwargs...</code>:</h1><ul><li><p><code>backend::Module = current_backend()</code>: set the backend to write out video, can be set to <code>CairoMakie</code>, <code>GLMakie</code>, <code>WGLMakie</code>, <code>RPRMakie</code>.</p></li></ul><h3>Backend options</h3><p>See <code>?Backend.Screen</code> or <code>Base.doc(Backend.Screen)</code> for applicable options that can be passed and forwarded to the backend.</p><h3>Video options</h3><ul><li><p><code>format = "mkv"</code>: The format of the video. If a path is present, will be inferred form the file extension.   Can be one of the following:</p><ul><li><p><code>"mkv"</code>  (open standard, the default)</p></li><li><p><code>"mp4"</code>  (good for Web, most supported format)</p></li><li><p><code>"webm"</code> (smallest file size)</p></li><li><p><code>"gif"</code>  (largest file size for the same quality)</p></li></ul><p><code>mp4</code> and <code>mk4</code> are marginally bigger than <code>webm</code>. <code>gif</code>s can be significantly (as much as   6x) larger with worse quality (due to the limited color palette) and only should be used   as a last resort, for playing in a context where videos aren't supported.</p></li><li><p><code>framerate = 24</code>: The target framerate.</p></li><li><p><code>compression = 20</code>: Controls the video compression via <code>ffmpeg</code>'s <code>-crf</code> option, with   smaller numbers giving higher quality and larger file sizes (lower compression), and and   higher numbers giving lower quality and smaller file sizes (higher compression). The   minimum value is <code>0</code> (lossless encoding).</p><ul><li><p>For <code>mp4</code>, <code>51</code> is the maximum. Note that <code>compression = 0</code> only works with <code>mp4</code> if</p></li></ul><p><code>profile = high444</code>.</p><ul><li><p>For <code>webm</code>, <code>63</code> is the maximum.</p></li><li><p><code>compression</code> has no effect on <code>mkv</code> and <code>gif</code> outputs.</p></li></ul></li><li><p><code>profile = "high422"</code>: A ffmpeg compatible profile. Currently only applies to <code>mp4</code>. If</p></li></ul><p>you have issues playing a video, try <code>profile = "high"</code> or <code>profile = "main"</code>.</p><ul><li><p><code>pixel_format = "yuv420p"</code>: A ffmpeg compatible pixel format (<code>-pix_fmt</code>). Currently only</p></li></ul><p>applies to <code>mp4</code>. Defaults to <code>yuv444p</code> for <code>profile = high444</code>.</p><ul><li><p><code>loop = 0</code>: Number of times the video is repeated, for a <code>gif</code>. Defaults to <code>0</code>, which</p></li></ul><p>means infinite looping. A value of <code>-1</code> turns off looping, and a value of <code>n &gt; 0</code> and above means <code>n</code> repetitions (i.e. the video is played <code>n+1</code> times).</p><pre><code>!!! warning
`profile` and `pixel_format` are only used when `format` is `"mp4"`; a warning will be issued if `format`
is not `"mp4"` and those two arguments are not `nothing`. Similarly, `compression` is only
valid when `format` is `"mp4"` or `"webm"`, and `loop` is only valid when `format` is `"gif"`.</code></pre><h1>Typical usage</h1><pre><code class="language-julia">record(figure, "video.mp4", itr) do i
    func(i) # or some other manipulation of the figure
end</code></pre><p>or, for more tweakability,</p><pre><code class="language-julia">record(figure, "test.gif") do io
    for i = 1:100
        func!(figure)     # animate figure
        recordframe!(io)  # record a new frame
    end
end</code></pre><p>If you want a more tweakable interface, consider using <a href="@ref"><code>VideoStream</code></a> and <a href="@ref"><code>save</code></a>.</p><h2>Extended help</h2><h3>Examples</h3><pre><code class="language-julia">fig, ax, p = lines(rand(10))
record(fig, "test.gif") do io
    for i in 1:255
        p[:color] = RGBf(i/255, (255 - i)/255, 0) # animate figure
        recordframe!(io)
    end
end</code></pre><p>or</p><pre><code class="language-julia">fig, ax, p = lines(rand(10))
record(fig, "test.gif", 1:255) do i
    p[:color] = RGBf(i/255, (255 - i)/255, 0) # animate figure
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="record_events"><a href="#record_events">record_events</a></div><div class="doc-content"><p>record_events(f, scene::Scene, path::String)</p><p>Records all window events that happen while executing function <code>f</code> for <code>scene</code> and serializes them to <code>path</code>.</p></div></div><div class="docstring"><div class="doc-header" id="recordframe!"><a href="#recordframe!">recordframe!</a></div><div class="doc-content"><pre><code>recordframe!(io::VideoStream)</code></pre><p>Adds a video frame to the VideoStream <code>io</code>.</p></div></div><div class="docstring"><div class="doc-header" id="register_interaction!"><a href="#register_interaction!">register_interaction!</a></div><div class="doc-content"><pre><code>register_interaction!(parent, name::Symbol, interaction)</code></pre><p>Register <code>interaction</code> with <code>parent</code> under the name <code>name</code>. The parent will call <code>process_interaction(interaction, event, parent)</code> whenever suitable events happen.</p><p>The interaction can be removed with <code>deregister_interaction!</code> or temporarily toggled with <code>activate_interaction!</code> / <code>deactivate_interaction!</code>.</p><pre><code>register_interaction!(interaction::Function, parent, name::Symbol)</code></pre><p>Register <code>interaction</code> with <code>parent</code> under the name <code>name</code>. The parent will call <code>process_interaction(interaction, event, parent)</code> whenever suitable events happen. This form with the first <code>Function</code> argument is especially intended for <code>do</code> syntax.</p><p>The interaction can be removed with <code>deregister_interaction!</code> or temporarily toggled with <code>activate_interaction!</code> / <code>deactivate_interaction!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="replace_automatic!"><a href="#replace_automatic!">replace_automatic!</a></div><div class="doc-content"><p>Like <code>get!(f, dict, key)</code> but also calls <code>f</code> and replaces <code>key</code> when the corresponding value is nothing</p></div></div><div class="docstring"><div class="doc-header" id="replay_events"><a href="#replay_events">replay_events</a></div><div class="doc-content"><p>replay<em>events(f, scene::Scene, path::String) replay</em>events(scene::Scene, path::String)</p><p>Replays the serialized events recorded with <code>record_events</code> in <code>path</code> in <code>scene</code>.</p></div></div><div class="docstring"><div class="doc-header" id="resample_cmap"><a href="#resample_cmap">resample_cmap</a></div><div class="doc-content"><pre><code>resample_cmap(cmap, ncolors::Integer; alpha=1.0)</code></pre><ul><li><p>cmap: anything that <code>to_colormap</code> accepts</p></li><li><p>ncolors: number of desired colors</p></li><li><p>alpha: additional alpha applied to each color. Can also be an array, matching <code>colors</code>, or a tuple giving a start + stop alpha value.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="reset_limits!"><a href="#reset_limits!">reset_limits!</a></div><div class="doc-content"><pre><code>reset_limits!(ax; xauto = true, yauto = true)</code></pre><p>Resets the axis limits depending on the value of <code>ax.limits</code>. If one of the two components of limits is nothing, that value is either copied from the targetlimits if <code>xauto</code> or <code>yauto</code> is false, respectively, or it is determined automatically from the plots in the axis. If one of the components is a tuple of two numbers, those are used directly.</p></div></div><div class="docstring"><div class="doc-header" id="resize_to_layout!"><a href="#resize_to_layout!">resize_to_layout!</a></div><div class="doc-content"><pre><code>resize_to_layout!(fig::Figure)</code></pre><p>Resize <code>fig</code> so that it fits the current contents of its top <code>GridLayout</code>. If a <code>GridLayout</code> contains fixed-size content or aspect-constrained columns, for example, it is likely that the solved size of the <code>GridLayout</code> differs from the size of the <code>Figure</code>. This can result in superfluous whitespace at the borders, or content clipping at the figure edges. Once resized, all content should fit the available space, including the <code>Figure</code>'s outer padding.</p></div></div><div class="docstring"><div class="doc-header" id="rich"><a href="#rich">rich</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.rich</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "rich" from Makie:
 [1] rich(args...; kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:286</code></pre></div></div><div class="docstring"><div class="doc-header" id="right"><a href="#right">right</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.right</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "right" from Makie:
 [1] right(rect::Rect2)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:3</code></pre></div></div><div class="docstring"><div class="doc-header" id="rlims!"><a href="#rlims!">rlims!</a></div><div class="doc-content"><pre><code>rlims!(ax::PolarAxis[, rmin], rmax)</code></pre><p>Sets the radial limits of a given <code>PolarAxis</code>.</p></div></div><div class="docstring"><div class="doc-header" id="rotate!"><a href="#rotate!">rotate!</a></div><div class="doc-content"><pre><code>rotate!(Accum, scene::Transformable, axis_rot...)</code></pre><p>Apply a relative rotation to the Scene, by multiplying by the current rotation.</p><pre><code>rotate!(t::Transformable, axis_rot::Quaternion)
rotate!(t::Transformable, axis_rot::AbstractFloat)
rotate!(t::Transformable, axis_rot...)</code></pre><p>Apply an absolute rotation to the Scene. Rotations are all internally converted to <code>Quaternion</code>s.</p></div></div><div class="docstring"><div class="doc-header" id="rotate_cam!"><a href="#rotate_cam!">rotate_cam!</a></div><div class="doc-content"><pre><code>rotate_cam!(scene::Scene, theta_v::Number...)
rotate_cam!(scene::Scene, theta_v::VecTypes)</code></pre><p>Rotate the camera of the Scene by the given rotation. Passing <code>theta_v = (Î±, Î², Î³)</code> will rotate the camera according to the Euler angles (Î±, Î², Î³).</p></div></div><div class="docstring"><div class="doc-header" id="rowgap!"><a href="#rowgap!">rowgap!</a></div><div class="doc-content"><pre><code>rowgap!(gl::GridLayout, i::Integer, s::Union{Fixed, Relative, Real})
rowgap!(gl::GridLayout, s::Union{Fixed, Relative, Real})</code></pre><p>Set the gap between rows in <code>gl</code>.  The two-argument version sets all row gaps in <code>gl</code>.  The three-argument version sets the gap between rows <code>i</code> and <code>i+1</code>. Passing a real number to <code>s</code> has the same behaviour as passing <code>Fixed(s)</code>.</p><p>See also <a href="@ref">Fixed</a> and <a href="@ref">Relative</a>.</p></div></div><div class="docstring"><div class="doc-header" id="rowsize!"><a href="#rowsize!">rowsize!</a></div><div class="doc-content"><pre><code>rowsize!(gl::GridLayout, i::Integer, s::Union{Aspect, Auto, Fixed, Relative, Real})</code></pre><p>Set the size of the <code>i</code>th row in <code>gl</code>, i.e., <code>gl[i, :]</code>. Passing a real number to <code>s</code> has the same behaviour as passing <code>Fixed(s)</code>.</p><p>See also <a href="@ref">Aspect</a>, <a href="@ref">Auto</a>, <a href="@ref">Fixed</a>, and <a href="@ref">Relative</a>.</p></div></div><div class="docstring"><div class="doc-header" id="save"><a href="#save">save</a></div><div class="doc-content"><ul><li><p><code>save(filename, data...)</code> saves the contents of a formatted file, trying to infer the format from <code>filename</code>.</p></li><li><p><code>save(Stream{format"PNG"}(io), data...)</code> specifies the format directly, and bypasses the format <a href="@ref"><code>query</code></a>.</p></li><li><p><code>save(File{format"PNG"}(filename), data...)</code> specifies the format directly, and bypasses the format <a href="@ref"><code>query</code></a>.</p></li><li><p><code>save(f, data...; options...)</code> passes keyword arguments on to the saver.</p></li></ul><pre><code>FileIO.save(filename, scene; resolution = size(scene), pt_per_unit = 0.75, px_per_unit = 1.0)</code></pre><p>Save a <code>Scene</code> with the specified filename and format.</p><h1>Supported Formats</h1><ul><li><p><code>GLMakie</code>: <code>.png</code></p></li><li><p><code>CairoMakie</code>: <code>.svg</code>, <code>.pdf</code> and <code>.png</code></p></li><li><p><code>WGLMakie</code>: <code>.png</code></p></li></ul><h1>Supported Keyword Arguments</h1><h2>All Backends</h2><ul><li><p><code>resolution</code>: <code>(width::Int, height::Int)</code> of the scene in dimensionless units (equivalent to <code>px</code> for GLMakie and WGLMakie).</p></li><li><p><code>update</code>: Whether the figure should be updated before saving. This resets the limits of all Axes in the figure. Defaults to <code>true</code>.</p></li><li><p><code>backend</code>: Specify the <code>Makie</code> backend that should be used for saving. Defaults to the current backend.</p></li><li><p>Further keywords will be forwarded to the screen.</p></li></ul><h2>CairoMakie</h2><ul><li><p><code>pt_per_unit</code>: The size of one scene unit in <code>pt</code> when exporting to a vector format.</p></li><li><p><code>px_per_unit</code>: The size of one scene unit in <code>px</code> when exporting to a bitmap format. This provides a mechanism to export the same scene with higher or lower resolution.</p></li></ul><pre><code>save(path::String, io::VideoStream)</code></pre><p>Flushes the video stream and saves it to <code>path</code>. Ideally, <code>path</code>'s file extension is the same as the format that the <code>VideoStream</code> was created with (e.g., if created with format "mp4" then <code>path</code>'s file extension must be ".mp4"). Otherwise, the video will get converted to the target format. If using <a href="@ref"><code>record</code></a> then this is handled for you, as the <code>VideoStream</code>'s format is deduced from the file extension of the path passed to <code>record</code>.</p></div></div><div class="docstring"><div class="doc-header" id="scale!"><a href="#scale!">scale!</a></div><div class="doc-content"><pre><code>scale!(t::Transformable, x, y)
scale!(t::Transformable, x, y, z)
scale!(t::Transformable, xyz)
scale!(t::Transformable, xyz...)</code></pre><p>Scale the given <code>Transformable</code> (a Scene or Plot) to the given arguments. Can take <code>x, y</code> or <code>x, y, z</code>. This is an absolute scaling, and there is no option to perform relative scaling.</p></div></div><div class="docstring"><div class="doc-header" id="scatter"><a href="#scatter">scatter</a></div><div class="doc-content"><pre><code>scatter(positions)
scatter(x, y)
scatter(x, y, z)</code></pre><p>Plots a marker for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><h2>Attributes</h2><h3>Specific to <code>Scatter</code></h3><ul><li><p><code>color=theme(scene, :markercolor)</code> sets the color of the marker. If no color is set, multiple calls to <code>scatter!</code> will cycle through the axis color palette. Otherwise, one can set one color per point by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole scatterplot. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>marker::Union{Symbol, Char, Matrix{&lt;:Colorant}, BezierPath, Polygon}</code> sets the scatter marker.</p></li><li><p><code>markersize::Union{&lt;:Real, Vec2f} = 9</code> sets the size of the marker.</p></li><li><p><code>markerspace::Symbol = :pixel</code> sets the space in which <code>markersize</code> is given. See <code>Makie.spaces()</code> for possible inputs.</p></li><li><p><code>strokewidth::Real = 0</code> sets the width of the outline around a marker.</p></li><li><p><code>strokecolor::Union{Symbol, &lt;:Colorant} = :black</code> sets the color of the outline around a marker.</p></li><li><p><code>glowwidth::Real = 0</code> sets the size of a glow effect around the marker.</p></li><li><p><code>glowcolor::Union{Symbol, &lt;:Colorant} = (:black, 0)</code> sets the color of the glow effect.</p></li><li><p><code>rotations::Union{Real, Billboard, Quaternion} = Billboard(0f0)</code> sets the rotation of the marker. A <code>Billboard</code> rotation is always around the depth axis.</p></li><li><p><code>transform_marker::Bool = false</code> controls whether the model matrix (without translation) applies to the marker itself, rather than just the positions. (If this is true, <code>scale!</code> and <code>rotate!</code> will affect the marker.)</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="scatter!"><a href="#scatter!">scatter!</a></div><div class="doc-content"><pre><code>scatter(positions)
scatter(x, y)
scatter(x, y, z)</code></pre><p>Plots a marker for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p><h2>Attributes</h2><h3>Specific to <code>Scatter</code></h3><ul><li><p><code>color=theme(scene, :markercolor)</code> sets the color of the marker. If no color is set, multiple calls to <code>scatter!</code> will cycle through the axis color palette. Otherwise, one can set one color per point by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole scatterplot. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>cycle::Vector{Symbol} = [:color]</code> sets which attributes to cycle when creating multiple plots.</p></li><li><p><code>marker::Union{Symbol, Char, Matrix{&lt;:Colorant}, BezierPath, Polygon}</code> sets the scatter marker.</p></li><li><p><code>markersize::Union{&lt;:Real, Vec2f} = 9</code> sets the size of the marker.</p></li><li><p><code>markerspace::Symbol = :pixel</code> sets the space in which <code>markersize</code> is given. See <code>Makie.spaces()</code> for possible inputs.</p></li><li><p><code>strokewidth::Real = 0</code> sets the width of the outline around a marker.</p></li><li><p><code>strokecolor::Union{Symbol, &lt;:Colorant} = :black</code> sets the color of the outline around a marker.</p></li><li><p><code>glowwidth::Real = 0</code> sets the size of a glow effect around the marker.</p></li><li><p><code>glowcolor::Union{Symbol, &lt;:Colorant} = (:black, 0)</code> sets the color of the glow effect.</p></li><li><p><code>rotations::Union{Real, Billboard, Quaternion} = Billboard(0f0)</code> sets the rotation of the marker. A <code>Billboard</code> rotation is always around the depth axis.</p></li><li><p><code>transform_marker::Bool = false</code> controls whether the model matrix (without translation) applies to the marker itself, rather than just the positions. (If this is true, <code>scale!</code> and <code>rotate!</code> will affect the marker.)</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="scatterlines"><a href="#scatterlines">scatterlines</a></div><div class="doc-content"><pre><code>scatterlines(xs, ys, [zs]; kwargs...)</code></pre><p>Plots <code>scatter</code> markers and <code>lines</code> between them.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.scatterlines}</code> are: </p><pre><code>  color             :black
  colormap          :viridis
  colorrange        MakieCore.Automatic()
  colorscale        identity
  cycle             [:color]
  inspectable       true
  linestyle         "nothing"
  linewidth         1.5
  marker            :circle
  markercolor       MakieCore.Automatic()
  markercolormap    :viridis
  markercolorrange  MakieCore.Automatic()
  markersize        12
  strokecolor       :black
  strokewidth       0</code></pre></div></div><div class="docstring"><div class="doc-header" id="scatterlines!"><a href="#scatterlines!">scatterlines!</a></div><div class="doc-content"><pre><code>scatterlines(xs, ys, [zs]; kwargs...)</code></pre><p>Plots <code>scatter</code> markers and <code>lines</code> between them.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.scatterlines!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="scroll"><a href="#scroll">scroll</a></div><div class="doc-content"><p>Registers a callback for the mouse scroll. returns an <code>Observable{Vec{2, Float64}}</code>, which is an x and y offset. <a href="http://www.glfw.org/docs/latest/group__input.html#gacc95e259ad21d4f666faa6280d4018fd">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="select_line"><a href="#select_line">select_line</a></div><div class="doc-content"><pre><code>select_line(scene; kwargs...) -&gt; line</code></pre><p>Interactively select a line (typically an arrow) on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. Return an <strong>observable</strong> whose value corresponds to the selected line on the scene. In addition the function <em>plots</em> the line on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted line disappears.</p><p>The value of the returned line is updated <strong>only</strong> when the user un-clicks and only if the selected line has non-zero length.</p><p>The <code>kwargs...</code> are propagated into <code>lines!</code> which plots the selected line.</p></div></div><div class="docstring"><div class="doc-header" id="select_point"><a href="#select_point">select_point</a></div><div class="doc-content"><pre><code>select_point(scene; kwargs...) -&gt; point</code></pre><p>Interactively select a point on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. Return an <strong>observable</strong> whose value corresponds to the selected point on the scene. In addition the function <em>plots</em> the point on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted point disappears.</p><p>The value of the returned point is updated <strong>only</strong> when the user un-clicks.</p><p>The <code>kwargs...</code> are propagated into <code>scatter!</code> which plots the selected point.</p></div></div><div class="docstring"><div class="doc-header" id="select_rectangle"><a href="#select_rectangle">select_rectangle</a></div><div class="doc-content"><pre><code>select_rectangle(scene; kwargs...) -&gt; rect</code></pre><p>Interactively select a rectangle on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. The function returns an <strong>observable</strong><code>rect</code> whose value corresponds to the selected rectangle on the scene. In addition the function <em>plots</em> the selected rectangle on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted rectangle disappears.</p><p>The value of the returned observable is updated <strong>only</strong> when the user un-clicks (i.e. when the final value of the rectangle has been decided) and only if the rectangle has area &gt; 0.</p><p>The <code>kwargs...</code> are propagated into <code>lines!</code> which plots the selected rectangle.</p></div></div><div class="docstring"><div class="doc-header" id="series"><a href="#series">series</a></div><div class="doc-content"><pre><code>series(curves;
    linewidth=2,
    color=:lighttest,
    solid_color=nothing,
    labels=nothing,
    # scatter arguments, if any is set != nothing, a scatterplot is added
    marker=nothing,
    markersize=nothing,
    markercolor=automatic,
    strokecolor=nothing,
    strokewidth=nothing)</code></pre><p>Curves can be:</p><ul><li><p><code>AbstractVector{&lt;: AbstractVector{&lt;: Point2}}</code>: the native representation of a series as a vector of lines</p></li><li><p><code>AbstractMatrix</code>: each row represents y coordinates of the line, while <code>x</code> goes from <code>1:size(curves, 1)</code></p></li><li><p><code>AbstractVector, AbstractMatrix</code>: the same as the above, but the first argument sets the x values for all lines</p></li><li><p><code>AbstractVector{&lt;: Tuple{X&lt;: AbstractVector, Y&lt;: AbstractVector}}</code>: A vector of tuples, where each tuple contains a vector for the x and y coordinates</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="series!"><a href="#series!">series!</a></div><div class="doc-content"><pre><code>series(curves;
    linewidth=2,
    color=:lighttest,
    solid_color=nothing,
    labels=nothing,
    # scatter arguments, if any is set != nothing, a scatterplot is added
    marker=nothing,
    markersize=nothing,
    markercolor=automatic,
    strokecolor=nothing,
    strokewidth=nothing)</code></pre><p>Curves can be:</p><ul><li><p><code>AbstractVector{&lt;: AbstractVector{&lt;: Point2}}</code>: the native representation of a series as a vector of lines</p></li><li><p><code>AbstractMatrix</code>: each row represents y coordinates of the line, while <code>x</code> goes from <code>1:size(curves, 1)</code></p></li><li><p><code>AbstractVector, AbstractMatrix</code>: the same as the above, but the first argument sets the x values for all lines</p></li><li><p><code>AbstractVector{&lt;: Tuple{X&lt;: AbstractVector, Y&lt;: AbstractVector}}</code>: A vector of tuples, where each tuple contains a vector for the x and y coordinates</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="set_close_to!"><a href="#set_close_to!">set_close_to!</a></div><div class="doc-content"><pre><code>set_close_to!(slider, value) -&gt; closest_value</code></pre><p>Set the <code>slider</code> to the value in the slider's range that is closest to <code>value</code> and return this value. This function should be used to set a slider to a value programmatically, rather than mutating its value observable directly, which doesn't update the slider visually.</p><p>Set the <code>slider</code> to the values in the slider's range that are closest to <code>v1</code> and <code>v2</code>, and return those values ordered min, misl.</p></div></div><div class="docstring"><div class="doc-header" id="set_theme!"><a href="#set_theme!">set_theme!</a></div><div class="doc-content"><pre><code>set_theme(theme; kwargs...)</code></pre><p>Set the global default theme to <code>theme</code> and add / override any attributes given as keyword arguments.</p></div></div><div class="docstring"><div class="doc-header" id="showgradients"><a href="#showgradients">showgradients</a></div><div class="doc-content"><pre><code>showgradients(
    cgrads::AbstractVector{Symbol};
    h = 0.0, offset = 0.2, fontsize = 0.7,
    resolution = (800, length(cgrads) * 84)
)::Scene</code></pre><p>Plots the given colour gradients arranged as horizontal colourbars. If you change the offsets or the font size, you may need to change the resolution.</p></div></div><div class="docstring"><div class="doc-header" id="spy"><a href="#spy">spy</a></div><div class="doc-content"><p>spy(x::Range, y::Range, z::AbstractSparseArray)</p><p>Visualizes big sparse matrices. Usage:</p><pre><code class="language-julia">N = 200_000
x = sprand(Float64, N, N, (3(10^6)) / (N*N));
spy(x)
# or if you want to specify the range of x and y:
spy(0..1, 0..1, x)</code></pre><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.spy}</code> are: </p><pre><code>  colormap     :viridis
  colorrange   MakieCore.Automatic()
  colorscale   identity
  framecolor   :black
  framesize    1
  inspectable  true
  marker       MakieCore.Automatic()
  markersize   MakieCore.Automatic()
  visible      true</code></pre></div></div><div class="docstring"><div class="doc-header" id="spy!"><a href="#spy!">spy!</a></div><div class="doc-content"><p>spy(x::Range, y::Range, z::AbstractSparseArray)</p><p>Visualizes big sparse matrices. Usage:</p><pre><code class="language-julia">N = 200_000
x = sprand(Float64, N, N, (3(10^6)) / (N*N));
spy(x)
# or if you want to specify the range of x and y:
spy(0..1, 0..1, x)</code></pre><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.spy!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="stairs"><a href="#stairs">stairs</a></div><div class="doc-content"><pre><code>stairs(xs, ys; kwargs...)</code></pre><p>Plot a stair function.</p><p>The <code>step</code> parameter can take the following values:</p><ul><li><p><code>:pre</code>: horizontal part of step extends to the left of each value in <code>xs</code>.</p></li><li><p><code>:post</code>: horizontal part of step extends to the right of each value in <code>xs</code>.</p></li><li><p><code>:center</code>: horizontal part of step extends halfway between the two adjacent values of <code>xs</code>.</p></li></ul><p>The conversion trait of stem is <code>PointBased</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.stairs}</code> are: </p><pre><code>  alpha           1.0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  cycle           [:color]
  depth_shift     0.0f0
  highclip        MakieCore.Automatic()
  inspectable     true
  linestyle       "nothing"
  linewidth       1.5
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  space           :data
  ssao            false
  step            :pre
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="stairs!"><a href="#stairs!">stairs!</a></div><div class="doc-content"><pre><code>stairs(xs, ys; kwargs...)</code></pre><p>Plot a stair function.</p><p>The <code>step</code> parameter can take the following values:</p><ul><li><p><code>:pre</code>: horizontal part of step extends to the left of each value in <code>xs</code>.</p></li><li><p><code>:post</code>: horizontal part of step extends to the right of each value in <code>xs</code>.</p></li><li><p><code>:center</code>: horizontal part of step extends halfway between the two adjacent values of <code>xs</code>.</p></li></ul><p>The conversion trait of stem is <code>PointBased</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.stairs!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="stem"><a href="#stem">stem</a></div><div class="doc-content"><pre><code>stem(xs, ys, [zs]; kwargs...)</code></pre><p>Plots markers at the given positions extending from <code>offset</code> along stem lines.</p><p><code>offset</code> can be a number, in which case it sets y for 2D, and z for 3D stems. It can be a Point2 for 2D plots, as well as a Point3 for 3D plots. It can also be an iterable of any of these at the same length as xs, ys, zs.</p><p>The conversion trait of stem is <code>PointBased</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.stem}</code> are: </p><pre><code>  color            :black
  colormap         :viridis
  colorrange       MakieCore.Automatic()
  colorscale       identity
  cycle            [[:stemcolor, :color, :trunkcolor] =&gt; :color]
  inspectable      true
  marker           :circle
  markersize       12
  offset           0
  stemcolor        :black
  stemcolormap     :viridis
  stemcolorrange   MakieCore.Automatic()
  stemlinestyle    "nothing"
  stemwidth        1.5
  strokecolor      :black
  strokewidth      0
  trunkcolor       :black
  trunkcolormap    :viridis
  trunkcolorrange  MakieCore.Automatic()
  trunklinestyle   "nothing"
  trunkwidth       1.5
  visible          true</code></pre></div></div><div class="docstring"><div class="doc-header" id="stem!"><a href="#stem!">stem!</a></div><div class="doc-content"><pre><code>stem(xs, ys, [zs]; kwargs...)</code></pre><p>Plots markers at the given positions extending from <code>offset</code> along stem lines.</p><p><code>offset</code> can be a number, in which case it sets y for 2D, and z for 3D stems. It can be a Point2 for 2D plots, as well as a Point3 for 3D plots. It can also be an iterable of any of these at the same length as xs, ys, zs.</p><p>The conversion trait of stem is <code>PointBased</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.stem!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="stephist"><a href="#stephist">stephist</a></div><div class="doc-content"><pre><code>stephist(values; bins = 15, normalization = :none)</code></pre><p>Plot a step histogram of <code>values</code>. <code>bins</code> can be an <code>Int</code> to create that number of equal-width bins over the range of <code>values</code>. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting <code>normalization</code>.</p><p>Shares most options with <code>hist</code> plotting function.</p><p>Statistical weights can be provided via the <code>weights</code> keyword argument.</p><p>The following attributes can move the histogram around, which comes in handy when placing multiple histograms into one plot:</p><ul><li><p><code>scale_to = nothing</code>: allows to scale all values to a certain height</p></li></ul><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.stephist}</code> are: </p><pre><code>  bins           15
  color          RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  cycle          [:color =&gt; :patchcolor]
  linestyle      :solid
  normalization  :none
  scale_to       "nothing"
  weights        MakieCore.Automatic()</code></pre></div></div><div class="docstring"><div class="doc-header" id="stephist!"><a href="#stephist!">stephist!</a></div><div class="doc-content"><pre><code>stephist(values; bins = 15, normalization = :none)</code></pre><p>Plot a step histogram of <code>values</code>. <code>bins</code> can be an <code>Int</code> to create that number of equal-width bins over the range of <code>values</code>. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting <code>normalization</code>.</p><p>Shares most options with <code>hist</code> plotting function.</p><p>Statistical weights can be provided via the <code>weights</code> keyword argument.</p><p>The following attributes can move the histogram around, which comes in handy when placing multiple histograms into one plot:</p><ul><li><p><code>scale_to = nothing</code>: allows to scale all values to a certain height</p></li></ul><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.stephist!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="streamplot"><a href="#streamplot">streamplot</a></div><div class="doc-content"><pre><code>streamplot(f::function, xinterval, yinterval; color = norm, kwargs...)</code></pre><p>f must either accept <code>f(::Point)</code> or <code>f(x::Number, y::Number)</code>. f must return a Point2.</p><p>Example:</p><pre><code class="language-julia">v(x::Point2{T}) where T = Point2f(x[2], 4*x[1])
streamplot(v, -2..2, -2..2)</code></pre><p>One can choose the color of the lines by passing a function <code>color_func(dx::Point)</code> to the <code>color</code> attribute. By default this is set to <code>norm</code>, but can be set to any function or composition of functions. The <code>dx</code> which is passed to <code>color_func</code> is the output of <code>f</code> at the point being colored.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.streamplot}</code> are: </p><pre><code>  alpha           1.0
  arrow_head      MakieCore.Automatic()
  arrow_size      15
  color           LinearAlgebra.norm
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  density         1.0
  depth_shift     0.0f0
  gridsize        (32, 32, 32)
  highclip        MakieCore.Automatic()
  inspectable     true
  linestyle       "nothing"
  linewidth       1.5
  lowclip         MakieCore.Automatic()
  maxsteps        500
  nan_color       :transparent
  overdraw        false
  quality         16
  space           :data
  ssao            false
  stepsize        0.01
  transparency    false
  visible         true</code></pre><h2>Implementation</h2><p>See the function <code>Makie.streamplot_impl</code> for implementation details.</p></div></div><div class="docstring"><div class="doc-header" id="streamplot!"><a href="#streamplot!">streamplot!</a></div><div class="doc-content"><pre><code>streamplot(f::function, xinterval, yinterval; color = norm, kwargs...)</code></pre><p>f must either accept <code>f(::Point)</code> or <code>f(x::Number, y::Number)</code>. f must return a Point2.</p><p>Example:</p><pre><code class="language-julia">v(x::Point2{T}) where T = Point2f(x[2], 4*x[1])
streamplot(v, -2..2, -2..2)</code></pre><p>One can choose the color of the lines by passing a function <code>color_func(dx::Point)</code> to the <code>color</code> attribute. By default this is set to <code>norm</code>, but can be set to any function or composition of functions. The <code>dx</code> which is passed to <code>color_func</code> is the output of <code>f</code> at the point being colored.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.streamplot!}</code> are: </p><pre><code></code></pre><h2>Implementation</h2><p>See the function <code>Makie.streamplot_impl</code> for implementation details.</p></div></div><div class="docstring"><div class="doc-header" id="subscript"><a href="#subscript">subscript</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.subscript</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "subscript" from Makie:
 [1] subscript(args...; kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:287</code></pre></div></div><div class="docstring"><div class="doc-header" id="superscript"><a href="#superscript">superscript</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.superscript</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "superscript" from Makie:
 [1] superscript(args...; kwargs...)
     @ ~/work/Makie.jl/Makie.jl/src/basic_recipes/text.jl:288</code></pre></div></div><div class="docstring"><div class="doc-header" id="surface"><a href="#surface">surface</a></div><div class="doc-content"><pre><code>surface(x, y, z)
surface(z)</code></pre><p>Plots a surface, where <code>(x, y)</code>  define a grid whose heights are the entries in <code>z</code>. <code>x</code> and <code>y</code> may be <code>Vectors</code> which define a regular grid, <strong>or</strong><code>Matrices</code> which define an irregular grid.</p><p><code>Surface</code> has the conversion trait <code>ContinuousSurface &lt;: SurfaceLike</code>.</p><h2>Attributes</h2><h3>Specific to <code>Surface</code></h3><ul><li><p><code>invert_normals::Bool = false</code> inverts the normals generated for the surface. This can be useful to illuminate the other side of the surface.</p></li><li><p><code>color = nothing</code>, can be set to an <code>Matrix{&lt;: Union{Number, Colorant}}</code> to color surface independent of the <code>z</code> component. If <code>color=nothing</code>, it defaults to <code>color=z</code>.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = true</code> enables lighting.</p></li><li><p><code>diffuse::Vec3f = Vec3f(0.4)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.2)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="surface!"><a href="#surface!">surface!</a></div><div class="doc-content"><pre><code>surface(x, y, z)
surface(z)</code></pre><p>Plots a surface, where <code>(x, y)</code>  define a grid whose heights are the entries in <code>z</code>. <code>x</code> and <code>y</code> may be <code>Vectors</code> which define a regular grid, <strong>or</strong><code>Matrices</code> which define an irregular grid.</p><p><code>Surface</code> has the conversion trait <code>ContinuousSurface &lt;: SurfaceLike</code>.</p><h2>Attributes</h2><h3>Specific to <code>Surface</code></h3><ul><li><p><code>invert_normals::Bool = false</code> inverts the normals generated for the surface. This can be useful to illuminate the other side of the surface.</p></li><li><p><code>color = nothing</code>, can be set to an <code>Matrix{&lt;: Union{Number, Colorant}}</code> to color surface independent of the <code>z</code> component. If <code>color=nothing</code>, it defaults to <code>color=z</code>.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = true</code> enables lighting.</p></li><li><p><code>diffuse::Vec3f = Vec3f(0.4)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.2)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="swap!"><a href="#swap!">swap!</a></div><div class="doc-content"><p>Swaps or rotates the layout positions of the given elements to their neighbor's.</p></div></div><div class="docstring"><div class="doc-header" id="text"><a href="#text">text</a></div><div class="doc-content"><pre><code>text(positions; text, kwargs...)
text(x, y; text, kwargs...)
text(x, y, z; text, kwargs...)</code></pre><p>Plots one or multiple texts passed via the <code>text</code> keyword. <code>Text</code> uses the <code>PointBased</code> conversion trait.</p><h2>Attributes</h2><h3>Specific to <code>Text</code></h3><ul><li><p><code>color=theme(scene, :textcolor)</code> sets the color of the text. One can set one color per glyph by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole text. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>text</code> specifies one piece of text or a vector of texts to show, where the number has to match the number of positions given. Makie supports <code>String</code> which is used for all normal text and <code>LaTeXString</code> which layouts mathematical expressions using <code>MathTeXEngine.jl</code>.</p></li><li><p><code>align::Tuple{Union{Symbol, Real}, Union{Symbol, Real}} = (:left, :bottom)</code> sets the alignment of the string w.r.t. <code>position</code>. Uses <code>:left, :center, :right, :top, :bottom, :baseline</code> or fractions.</p></li><li><p><code>font::Union{String, Vector{String}} = :regular</code> sets the font for the string or each character.</p></li><li><p><code>justification::Union{Real, Symbol} = automatic</code> sets the alignment of text w.r.t its bounding box. Can be <code>:left, :center, :right</code> or a fraction. Will default to the horizontal alignment in <code>align</code>.</p></li><li><p><code>rotation::Union{Real, Quaternion}</code> rotates text around the given position.</p></li><li><p><code>fontsize::Union{Real, Vec2f}</code> sets the size of each character.</p></li><li><p><code>markerspace::Symbol = :pixel</code> sets the space in which <code>fontsize</code> acts. See <code>Makie.spaces()</code> for possible inputs.</p></li><li><p><code>strokewidth::Real = 0</code> sets the width of the outline around a marker.</p></li><li><p><code>strokecolor::Union{Symbol, &lt;:Colorant} = :black</code> sets the color of the outline around a marker.</p></li><li><p><code>glowwidth::Real = 0</code> sets the size of a glow effect around the marker.</p></li><li><p><code>glowcolor::Union{Symbol, &lt;:Colorant} = (:black, 0)</code> sets the color of the glow effect.</p></li><li><p><code>word_wrap_with::Real = -1</code> specifies a linewidth limit for text. If a word overflows this limit, a newline is inserted before it. Negative numbers disable word wrapping.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="text!"><a href="#text!">text!</a></div><div class="doc-content"><pre><code>text(positions; text, kwargs...)
text(x, y; text, kwargs...)
text(x, y, z; text, kwargs...)</code></pre><p>Plots one or multiple texts passed via the <code>text</code> keyword. <code>Text</code> uses the <code>PointBased</code> conversion trait.</p><h2>Attributes</h2><h3>Specific to <code>Text</code></h3><ul><li><p><code>color=theme(scene, :textcolor)</code> sets the color of the text. One can set one color per glyph by passing a <code>Vector{&lt;:Colorant}</code>, or one colorant for the whole text. If color is a vector of numbers, the colormap args are used to map the numbers to colors.</p></li><li><p><code>text</code> specifies one piece of text or a vector of texts to show, where the number has to match the number of positions given. Makie supports <code>String</code> which is used for all normal text and <code>LaTeXString</code> which layouts mathematical expressions using <code>MathTeXEngine.jl</code>.</p></li><li><p><code>align::Tuple{Union{Symbol, Real}, Union{Symbol, Real}} = (:left, :bottom)</code> sets the alignment of the string w.r.t. <code>position</code>. Uses <code>:left, :center, :right, :top, :bottom, :baseline</code> or fractions.</p></li><li><p><code>font::Union{String, Vector{String}} = :regular</code> sets the font for the string or each character.</p></li><li><p><code>justification::Union{Real, Symbol} = automatic</code> sets the alignment of text w.r.t its bounding box. Can be <code>:left, :center, :right</code> or a fraction. Will default to the horizontal alignment in <code>align</code>.</p></li><li><p><code>rotation::Union{Real, Quaternion}</code> rotates text around the given position.</p></li><li><p><code>fontsize::Union{Real, Vec2f}</code> sets the size of each character.</p></li><li><p><code>markerspace::Symbol = :pixel</code> sets the space in which <code>fontsize</code> acts. See <code>Makie.spaces()</code> for possible inputs.</p></li><li><p><code>strokewidth::Real = 0</code> sets the width of the outline around a marker.</p></li><li><p><code>strokecolor::Union{Symbol, &lt;:Colorant} = :black</code> sets the color of the outline around a marker.</p></li><li><p><code>glowwidth::Real = 0</code> sets the size of a glow effect around the marker.</p></li><li><p><code>glowcolor::Union{Symbol, &lt;:Colorant} = (:black, 0)</code> sets the color of the glow effect.</p></li><li><p><code>word_wrap_with::Real = -1</code> specifies a linewidth limit for text. If a word overflows this limit, a newline is inserted before it. Negative numbers disable word wrapping.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="theme"><a href="#theme">theme</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.theme</code> is a <code>Function</code>.</p><pre><code># 7 methods for generic function "theme" from MakieCore:
 [1] theme(x::AbstractScene)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:58
 [2] theme(x::AbstractScene, key; default)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:59
 [3] theme(x::Union{AbstractScene, MakieCore.ScenePlot}, args...)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:57
 [4] theme(x::AbstractPlot)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/attributes.jl:151
 [5] theme(x::AbstractPlot, key; default)
     @ ~/work/Makie.jl/Makie.jl/MakieCore/src/recipes.jl:60
 [6] theme(key::Symbol; default)
     @ Makie ~/work/Makie.jl/Makie.jl/src/theming.jl:201
 [7] theme(::Nothing, key::Symbol; default)
     @ Makie ~/work/Makie.jl/Makie.jl/src/theming.jl:200</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_black"><a href="#theme_black">theme_black</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_black</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_black" from Makie:
 [1] theme_black()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_black.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_dark"><a href="#theme_dark">theme_dark</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_dark</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_dark" from Makie:
 [1] theme_dark()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_dark.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_ggplot2"><a href="#theme_ggplot2">theme_ggplot2</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_ggplot2</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_ggplot2" from Makie:
 [1] theme_ggplot2()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_ggplot2.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_latexfonts"><a href="#theme_latexfonts">theme_latexfonts</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_latexfonts</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_latexfonts" from Makie:
 [1] theme_latexfonts()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_latexfonts.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_light"><a href="#theme_light">theme_light</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_light</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_light" from Makie:
 [1] theme_light()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_light.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_minimal"><a href="#theme_minimal">theme_minimal</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_minimal</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_minimal" from Makie:
 [1] theme_minimal()
     @ ~/work/Makie.jl/Makie.jl/src/themes/theme_minimal.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="thetalims!"><a href="#thetalims!">thetalims!</a></div><div class="doc-content"><pre><code>thetalims!(ax::PolarAxis, thetamin, thetamax)</code></pre><p>Sets the angular limits of a given <code>PolarAxis</code>.</p></div></div><div class="docstring"><div class="doc-header" id="tight_ticklabel_spacing!"><a href="#tight_ticklabel_spacing!">tight_ticklabel_spacing!</a></div><div class="doc-content"><pre><code>tight_ticklabel_spacing(ax::Axis)</code></pre><p>Sets the space allocated for the xticklabels and yticklabels of the <code>Axis</code> to the minimum that is needed.</p><pre><code>space = tight_ticklabel_spacing!(cb::Colorbar)</code></pre><p>Sets the space allocated for the ticklabels of the <code>Colorbar</code> to the minimum that is needed and returns that value.</p></div></div><div class="docstring"><div class="doc-header" id="tight_xticklabel_spacing!"><a href="#tight_xticklabel_spacing!">tight_xticklabel_spacing!</a></div><div class="doc-content"><pre><code>space = tight_xticklabel_spacing!(ax::Axis)</code></pre><p>Sets the space allocated for the yticklabels of the <code>Axis</code> to the minimum that is needed and returns that value.</p></div></div><div class="docstring"><div class="doc-header" id="tight_yticklabel_spacing!"><a href="#tight_yticklabel_spacing!">tight_yticklabel_spacing!</a></div><div class="doc-content"><pre><code>space = tight_xticklabel_spacing!(ax::Axis)</code></pre><p>Sets the space allocated for the xticklabels of the <code>Axis</code> to the minimum that is needed and returns that value.</p></div></div><div class="docstring"><div class="doc-header" id="tightlimits!"><a href="#tightlimits!">tightlimits!</a></div><div class="doc-content"><pre><code>tightlimits!(la::Axis)</code></pre><p>Sets the autolimit margins to zero on all sides.</p><pre><code>tightlimits!(la::Axis, sides::Union{Left, Right, Bottom, Top}...)</code></pre><p>Sets the autolimit margins to zero on all given sides.</p><p>Example:</p><pre><code>tightlimits!(laxis, Bottom())</code></pre></div></div><div class="docstring"><div class="doc-header" id="timeseries"><a href="#timeseries">timeseries</a></div><div class="doc-content"><pre><code>timeseries(x::Observable{{Union{Number, Point2}}})</code></pre><p>Plots a sampled signal. Usage:</p><pre><code class="language-julia">signal = Observable(1.0)
scene = timeseries(signal)
display(scene)
# @async is optional, but helps to continue evaluating more code
@async while isopen(scene)
    # aquire data from e.g. a sensor:
    data = rand()
    # update the signal
    signal[] = data
    # sleep/ wait for new data/ whatever...
    # It's important to yield here though, otherwise nothing will be rendered
    sleep(1/30)
end
</code></pre></div></div><div class="docstring"><div class="doc-header" id="timeseries!"><a href="#timeseries!">timeseries!</a></div><div class="doc-content"><pre><code>timeseries(x::Observable{{Union{Number, Point2}}})</code></pre><p>Plots a sampled signal. Usage:</p><pre><code class="language-julia">signal = Observable(1.0)
scene = timeseries(signal)
display(scene)
# @async is optional, but helps to continue evaluating more code
@async while isopen(scene)
    # aquire data from e.g. a sensor:
    data = rand()
    # update the signal
    signal[] = data
    # sleep/ wait for new data/ whatever...
    # It's important to yield here though, otherwise nothing will be rendered
    sleep(1/30)
end
</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_align"><a href="#to_align">to_align</a></div><div class="doc-content"><pre><code>to_align(align[, error_prefix])</code></pre><p>Converts the given align to a <code>Vec2f</code>. Can convert <code>VecTypes{2}</code> and two component <code>Tuple</code>s with <code>Real</code> and <code>Symbol</code> elements.</p><p>To specify a custom error message you can add an <code>error_prefix</code> or use <code>halign2num(value, error_msg)</code> and <code>valign2num(value, error_msg)</code> respectively.</p></div></div><div class="docstring"><div class="doc-header" id="to_color"><a href="#to_color">to_color</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_color</code> is a <code>Function</code>.</p><pre><code># 12 methods for generic function "to_color" from Makie:
  [1] to_color(c::Makie.ColorMapping)
     @ ~/work/Makie.jl/Makie.jl/src/colorsampler.jl:321
  [2] to_color(c::Real)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:833
  [3] to_color(c::ColorTypes.Colorant)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:834
  [4] to_color(p::Makie.AbstractPattern)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:839
  [5] to_color(c::Tuple{Any, Number})
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:840
  [6] to_color(sampler::Sampler)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:1494
  [7] to_color(c::AbstractArray{&lt;:ColorTypes.Colorant, N}) where N
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:838
  [8] to_color(c::AbstractArray)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:837
  [9] to_color(p::Makie.Palette)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:826
 [10] to_color(c::Nothing)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:832
 [11] to_color(c::Symbol)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:835
 [12] to_color(c::String)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:836</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_colormap"><a href="#to_colormap">to_colormap</a></div><div class="doc-content"><pre><code>to_colormap(b::AbstractVector)</code></pre><p>An <code>AbstractVector{T}</code> with any object that <a href="@ref"><code>to_color</code></a> accepts.</p><pre><code>to_colormap(cs::Union{String, Symbol})::Vector{RGBAf}</code></pre><p>A Symbol/String naming the gradient. For more on what names are available please see: <code>available_gradients()</code>. For now, we support gradients from <code>PlotUtils</code> natively.</p></div></div><div class="docstring"><div class="doc-header" id="to_font"><a href="#to_font">to_font</a></div><div class="doc-content"><pre><code>to_font(str::String)</code></pre><p>Loads a font specified by <code>str</code> and returns a <code>NativeFont</code> object storing the font handle. A font can either be specified by a file path, such as "folder/with/fonts/font.otf", or by a (partial) name such as "Helvetica", "Helvetica Bold" etc.</p></div></div><div class="docstring"><div class="doc-header" id="to_fontsize"><a href="#to_fontsize">to_fontsize</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_fontsize</code> is a <code>Function</code>.</p><pre><code># 4 methods for generic function "to_fontsize" from Makie:
 [1] to_fontsize(x::Number)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:1174
 [2] to_fontsize(x::Vec2)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:1176
 [3] to_fontsize(x::AbstractVector{T}) where T&lt;:Number
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:1175
 [4] to_fontsize(x::AbstractVector{T}) where T&lt;:(Vec2)
     @ ~/work/Makie.jl/Makie.jl/src/conversions.jl:1177</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_ndim"><a href="#to_ndim">to_ndim</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_ndim</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "to_ndim" from Makie:
 [1] to_ndim(T::Type{&lt;:Union{Tuple{Vararg{ET, N}}, StaticArraysCore.StaticArray{Tuple{N}, ET, 1}}}, vec::Union{Tuple{Vararg{T, N2}}, StaticArraysCore.StaticArray{Tuple{N2}, T, 1}} where T, fillval) where {N, ET, N2}
     @ ~/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:246</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_rotation"><a href="#to_rotation">to_rotation</a></div><div class="doc-content"><pre><code>rotation accepts:
to_rotation(b, quaternion)
to_rotation(b, tuple_float)
to_rotation(b, vec4)</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_value"><a href="#to_value">to_value</a></div><div class="doc-content"><pre><code>to_value(x::Union{Any, AbstractObservable})</code></pre><p>Extracts the value of an observable, and returns the object if it's not an observable!</p></div></div><div class="docstring"><div class="doc-header" id="to_vector"><a href="#to_vector">to_vector</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_vector</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "to_vector" from Makie:
 [1] to_vector(x::AbstractVector, len, T)
     @ ~/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:269
 [2] to_vector(x::AbstractArray, len, T)
     @ ~/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:270
 [3] to_vector(x::IntervalSets.ClosedInterval, len, T)
     @ ~/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:277</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_world"><a href="#to_world">to_world</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_world</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "to_world" from Makie:
 [1] to_world(scene::Scene, point::T) where T&lt;:(StaticArraysCore.StaticArray{Tuple{N}, T, 1} where {N, T})
     @ ~/work/Makie.jl/Makie.jl/src/camera/projection_math.jl:241
 [2] to_world(p::Vec{N, T}, prj_view_inv::StaticArraysCore.SMatrix{4, 4, T, 16} where T, cam_res::StaticArraysCore.StaticArray{Tuple{N}, T, 1} where {N, T}) where {N, T}
     @ ~/work/Makie.jl/Makie.jl/src/camera/projection_math.jl:272
 [3] to_world(p::StaticArraysCore.StaticArray{Tuple{N}, T, 1}, prj_view_inv::StaticArraysCore.SMatrix{4, 4, T, 16} where T, cam_res::StaticArraysCore.StaticArray{Tuple{N}, T, 1} where {N, T}) where {N, T}
     @ ~/work/Makie.jl/Makie.jl/src/camera/projection_math.jl:256</code></pre></div></div><div class="docstring"><div class="doc-header" id="tooltip"><a href="#tooltip">tooltip</a></div><div class="doc-content"><pre><code>tooltip(position, string)
tooltip(x, y, string)</code></pre><p>Creates a tooltip pointing at <code>position</code> displaying the given <code>string</code></p><h2>Attributes</h2><h3>Generic</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for positions of markers. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul><h3>Tooltip specific</h3><ul><li><p><code>offset = 10</code> sets the offset between the given <code>position</code> and the tip of the triangle pointing at that position.</p></li><li><p><code>placement = :above</code> sets where the tooltipÃ¼ should be placed relative to <code>position</code>. Can be <code>:above</code>, <code>:below</code>, <code>:left</code>, <code>:right</code>.</p></li><li><p><code>align = 0.5</code> sets the alignment of the tooltip relative <code>position</code>. With <code>align = 0.5</code> the tooltip is centered above/below/left/right the <code>position</code>.</p></li><li><p><code>backgroundcolor = :white</code> sets the background color of the tooltip.</p></li><li><p><code>triangle_size = 10</code> sets the size of the triangle pointing at <code>position</code>.</p></li><li><p><code>outline_color = :black</code> sets the color of the tooltip outline.</p></li><li><p><code>outline_linewidth = 2f0</code> sets the linewidth of the tooltip outline.</p></li><li><p><code>outline_linestyle = nothing</code> sets the linestyle of the tooltip outline.</p></li><li><p><code>textpadding = (4, 4, 4, 4)</code> sets the padding around text in the tooltip. This is given as <code>(left, right, bottom top)</code> offsets.</p></li><li><p><code>textcolor = theme(scene, :textcolor)</code> sets the text color.</p></li><li><p><code>fontsize = 16</code> sets the text size.</p></li><li><p><code>font = theme(scene, :font)</code> sets the font.</p></li><li><p><code>strokewidth = 0</code>: Gives text an outline if set to a positive value.</p></li><li><p><code>strokecolor = :white</code> sets the text outline color.</p></li><li><p><code>justification = :left</code> sets whether text is aligned to the <code>:left</code>, <code>:center</code> or <code>:right</code> within its bounding box.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="tooltip!"><a href="#tooltip!">tooltip!</a></div><div class="doc-content"><pre><code>tooltip(position, string)
tooltip(x, y, string)</code></pre><p>Creates a tooltip pointing at <code>position</code> displaying the given <code>string</code></p><h2>Attributes</h2><h3>Generic</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for positions of markers. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul><h3>Tooltip specific</h3><ul><li><p><code>offset = 10</code> sets the offset between the given <code>position</code> and the tip of the triangle pointing at that position.</p></li><li><p><code>placement = :above</code> sets where the tooltipÃ¼ should be placed relative to <code>position</code>. Can be <code>:above</code>, <code>:below</code>, <code>:left</code>, <code>:right</code>.</p></li><li><p><code>align = 0.5</code> sets the alignment of the tooltip relative <code>position</code>. With <code>align = 0.5</code> the tooltip is centered above/below/left/right the <code>position</code>.</p></li><li><p><code>backgroundcolor = :white</code> sets the background color of the tooltip.</p></li><li><p><code>triangle_size = 10</code> sets the size of the triangle pointing at <code>position</code>.</p></li><li><p><code>outline_color = :black</code> sets the color of the tooltip outline.</p></li><li><p><code>outline_linewidth = 2f0</code> sets the linewidth of the tooltip outline.</p></li><li><p><code>outline_linestyle = nothing</code> sets the linestyle of the tooltip outline.</p></li><li><p><code>textpadding = (4, 4, 4, 4)</code> sets the padding around text in the tooltip. This is given as <code>(left, right, bottom top)</code> offsets.</p></li><li><p><code>textcolor = theme(scene, :textcolor)</code> sets the text color.</p></li><li><p><code>fontsize = 16</code> sets the text size.</p></li><li><p><code>font = theme(scene, :font)</code> sets the font.</p></li><li><p><code>strokewidth = 0</code>: Gives text an outline if set to a positive value.</p></li><li><p><code>strokecolor = :white</code> sets the text outline color.</p></li><li><p><code>justification = :left</code> sets whether text is aligned to the <code>:left</code>, <code>:center</code> or <code>:right</code> within its bounding box.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="top"><a href="#top">top</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.top</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "top" from Makie:
 [1] top(rect::Rect2)
     @ ~/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:5</code></pre></div></div><div class="docstring"><div class="doc-header" id="translate!"><a href="#translate!">translate!</a></div><div class="doc-content"><pre><code>translate!(scene::Transformable, xyz::VecTypes)
translate!(scene::Transformable, xyz...)</code></pre><p>Apply an absolute translation to the Scene, translating it to <code>x, y, z</code>.</p><pre><code>translate!(Accum, scene::Transformable, xyz...)</code></pre><p>Translate the scene relative to its current position.</p></div></div><div class="docstring"><div class="doc-header" id="translate_cam!"><a href="#translate_cam!">translate_cam!</a></div><div class="doc-content"><pre><code>translate_cam!(scene::Scene, translation::VecTypes)</code></pre><p>Translate the camera by a translation vector given in camera space.</p></div></div><div class="docstring"><div class="doc-header" id="translated"><a href="#translated">translated</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.translated</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "translated" from Makie:
 [1] translated(scene::Scene; kw_args...)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/transformation.jl:69
 [2] translated(scene::Scene, translation...)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/transformation.jl:63</code></pre></div></div><div class="docstring"><div class="doc-header" id="translation"><a href="#translation">translation</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.translation</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "translation" from Makie:
 [1] translation(scene::MakieCore.Transformable)
     @ ~/work/Makie.jl/Makie.jl/src/layouting/transformation.jl:144</code></pre></div></div><div class="docstring"><div class="doc-header" id="tricontourf"><a href="#tricontourf">tricontourf</a></div><div class="doc-content"><pre><code>tricontourf(triangles::Triangulation, zs; kwargs...)
tricontourf(xs, ys, zs; kwargs...)</code></pre><p>Plots a filled tricontour of the height information in <code>zs</code> at the horizontal positions <code>xs</code> and  vertical positions <code>ys</code>. A <code>Triangulation</code> from DelaunayTriangulation.jl can also be provided instead of <code>xs</code> and <code>ys</code> for specifying the triangles, otherwise an unconstrained triangulation of <code>xs</code> and <code>ys</code> is computed.</p><h2>Attributes</h2><h3>Specific to <code>Tricontourf</code></h3><ul><li><p><code>levels = 10</code> can be either an <code>Int</code> which results in n bands delimited by n+1 equally spaced levels, or it can be an <code>AbstractVector{&lt;:Real}</code> that lists n consecutive edges from low to high, which result in n-1 bands.</p></li><li><p><code>mode = :normal</code> sets the way in which a vector of levels is interpreted, if it's set to <code>:relative</code>, each number is interpreted as a fraction between the minimum and maximum values of <code>zs</code>. For example, <code>levels = 0.1:0.1:1.0</code> would exclude the lower 10% of data.</p></li><li><p><code>extendlow = nothing</code>. This sets the color of an optional additional band from <code>minimum(zs)</code> to the lowest value in <code>levels</code>. If it's <code>:auto</code>, the lower end of the colormap is picked and the remaining colors are shifted accordingly. If it's any color representation, this color is used. If it's <code>nothing</code>, no band is added.</p></li><li><p><code>extendhigh = nothing</code>. This sets the color of an optional additional band from the highest value of <code>levels</code> to <code>maximum(zs)</code>. If it's <code>:auto</code>, the high end of the colormap is picked and the remaining colors are shifted accordingly. If it's any color representation, this color is used. If it's <code>nothing</code>, no band is added.</p></li><li><p><code>triangulation = DelaunayTriangulation()</code>. The mode with which the points in <code>xs</code> and <code>ys</code> are triangulated. Passing <code>DelaunayTriangulation()</code> performs a Delaunay triangulation. You can also pass a preexisting triangulation as an <code>AbstractMatrix{&lt;:Int}</code> with size (3, n), where each column specifies the vertex indices of one triangle, or as a <code>Triangulation</code> from DelaunayTriangulation.jl.</p></li></ul><h3>Generic</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = false</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>color</code> sets the color of the plot. It can be given as a named color <code>Symbol</code> or a <code>Colors.Colorant</code>. Transparency can be included either directly as an alpha value in the <code>Colorant</code> or as an additional float in a tuple <code>(color, alpha)</code>. The color can also be set for each scattered marker by passing a <code>Vector</code> of colors or be used to index the <code>colormap</code> by passing a <code>Real</code> number or <code>Vector{&lt;: Real}</code>.</p></li><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap from which the band colors are sampled.</p></li><li><p><code>colorscale::Function = identity</code> color transform function.</p></li></ul><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.tricontourf}</code> are: </p><pre><code>  colormap       :viridis
  colorscale     identity
  edges          "nothing"
  extendhigh     "nothing"
  extendlow      "nothing"
  inspectable    true
  levels         10
  mode           :normal
  nan_color      :transparent
  transparency   false
  triangulation  Makie.DelaunayTriangulation()</code></pre></div></div><div class="docstring"><div class="doc-header" id="tricontourf!"><a href="#tricontourf!">tricontourf!</a></div><div class="doc-content"><pre><code>tricontourf(triangles::Triangulation, zs; kwargs...)
tricontourf(xs, ys, zs; kwargs...)</code></pre><p>Plots a filled tricontour of the height information in <code>zs</code> at the horizontal positions <code>xs</code> and  vertical positions <code>ys</code>. A <code>Triangulation</code> from DelaunayTriangulation.jl can also be provided instead of <code>xs</code> and <code>ys</code> for specifying the triangles, otherwise an unconstrained triangulation of <code>xs</code> and <code>ys</code> is computed.</p><h2>Attributes</h2><h3>Specific to <code>Tricontourf</code></h3><ul><li><p><code>levels = 10</code> can be either an <code>Int</code> which results in n bands delimited by n+1 equally spaced levels, or it can be an <code>AbstractVector{&lt;:Real}</code> that lists n consecutive edges from low to high, which result in n-1 bands.</p></li><li><p><code>mode = :normal</code> sets the way in which a vector of levels is interpreted, if it's set to <code>:relative</code>, each number is interpreted as a fraction between the minimum and maximum values of <code>zs</code>. For example, <code>levels = 0.1:0.1:1.0</code> would exclude the lower 10% of data.</p></li><li><p><code>extendlow = nothing</code>. This sets the color of an optional additional band from <code>minimum(zs)</code> to the lowest value in <code>levels</code>. If it's <code>:auto</code>, the lower end of the colormap is picked and the remaining colors are shifted accordingly. If it's any color representation, this color is used. If it's <code>nothing</code>, no band is added.</p></li><li><p><code>extendhigh = nothing</code>. This sets the color of an optional additional band from the highest value of <code>levels</code> to <code>maximum(zs)</code>. If it's <code>:auto</code>, the high end of the colormap is picked and the remaining colors are shifted accordingly. If it's any color representation, this color is used. If it's <code>nothing</code>, no band is added.</p></li><li><p><code>triangulation = DelaunayTriangulation()</code>. The mode with which the points in <code>xs</code> and <code>ys</code> are triangulated. Passing <code>DelaunayTriangulation()</code> performs a Delaunay triangulation. You can also pass a preexisting triangulation as an <code>AbstractMatrix{&lt;:Int}</code> with size (3, n), where each column specifies the vertex indices of one triangle, or as a <code>Triangulation</code> from DelaunayTriangulation.jl.</p></li></ul><h3>Generic</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = false</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>color</code> sets the color of the plot. It can be given as a named color <code>Symbol</code> or a <code>Colors.Colorant</code>. Transparency can be included either directly as an alpha value in the <code>Colorant</code> or as an additional float in a tuple <code>(color, alpha)</code>. The color can also be set for each scattered marker by passing a <code>Vector</code> of colors or be used to index the <code>colormap</code> by passing a <code>Real</code> number or <code>Vector{&lt;: Real}</code>.</p></li><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap from which the band colors are sampled.</p></li><li><p><code>colorscale::Function = identity</code> color transform function.</p></li></ul><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.tricontourf!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="trim!"><a href="#trim!">trim!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.trim!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "trim!" from GridLayoutBase:
 [1] trim!(gl::GridLayout)
     @ ~/.julia/packages/GridLayoutBase/kiave/src/gridlayout.jl:563</code></pre></div></div><div class="docstring"><div class="doc-header" id="triplot"><a href="#triplot">triplot</a></div><div class="doc-content"><pre><code>triplot(x, y; kwargs...)
triplot(positions; kwargs...)
triplot(triangles::Triangulation; kwargs...)</code></pre><p>Plots a triangulation based on the provided position or <code>Triangulation</code> from DelaunayTriangulation.jl.</p><h2>Attributes</h2><ul><li><p><code>show_points = false</code> determines whether to plot the individual points. Note that this will only plot points included in the triangulation.</p></li><li><p><code>show_convex_hull = false</code> determines whether to plot the convex hull.</p></li><li><p><code>show_ghost_edges = false</code> determines whether to plot the ghost edges.</p></li><li><p><code>show_constrained_edges = false</code> determines whether to plot the constrained edges.</p></li><li><p><code>recompute_centers = false</code> determines whether to recompute the representative points for the ghost edge orientation. Note that this will mutate <code>tri.representative_point_list</code> directly.</p></li><li><p><code>markersize = 12</code> sets the size of the points.</p></li><li><p><code>marker = :circle</code> sets the shape of the points.</p></li><li><p><code>markercolor = :black</code> sets the color of the points.</p></li><li><p><code>strokecolor = :black</code> sets the color of triangle edges.</p></li><li><p><code>strokewidth = 1</code> sets the linewidth of triangle edges.</p></li><li><p><code>linestyle = :solid</code> sets the linestyle of triangle edges.</p></li><li><p><code>triangle_color = (:white, 0.0)</code> sets the color of the triangles.</p></li><li><p><code>convex_hull_color = :red</code> sets the color of the convex hull.</p></li><li><p><code>convex_hull_linestyle = :dash</code> sets the linestyle of the convex hull.</p></li><li><p><code>convex_hull_linewidth = 1</code> sets the width of the convex hull.</p></li><li><p><code>ghost_edge_color = :blue</code> sets the color of the ghost edges.</p></li><li><p><code>ghost_edge_linestyle = :solid</code> sets the linestyle of the ghost edges.</p></li><li><p><code>ghost_edge_linewidth = 1</code> sets the width of the ghost edges.</p></li><li><p><code>ghost_edge_extension_factor = 0.1</code> sets the extension factor for the rectangle that the exterior ghost edges are extended onto.</p></li><li><p><code>bounding_box::Union{Automatic, Rect2, Tuple} = automatic</code>: Sets the bounding box for truncating ghost edges which can be a <code>Rect2</code> (or <code>BBox</code>) or a tuple of the form <code>(xmin, xmax, ymin, ymax)</code>. By default, the rectangle will be given by <code>[a - eÎx, b + eÎx] Ã [c - eÎy, d + eÎy]</code> where <code>e</code> is the <code>ghost_edge_extension_factor</code>, <code>Îx = b - a</code> and <code>Îy = d - c</code> are the lengths of the sides of the rectangle, and <code>[a, b] Ã [c, d]</code> is the bounding box of the points in the triangulation.</p></li><li><p><code>constrained_edge_color = :magenta</code> sets the color of the constrained edges.</p></li><li><p><code>constrained_edge_linestyle = :solid</code> sets the linestyle of the constrained edges.</p></li><li><p><code>constrained_edge_linewidth = 1</code> sets the width of the constrained edges.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="triplot!"><a href="#triplot!">triplot!</a></div><div class="doc-content"><pre><code>triplot(x, y; kwargs...)
triplot(positions; kwargs...)
triplot(triangles::Triangulation; kwargs...)</code></pre><p>Plots a triangulation based on the provided position or <code>Triangulation</code> from DelaunayTriangulation.jl.</p><h2>Attributes</h2><ul><li><p><code>show_points = false</code> determines whether to plot the individual points. Note that this will only plot points included in the triangulation.</p></li><li><p><code>show_convex_hull = false</code> determines whether to plot the convex hull.</p></li><li><p><code>show_ghost_edges = false</code> determines whether to plot the ghost edges.</p></li><li><p><code>show_constrained_edges = false</code> determines whether to plot the constrained edges.</p></li><li><p><code>recompute_centers = false</code> determines whether to recompute the representative points for the ghost edge orientation. Note that this will mutate <code>tri.representative_point_list</code> directly.</p></li><li><p><code>markersize = 12</code> sets the size of the points.</p></li><li><p><code>marker = :circle</code> sets the shape of the points.</p></li><li><p><code>markercolor = :black</code> sets the color of the points.</p></li><li><p><code>strokecolor = :black</code> sets the color of triangle edges.</p></li><li><p><code>strokewidth = 1</code> sets the linewidth of triangle edges.</p></li><li><p><code>linestyle = :solid</code> sets the linestyle of triangle edges.</p></li><li><p><code>triangle_color = (:white, 0.0)</code> sets the color of the triangles.</p></li><li><p><code>convex_hull_color = :red</code> sets the color of the convex hull.</p></li><li><p><code>convex_hull_linestyle = :dash</code> sets the linestyle of the convex hull.</p></li><li><p><code>convex_hull_linewidth = 1</code> sets the width of the convex hull.</p></li><li><p><code>ghost_edge_color = :blue</code> sets the color of the ghost edges.</p></li><li><p><code>ghost_edge_linestyle = :solid</code> sets the linestyle of the ghost edges.</p></li><li><p><code>ghost_edge_linewidth = 1</code> sets the width of the ghost edges.</p></li><li><p><code>ghost_edge_extension_factor = 0.1</code> sets the extension factor for the rectangle that the exterior ghost edges are extended onto.</p></li><li><p><code>bounding_box::Union{Automatic, Rect2, Tuple} = automatic</code>: Sets the bounding box for truncating ghost edges which can be a <code>Rect2</code> (or <code>BBox</code>) or a tuple of the form <code>(xmin, xmax, ymin, ymax)</code>. By default, the rectangle will be given by <code>[a - eÎx, b + eÎx] Ã [c - eÎy, d + eÎy]</code> where <code>e</code> is the <code>ghost_edge_extension_factor</code>, <code>Îx = b - a</code> and <code>Îy = d - c</code> are the lengths of the sides of the rectangle, and <code>[a, b] Ã [c, d]</code> is the bounding box of the points in the triangulation.</p></li><li><p><code>constrained_edge_color = :magenta</code> sets the color of the constrained edges.</p></li><li><p><code>constrained_edge_linestyle = :solid</code> sets the linestyle of the constrained edges.</p></li><li><p><code>constrained_edge_linewidth = 1</code> sets the width of the constrained edges.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="unicode_input"><a href="#unicode_input">unicode_input</a></div><div class="doc-content"><p>Registers a callback for keyboard unicode input. returns an <code>Observable{Vector{Char}}</code>, containing the pressed char. Is empty, if no key is pressed. <a href="http://www.glfw.org/docs/latest/group__input.html#ga1e008c7a8751cea648c8f42cc91104cf">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="update_cam!"><a href="#update_cam!">update_cam!</a></div><div class="doc-content"><pre><code>update_cam!(scene::SceneLike, area)</code></pre><p>Updates the camera for the given <code>scene</code> to cover the given <code>area</code> in 2d.</p><pre><code>update_cam!(scene::SceneLike)</code></pre><p>Updates the camera for the given <code>scene</code> to cover the limits of the <code>Scene</code>. Useful when using the <code>Observable</code> pipeline.</p><pre><code>update_cam!(scene::Scene, eyeposition, lookat, up = Vec3f(0, 0, 1))</code></pre><p>Updates the camera's controls to point to the specified location.</p></div></div><div class="docstring"><div class="doc-header" id="update_theme!"><a href="#update_theme!">update_theme!</a></div><div class="doc-content"><pre><code>update_theme!(with_theme::Theme; kwargs...)</code></pre><p>Update the current theme incrementally. This means that only the keys given in <code>with_theme</code> or through keyword arguments are changed, the rest is left intact. Nested attributes are either also updated incrementally, or replaced if they are not attributes in the new theme.</p><h1>Example</h1><p>To change the default colormap to <code>:greys</code>, you can pass that attribute as a keyword argument to <code>update_theme!</code> as demonstrated below.</p><pre><code>update_theme!(colormap=:greys)</code></pre><p>This can also be achieved by passing an object of types <code>Attributes</code> or <code>Theme</code> as the first and only positional argument:</p><pre><code>update_theme!(Attributes(colormap=:greys))
update_theme!(Theme(colormap=:greys))</code></pre></div></div><div class="docstring"><div class="doc-header" id="used_attributes"><a href="#used_attributes">used_attributes</a></div><div class="doc-content"><pre><code>used_attributes(args...) = ()</code></pre><p>Function used to indicate what keyword args one wants to get passed in <code>convert_arguments</code>. Those attributes will not be forwarded to the backend, but only used during the conversion pipeline. Usage:</p><pre><code class="language-julia">    struct MyType end
    used_attributes(::MyType) = (:attribute,)
    function convert_arguments(x::MyType; attribute = 1)
        ...
    end
    # attribute will get passed to convert_arguments
    # without keyword_verload, this wouldn't happen
    plot(MyType, attribute = 2)
    #You can also use the convenience macro, to overload convert_arguments in one step:
    @keywords convert_arguments(x::MyType; attribute = 1)
        ...
    end</code></pre></div></div><div class="docstring"><div class="doc-header" id="vgrid!"><a href="#vgrid!">vgrid!</a></div><div class="doc-content"><pre><code>vbox!(content::Vararg; kwargs...)</code></pre><p>Creates a single-column GridLayout with all elements contained in <code>content</code> placed from top to bottom.</p></div></div><div class="docstring"><div class="doc-header" id="violin"><a href="#violin">violin</a></div><div class="doc-content"><pre><code>violin(x, y; kwargs...)</code></pre><p>Draw a violin plot.</p><h1>Arguments</h1><ul><li><p><code>x</code>: positions of the categories</p></li><li><p><code>y</code>: variables whose density is computed</p></li></ul><h1>Keywords</h1><ul><li><p><code>weights</code>: vector of statistical weights (length of data). By default, each observation has weight <code>1</code>.</p></li><li><p><code>orientation=:vertical</code>: orientation of the violins (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=1</code>: width of the box before shrinking</p></li><li><p><code>gap=0.2</code>: shrinking factor, <code>width -&gt; width * (1 - gap)</code></p></li><li><p><code>show_median=false</code>: show median as midline</p></li><li><p><code>side=:both</code>: specify <code>:left</code> or <code>:right</code> to only plot the violin on one side</p></li><li><p><code>datalimits</code>: specify values to trim the <code>violin</code>. Can be a <code>Tuple</code> or a <code>Function</code> (e.g. <code>datalimits=extrema</code>)</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="violin!"><a href="#violin!">violin!</a></div><div class="doc-content"><pre><code>violin(x, y; kwargs...)</code></pre><p>Draw a violin plot.</p><h1>Arguments</h1><ul><li><p><code>x</code>: positions of the categories</p></li><li><p><code>y</code>: variables whose density is computed</p></li></ul><h1>Keywords</h1><ul><li><p><code>weights</code>: vector of statistical weights (length of data). By default, each observation has weight <code>1</code>.</p></li><li><p><code>orientation=:vertical</code>: orientation of the violins (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=1</code>: width of the box before shrinking</p></li><li><p><code>gap=0.2</code>: shrinking factor, <code>width -&gt; width * (1 - gap)</code></p></li><li><p><code>show_median=false</code>: show median as midline</p></li><li><p><code>side=:both</code>: specify <code>:left</code> or <code>:right</code> to only plot the violin on one side</p></li><li><p><code>datalimits</code>: specify values to trim the <code>violin</code>. Can be a <code>Tuple</code> or a <code>Function</code> (e.g. <code>datalimits=extrema</code>)</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="vlines"><a href="#vlines">vlines</a></div><div class="doc-content"><pre><code>vlines(xs; ymin = 0.0, ymax = 1.0, attrs...)</code></pre><p>Create vertical lines across a <code>Scene</code> with 2D projection. The lines will be placed at <code>xs</code> in data coordinates and <code>ymin</code> to <code>ymax</code> in scene coordinates (0 to 1). All three of these can have single or multiple values because they are broadcast to calculate the final line segments.</p><p>All style attributes are the same as for <code>LineSegments</code>.</p></div></div><div class="docstring"><div class="doc-header" id="vlines!"><a href="#vlines!">vlines!</a></div><div class="doc-content"><pre><code>vlines(xs; ymin = 0.0, ymax = 1.0, attrs...)</code></pre><p>Create vertical lines across a <code>Scene</code> with 2D projection. The lines will be placed at <code>xs</code> in data coordinates and <code>ymin</code> to <code>ymax</code> in scene coordinates (0 to 1). All three of these can have single or multiple values because they are broadcast to calculate the final line segments.</p><p>All style attributes are the same as for <code>LineSegments</code>.</p></div></div><div class="docstring"><div class="doc-header" id="volume"><a href="#volume">volume</a></div><div class="doc-content"><pre><code>volume(volume_data)
volume(x, y, z, volume_data)</code></pre><p>Plots a volume, with optional physical dimensions <code>x, y, z</code>. Available algorithms are:</p><ul><li><p><code>:iso</code> =&gt; IsoValue</p></li><li><p><code>:absorption</code> =&gt; Absorption</p></li><li><p><code>:mip</code> =&gt; MaximumIntensityProjection</p></li><li><p><code>:absorptionrgba</code> =&gt; AbsorptionRGBA</p></li><li><p><code>:additive</code> =&gt; AdditiveRGBA</p></li><li><p><code>:indexedabsorption</code> =&gt; IndexedAbsorptionRGBA</p></li></ul><h2>Attributes</h2><h3>Specific to <code>Volume</code></h3><ul><li><p><code>algorithm::Union{Symbol, RaymarchAlgorithm} = :mip</code> sets the volume algorithm that is used.</p></li><li><p><code>isorange::Real = 0.05</code> sets the range of values picked up by the IsoValue algorithm.</p></li><li><p><code>isovalue = 0.5</code> sets the target value for the IsoValue algorithm.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = true</code> enables lighting.</p></li><li><p><code>diffuse::Vec3f = Vec3f(0.4)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.2)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="volume!"><a href="#volume!">volume!</a></div><div class="doc-content"><pre><code>volume(volume_data)
volume(x, y, z, volume_data)</code></pre><p>Plots a volume, with optional physical dimensions <code>x, y, z</code>. Available algorithms are:</p><ul><li><p><code>:iso</code> =&gt; IsoValue</p></li><li><p><code>:absorption</code> =&gt; Absorption</p></li><li><p><code>:mip</code> =&gt; MaximumIntensityProjection</p></li><li><p><code>:absorptionrgba</code> =&gt; AbsorptionRGBA</p></li><li><p><code>:additive</code> =&gt; AdditiveRGBA</p></li><li><p><code>:indexedabsorption</code> =&gt; IndexedAbsorptionRGBA</p></li></ul><h2>Attributes</h2><h3>Specific to <code>Volume</code></h3><ul><li><p><code>algorithm::Union{Symbol, RaymarchAlgorithm} = :mip</code> sets the volume algorithm that is used.</p></li><li><p><code>isorange::Real = 0.05</code> sets the range of values picked up by the IsoValue algorithm.</p></li><li><p><code>isovalue = 0.5</code> sets the target value for the IsoValue algorithm.</p></li></ul><h3>3D shading attributes</h3><ul><li><p><code>shading = true</code> enables lighting.</p></li><li><p><code>diffuse::Vec3f = Vec3f(0.4)</code> sets how strongly the red, green and blue channel react to diffuse (scattered) light.</p></li><li><p><code>specular::Vec3f = Vec3f(0.2)</code> sets how strongly the object reflects light in the red, green and blue channels.</p></li><li><p><code>shininess::Real = 32.0</code> sets how sharp the reflection is.</p></li><li><p><code>ssao::Bool = false</code> adjusts whether the plot is rendered with ssao (screen space ambient occlusion). Note that this only makes sense in 3D plots and is only applicable with <code>fxaa = true</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul><h3>Generic attributes</h3><ul><li><p><code>visible::Bool = true</code> sets whether the plot will be rendered or not.</p></li><li><p><code>overdraw::Bool = false</code> sets whether the plot will draw over other plots. This specifically means ignoring depth checks in GL backends.</p></li><li><p><code>transparency::Bool = false</code> adjusts how the plot deals with transparency. In GLMakie <code>transparency = true</code> results in using Order Independent Transparency.</p></li><li><p><code>fxaa::Bool = true</code> adjusts whether the plot is rendered with fxaa (anti-aliasing).</p></li><li><p><code>inspectable::Bool = true</code> sets whether this plot should be seen by <code>DataInspector</code>.</p></li><li><p><code>depth_shift::Float32 = 0f0</code> adjusts the depth value of a plot after all other transformations, i.e. in clip space, where <code>0 &lt;= depth &lt;= 1</code>. This only applies to GLMakie and WGLMakie and can be used to adjust render order (like a tunable overdraw).</p></li><li><p><code>model::Makie.Mat4f</code> sets a model matrix for the plot. This replaces adjustments made with <code>translate!</code>, <code>rotate!</code> and <code>scale!</code>.</p></li><li><p><code>space::Symbol = :data</code> sets the transformation space for box encompassing the volume plot. See <code>Makie.spaces()</code> for possible inputs.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="volumeslices"><a href="#volumeslices">volumeslices</a></div><div class="doc-content"><p>VolumeSlices</p><pre><code>volumeslices(x, y, z, v)</code></pre><p>Draws heatmap slices of the volume v</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.volumeslices}</code> are: </p><pre><code>  alpha           1.0
  bbox_color      RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.5f0)
  bbox_visible    true
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  depth_shift     0.0f0
  highclip        MakieCore.Automatic()
  inspectable     true
  interpolate     false
  linewidth       0.0
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  space           :data
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="volumeslices!"><a href="#volumeslices!">volumeslices!</a></div><div class="doc-content"><p>VolumeSlices</p><pre><code>volumeslices(x, y, z, v)</code></pre><p>Draws heatmap slices of the volume v</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.volumeslices!}</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="voronoiplot"><a href="#voronoiplot">voronoiplot</a></div><div class="doc-content"><pre><code>voronoiplot(x, y, values; kwargs...)
voronoiplot(values; kwargs...)
voronoiplot(x, y; kwargs...)
voronoiplot(positions; kwargs...)
voronoiplot(vorn::VoronoiTessellation; kwargs...)</code></pre><p>Generates and plots a Voronoi tessalation from <code>heatmap</code>- or point-like data. The tessellation can also be passed directly as a <code>VoronoiTessellation</code> from DelaunayTriangulation.jl.</p><h2>Attributes</h2><ul><li><p><code>show_generators = true</code> determines whether to plot the individual generators.</p></li><li><p><code>markersize = 12</code> sets the size of the points.</p></li><li><p><code>marker = :circle</code> sets the shape of the points.</p></li><li><p><code>markercolor = :black</code> sets the color of the points.</p></li><li><p><code>strokecolor = :black</code> sets the strokecolor of the polygons.</p></li><li><p><code>strokewidth = 1</code> sets the width of the polygon stroke.</p></li><li><p><code>color = automatic</code> sets the color of the polygons. If <code>automatic</code>, the polygons will be individually colored according to the colormap.</p></li><li><p><code>unbounded_edge_extension_factor = 0.1</code> sets the extension factor for the unbounded edges, used in <code>DelaunayTriangulation.polygon_bounds</code>.</p></li><li><p><code>clip::Union{Automatic, Rect2, Circle, Tuple} = automatic</code> sets the clipping area for the generated polygons which can be a <code>Rect2</code> (or <code>BBox</code>), <code>Tuple</code> with entries <code>(xmin, xmax, ymin, ymax)</code> or as a <code>Circle</code>. Anything outside the specified area will be removed. If the <code>clip</code> is not set it is automatically determined using <code>unbounded_edge_extension_factor</code> as a <code>Rect</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="voronoiplot!"><a href="#voronoiplot!">voronoiplot!</a></div><div class="doc-content"><pre><code>voronoiplot(x, y, values; kwargs...)
voronoiplot(values; kwargs...)
voronoiplot(x, y; kwargs...)
voronoiplot(positions; kwargs...)
voronoiplot(vorn::VoronoiTessellation; kwargs...)</code></pre><p>Generates and plots a Voronoi tessalation from <code>heatmap</code>- or point-like data. The tessellation can also be passed directly as a <code>VoronoiTessellation</code> from DelaunayTriangulation.jl.</p><h2>Attributes</h2><ul><li><p><code>show_generators = true</code> determines whether to plot the individual generators.</p></li><li><p><code>markersize = 12</code> sets the size of the points.</p></li><li><p><code>marker = :circle</code> sets the shape of the points.</p></li><li><p><code>markercolor = :black</code> sets the color of the points.</p></li><li><p><code>strokecolor = :black</code> sets the strokecolor of the polygons.</p></li><li><p><code>strokewidth = 1</code> sets the width of the polygon stroke.</p></li><li><p><code>color = automatic</code> sets the color of the polygons. If <code>automatic</code>, the polygons will be individually colored according to the colormap.</p></li><li><p><code>unbounded_edge_extension_factor = 0.1</code> sets the extension factor for the unbounded edges, used in <code>DelaunayTriangulation.polygon_bounds</code>.</p></li><li><p><code>clip::Union{Automatic, Rect2, Circle, Tuple} = automatic</code> sets the clipping area for the generated polygons which can be a <code>Rect2</code> (or <code>BBox</code>), <code>Tuple</code> with entries <code>(xmin, xmax, ymin, ymax)</code> or as a <code>Circle</code>. Anything outside the specified area will be removed. If the <code>clip</code> is not set it is automatically determined using <code>unbounded_edge_extension_factor</code> as a <code>Rect</code>.</p></li></ul><h3>Color attributes</h3><ul><li><p><code>colormap::Union{Symbol, Vector{&lt;:Colorant}} = :viridis</code> sets the colormap that is sampled for numeric <code>color</code>s. <code>PlotUtils.cgrad(...)</code>, <code>Makie.Reverse(any_colormap)</code> can be used as well, or any symbol from ColorBrewer or PlotUtils. To see all available color gradients, you can call <code>Makie.available_gradients()</code>.</p></li><li><p><code>colorscale::Function = identity</code> color transform function. Can be any function, but only works well together with <code>Colorbar</code> for <code>identity</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>sqrt</code>, <code>logit</code>, <code>Makie.pseudolog10</code> and <code>Makie.Symlog10</code>.</p></li><li><p><code>colorrange::Tuple{&lt;:Real, &lt;:Real}</code> sets the values representing the start and end points of <code>colormap</code>.</p></li><li><p><code>nan_color::Union{Symbol, &lt;:Colorant} = RGBAf(0,0,0,0)</code> sets a replacement color for <code>color = NaN</code>.</p></li><li><p><code>lowclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value below the colorrange.</p></li><li><p><code>highclip::Union{Nothing, Symbol, &lt;:Colorant} = nothing</code> sets a color for any value above the colorrange.</p></li><li><p><code>alpha = 1.0</code> sets the alpha value of the colormap or color attribute. Multiple alphas like in <code>plot(alpha=0.2, color=(:red, 0.5)</code>, will get multiplied.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="vspan"><a href="#vspan">vspan</a></div><div class="doc-content"><pre><code>vspan(xs_low, xs_high; ymin = 0.0, ymax = 1.0, attrs...)</code></pre><p>Create vertical bands spanning across a <code>Scene</code> with 2D projection. The bands will be placed from <code>xs_low</code> to <code>xs_high</code> in data coordinates and <code>ymin</code> to <code>ymax</code> in scene coordinates (0 to 1). All four of these can have single or multiple values because they are broadcast to calculate the final spans.</p><p>All style attributes are the same as for <code>Poly</code>.</p></div></div><div class="docstring"><div class="doc-header" id="vspan!"><a href="#vspan!">vspan!</a></div><div class="doc-content"><pre><code>vspan(xs_low, xs_high; ymin = 0.0, ymax = 1.0, attrs...)</code></pre><p>Create vertical bands spanning across a <code>Scene</code> with 2D projection. The bands will be placed from <code>xs_low</code> to <code>xs_high</code> in data coordinates and <code>ymin</code> to <code>ymax</code> in scene coordinates (0 to 1). All four of these can have single or multiple values because they are broadcast to calculate the final spans.</p><p>All style attributes are the same as for <code>Poly</code>.</p></div></div><div class="docstring"><div class="doc-header" id="waterfall"><a href="#waterfall">waterfall</a></div><div class="doc-content"><pre><code>waterfall(x, y; kwargs...)</code></pre><p>Plots a <a href="https://en.wikipedia.org/wiki/Waterfall_chart">waterfall chart</a> to visualize individual positive and negative components that add up to a net result as a barplot with stacked bars next to each other.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.waterfall}</code> are: </p><pre><code>  cycle            [:color =&gt; :patchcolor]
  direction_color  :white
  dodge            MakieCore.Automatic()
  dodge_gap        0.03
  final_color      RGBA{Float64}(0.8980392156862745,0.8980392156862745,0.8980392156862745,0.5)
  final_dodge_gap  0
  final_gap        MakieCore.Automatic()
  gap              0.2
  marker_neg       :dtriangle
  marker_pos       :utriangle
  n_dodge          MakieCore.Automatic()
  show_direction   false
  show_final       false
  stack            MakieCore.Automatic()
  width            MakieCore.Automatic()</code></pre><p>Furthermore the same attributes as for <code>barplot</code> are supported.</p></div></div><div class="docstring"><div class="doc-header" id="waterfall!"><a href="#waterfall!">waterfall!</a></div><div class="doc-content"><pre><code>waterfall(x, y; kwargs...)</code></pre><p>Plots a <a href="https://en.wikipedia.org/wiki/Waterfall_chart">waterfall chart</a> to visualize individual positive and negative components that add up to a net result as a barplot with stacked bars next to each other.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Combined{Makie.waterfall!}</code> are: </p><pre><code></code></pre><p>Furthermore the same attributes as for <code>barplot</code> are supported.</p></div></div><div class="docstring"><div class="doc-header" id="width"><a href="#width">width</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.width</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "width" from GeometryBasics:
 [1] width(prim::GeometryBasics.HyperRectangle)
     @ ~/.julia/packages/GeometryBasics/b8075/src/primitives/rectangles.jl:164</code></pre></div></div><div class="docstring"><div class="doc-header" id="widths"><a href="#widths">widths</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.widths</code> is a <code>Function</code>.</p><pre><code># 4 methods for generic function "widths" from GeometryBasics:
 [1] widths(prim::GeometryBasics.HyperRectangle)
     @ ~/.julia/packages/GeometryBasics/b8075/src/primitives/rectangles.jl:162
 [2] widths(c::GeometryBasics.HyperSphere{N, T}) where {N, T}
     @ ~/.julia/packages/GeometryBasics/b8075/src/primitives/spheres.jl:28
 [3] widths(x::AbstractRange)
     @ ~/.julia/packages/GeometryBasics/b8075/src/geometry_primitives.jl:4
 [4] widths(scene::Scene)
     @ Makie ~/work/Makie.jl/Makie.jl/src/scenes.jl:366</code></pre></div></div><div class="docstring"><div class="doc-header" id="window_area"><a href="#window_area">window_area</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.window_area</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "window_area" from Makie:
 [1] window_area(scene::Scene, screen::GLMakie.Screen)
     @ GLMakie ~/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:71
 [2] window_area(scene, native_window)
     @ ~/work/Makie.jl/Makie.jl/src/interaction/events.jl:3</code></pre></div></div><div class="docstring"><div class="doc-header" id="window_open"><a href="#window_open">window_open</a></div><div class="doc-content"><p>Returns a signal, which is true as long as the window is open. returns <code>Observable{Bool}</code><a href="http://www.glfw.org/docs/latest/group__window.html#gaade9264e79fae52bdb78e2df11ee8d6a">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="wireframe"><a href="#wireframe">wireframe</a></div><div class="doc-content"><pre><code>wireframe(x, y, z)
wireframe(positions)
wireframe(mesh)</code></pre><p>Draws a wireframe, either interpreted as a surface or as a mesh.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>Wireframe</code> are: </p><pre><code>  alpha           1.0
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  colorscale      identity
  cycle           [:color]
  depth_shift     -1.0f-5
  highclip        MakieCore.Automatic()
  inspectable     true
  linestyle       "nothing"
  linewidth       1.5
  lowclip         MakieCore.Automatic()
  nan_color       :transparent
  overdraw        false
  space           :data
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="wireframe!"><a href="#wireframe!">wireframe!</a></div><div class="doc-content"><p>See <a href="@ref"><code>wireframe</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="with_theme"><a href="#with_theme">with_theme</a></div><div class="doc-content"><pre><code>with_theme(f, theme = Theme(); kwargs...)</code></pre><p>Calls <code>f</code> with <code>theme</code> temporarily activated. Attributes in <code>theme</code> can be overridden or extended with <code>kwargs</code>. The previous theme is always restored afterwards, no matter if <code>f</code> succeeds or fails.</p><p>Example:</p><pre><code class="language-julia">my_theme = Theme(resolution = (500, 500), color = :red)
with_theme(my_theme, color = :blue, linestyle = :dashed) do
    scatter(randn(100, 2))
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="with_updates_suspended"><a href="#with_updates_suspended">with_updates_suspended</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.with_updates_suspended</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "with_updates_suspended" from GridLayoutBase:
 [1] with_updates_suspended(f::Function, gl::GridLayout; update)
     @ ~/.julia/packages/GridLayoutBase/kiave/src/gridlayout.jl:232</code></pre></div></div><div class="docstring"><div class="doc-header" id="xlabel!"><a href="#xlabel!">xlabel!</a></div><div class="doc-content"><pre><code>xlabel!([scene,] xlabel)</code></pre><p>Set the x-axis label for the given Scene. Defaults to using the current Scene.</p></div></div><div class="docstring"><div class="doc-header" id="xlims!"><a href="#xlims!">xlims!</a></div><div class="doc-content"><pre><code>xlims!(ax, low, high)
xlims!(ax; low = nothing, high = nothing)
xlims!(ax, xlims)</code></pre><p>Set the x-axis limits of axis <code>ax</code> to <code>low</code> and <code>high</code> or a tuple <code>xlims = (low,high)</code>. If the limits are ordered high-low, the axis orientation will be reversed. If a limit is <code>nothing</code> it will be determined automatically from the plots in the axis.</p><pre><code>xlims!(low, high)
xlims!(; low = nothing, high = nothing)</code></pre><p>Set the x-axis limits of the current axis to <code>low</code> and <code>high</code>. If the limits are ordered high-low, this reverses the axis orientation. A limit set to <code>nothing</code> will be determined automatically from the plots in the axis.</p><pre><code>xlims!(ax = current_axis())</code></pre><p>Reset the x-axis limits to be determined automatically from the plots in the axis.</p></div></div><div class="docstring"><div class="doc-header" id="xticklabels"><a href="#xticklabels">xticklabels</a></div><div class="doc-content"><pre><code>xticklabels(scene)</code></pre><p>Returns the all the x-axis tick labels. See also <code>ticklabels</code>.</p></div></div><div class="docstring"><div class="doc-header" id="xtickrange"><a href="#xtickrange">xtickrange</a></div><div class="doc-content"><pre><code>xtickrange(scene)</code></pre><p>Returns the tick range along the x-axis. See also <code>tickranges</code>.</p></div></div><div class="docstring"><div class="doc-header" id="xtickrotation"><a href="#xtickrotation">xtickrotation</a></div><div class="doc-content"><pre><code>xtickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the x-axis. See also <code>tickrotations</code></p></div></div><div class="docstring"><div class="doc-header" id="xtickrotation!"><a href="#xtickrotation!">xtickrotation!</a></div><div class="doc-content"><pre><code>xtickrotation!([scene,] xangle)</code></pre><p>Set the rotation of tick labels along the x-axis. See also <code>tickrotations!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="xticks!"><a href="#xticks!">xticks!</a></div><div class="doc-content"><pre><code>xticks!([scene,]; xtickrange=xtickrange(scene), xticklabels=xticklabel(scene))</code></pre><p>Set the tick labels and range along the x-axes. See also <code>ticks!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ylabel!"><a href="#ylabel!">ylabel!</a></div><div class="doc-content"><pre><code>ylabel!([scene,] ylabel)</code></pre><p>Set the y-axis label for the given Scene. Defaults to using the current Scene.</p></div></div><div class="docstring"><div class="doc-header" id="ylims!"><a href="#ylims!">ylims!</a></div><div class="doc-content"><pre><code>ylims!(ax, low, high)
ylims!(ax; low = nothing, high = nothing)
ylims!(ax, ylims)</code></pre><p>Set the y-axis limits of axis <code>ax</code> to <code>low</code> and <code>high</code> or a tuple <code>ylims = (low,high)</code>. If the limits are ordered high-low, the axis orientation will be reversed. If a limit is <code>nothing</code> it will be determined automatically from the plots in the axis.</p><pre><code>ylims!(low, high)
ylims!(; low = nothing, high = nothing)</code></pre><p>Set the y-axis limits of the current axis to <code>low</code> and <code>high</code>. If the limits are ordered high-low, this reverses the axis orientation. A limit set to <code>nothing</code> will be determined automatically from the plots in the axis.</p><pre><code>ylims!(ax = current_axis())</code></pre><p>Reset the y-axis limits to be determined automatically from the plots in the axis.</p></div></div><div class="docstring"><div class="doc-header" id="yticklabels"><a href="#yticklabels">yticklabels</a></div><div class="doc-content"><pre><code>yticklabels(scene)</code></pre><p>Returns the all the y-axis tick labels. See also <code>ticklabels</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ytickrange"><a href="#ytickrange">ytickrange</a></div><div class="doc-content"><pre><code>ytickrange(scene)</code></pre><p>Returns the tick range along the y-axis. See also <code>tickranges</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ytickrotation"><a href="#ytickrotation">ytickrotation</a></div><div class="doc-content"><pre><code>ytickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the y-axis. See also <code>tickrotations</code></p></div></div><div class="docstring"><div class="doc-header" id="ytickrotation!"><a href="#ytickrotation!">ytickrotation!</a></div><div class="doc-content"><pre><code>ytickrotation!([scene,] yangle)</code></pre><p>Set the rotation of tick labels along the y-axis. See also <code>tickrotations!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="yticks!"><a href="#yticks!">yticks!</a></div><div class="doc-content"><pre><code>yticks!([scene,]; ytickrange=ytickrange(scene), yticklabels=yticklabel(scene))</code></pre><p>Set the tick labels and range along all the y-axis. See also <code>ticks!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="zlabel!"><a href="#zlabel!">zlabel!</a></div><div class="doc-content"><pre><code>zlabel!([scene,] zlabel)</code></pre><p>Set the z-axis label for the given Scene. Defaults to using the current Scene.</p><div class="admonition warning"><p class="admonition-title">Warning</p><p>The Scene must have an Axis3D.  If not, then this function will error.</p></div></div></div><div class="docstring"><div class="doc-header" id="zlims!"><a href="#zlims!">zlims!</a></div><div class="doc-content"><pre><code>zlims!(ax, low, high)
zlims!(ax; low = nothing, high = nothing)
zlims!(ax, zlims)</code></pre><p>Set the z-axis limits of axis <code>ax</code> to <code>low</code> and <code>high</code> or a tuple <code>zlims = (low,high)</code>. If the limits are ordered high-low, the axis orientation will be reversed. If a limit is <code>nothing</code> it will be determined automatically from the plots in the axis.</p><pre><code>zlims!(low, high)
zlims!(; low = nothing, high = nothing)</code></pre><p>Set the z-axis limits of the current axis to <code>low</code> and <code>high</code>. If the limits are ordered high-low, this reverses the axis orientation. A limit set to <code>nothing</code> will be determined automatically from the plots in the axis.</p><pre><code>zlims!(ax = current_axis())</code></pre><p>Reset the z-axis limits to be determined automatically from the plots in the axis.</p></div></div><div class="docstring"><div class="doc-header" id="zoom!"><a href="#zoom!">zoom!</a></div><div class="doc-content"><pre><code>zoom!(scene, zoom_step)</code></pre><p>Zooms the camera in or out based on the multiplier <code>zoom_step</code>. A <code>zoom_step</code> of 1.0 is neutral, larger zooms out and lower zooms in.</p><p>Note that this method only applies to Camera3D.</p><pre><code>zoom!(scene, point, zoom_step, shift_lookat::Bool)</code></pre><p>Zooms the camera of <code>scene</code> in towards <code>point</code> by a factor of <code>zoom_step</code>. A positive <code>zoom_step</code> zooms in while a negative <code>zoom_step</code> zooms out.</p></div></div><div class="docstring"><div class="doc-header" id="zticklabels"><a href="#zticklabels">zticklabels</a></div><div class="doc-content"><pre><code>zticklabels(scene)</code></pre><p>Returns the all the z-axis tick labels. See also <code>ticklabels</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ztickrange"><a href="#ztickrange">ztickrange</a></div><div class="doc-content"><pre><code>ztickrange(scene)</code></pre><p>Returns the tick range along the z-axis. See also <code>tickranges</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ztickrotation"><a href="#ztickrotation">ztickrotation</a></div><div class="doc-content"><pre><code>ztickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the z-axis. See also <code>tickrotations</code></p></div></div><div class="docstring"><div class="doc-header" id="ztickrotation!"><a href="#ztickrotation!">ztickrotation!</a></div><div class="doc-content"><pre><code>ztickrotation!([scene,] zangle)</code></pre><p>Set the rotation of tick labels along the z-axis. See also <code>tickrotations!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="zticks!"><a href="#zticks!">zticks!</a></div><div class="doc-content"><pre><code>zticks!([scene,]; ztickranges=ztickrange(scene), zticklabels=zticklabel(scene))</code></pre><p>Set the tick labels and range along all z-axis. See also <code>ticks!</code>.</p></div></div><div class="page-foot"><div class="copyright">
    Â© Makie.jl. Last modified: October 31, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
      <p>These docs were autogenerated using Makie: v0.19.12, GLMakie: v0.8.12, CairoMakie: v0.10.12, WGLMakie: v0.8.16</p></div></div></div></div><div class="page__footer"><footer><div class="page__footer-follow"><ul class="social-icons"><li><a href="https://twitter.com/MakiePlots" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-twitter-square"></i> Twitter</a></li><li><a href="https://github.com/JuliaPlots/Makie.jl" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-github"></i> GitHub</a></li></ul></div><div class="page__footer-copyright">Â© Makie.jl. Powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div></footer></div></div><script src="../../versions.js" type="text/javascript"></script><script src="../siteinfo.js" type="text/javascript"></script><script src="../libs/warner.js" type="text/javascript"></script><script src="../libs/navbar.js"></script><link href="../_pagefind/pagefind-ui.css" rel="stylesheet"/><script src="../_pagefind/pagefind-ui.js" type="text/javascript"></script><script>
        window.addEventListener('DOMContentLoaded', (event) => {
            new PagefindUI({
              element: "#makiesearch",
              showImages: false
            });
            new PagefindUI({
              element: "#makiesearch-overlay",
              showImages: false
            });
        });
    </script><script async="" defer="" src="https://api.makie.org/latest.js"></script><noscript><img alt="" referrerpolicy="no-referrer-when-downgrade" src="https://api.makie.org/noscript.gif"/></noscript></body></HTML>