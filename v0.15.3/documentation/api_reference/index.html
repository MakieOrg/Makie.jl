<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/><link href="../../css/franklin.css" rel="stylesheet"/><link href="../../css/minimal-mistakes.css" rel="stylesheet"/><link href="../../css/makie.css" rel="stylesheet"/><link href="../../assets/icon_transparent.png" rel="icon"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><title>API reference</title></head><body class="layout--single"><div class="site-container"><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav class="greedy-nav" id="site-nav"><a class="title-icon" href="../.."><img src="../../assets/makie_logo_transparent.svg"/></a><ul class="visible-links"><li class="masthead__menu-item"><a href="https://github.com/JuliaPlots/Makie.jl"><img class="masthead-icon" src="../../assets/GitHub-Mark-64px.png"/></a></li><li class="masthead__menu-item"><a href="../../examples/">Examples</a></li><li class="masthead__menu-item"><a href="../../tutorials/">Tutorials</a></li><li class="masthead__menu-item"><a href="..">Documentation</a></li></ul><button class="greedy-nav__toggle" type="button"><span class="visually-hidden">Toggle menu</span><div class="navicon"></div></button><ul class="hidden-links hidden"></ul></nav></div></div></div><div id="main" role="main"><div id="overlay"></div><div id="navbar-container"><div id="navbar"><form action="../../search/index.html" id="lunrSearchForm" name="lunrSearchForm"><input class="search-input" name="q" placeholder="Search docs" type="text"/></form><h1>Navigation</h1><ul><li><div class="tocitem-container"><a href="../..">Home</a></div></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-2"><i class="docs-chevron"></i></label><a href="../../examples">Examples</a></div><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-2-1"><i class="docs-chevron"></i></label><a href="../../examples/layoutables">Layoutables &amp; Widgets</a></div><ul><li><div class="tocitem-container"><a href="../../examples/layoutables/axis">Axis</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/axis3">Axis3</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/box">Box</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/button">Button</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/colorbar">Colorbar</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/gridlayout">GridLayout</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/intervalslider">IntervalSlider</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/label">Label</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/legend">Legend</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/lscene">LScene</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/menu">Menu</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/slider">Slider</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/textbox">Textbox</a></div></li><li><div class="tocitem-container"><a href="../../examples/layoutables/toggle">Toggle</a></div></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-2-2"><i class="docs-chevron"></i></label><a href="../../examples/plotting_functions">Plotting functions</a></div><ul><li><div class="tocitem-container"><a href="../../examples/plotting_functions/abline">abline!</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/arrows">arrows</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/band">band</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/barplot">barplot</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/boxplot">boxplot</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/contour">contour</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/contourf">contourf</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/crossbar">crossbar</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/density">density</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/errorbars">errorbars</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/heatmap">heatmap</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/hist">hist</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/hvlines">hlines! and vlines!</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/hvspan">hspan! and vspan!</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/image">image</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/lines">lines</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/linesegments">linesegments</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/mesh">mesh</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/meshscatter">meshscatter</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/poly">poly</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/rangebars">rangebars</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/scatter">scatter</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/scatterlines">scatterlines</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/series">series</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/stairs">stairs</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/stem">stem</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/streamplot">streamplot</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/surface">surface</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/text">text</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/violin">violin</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/volume">volume</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/volumeslices">volumeslices</a></div></li><li><div class="tocitem-container"><a href="../../examples/plotting_functions/wireframe">wireframe</a></div></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-3"><i class="docs-chevron"></i></label><a href="../../tutorials">Tutorials</a></div><ul><li><div class="tocitem-container"><a href="../../tutorials/basic-tutorial">Basic Tutorial</a></div></li><li><div class="tocitem-container"><a href="../../tutorials/layout-tutorial">Layout Tutorial</a></div></li></ul></li><li><input checked="" class="collapse-toggle" id="menuitem-4" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-4"><i class="docs-chevron"></i></label><a href="..">Documentation</a></div><ul><li><div class="tocitem-container"><a class="active" href="">API reference</a></div><ul class="page-content"><li><a href="#api_reference">API reference</a></li></ul></li><li><div class="tocitem-container"><a href="../animation">Animations</a></div></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-4-3"><i class="docs-chevron"></i></label><a href="../backends_and_output">Backends &amp; Output</a></div><ul><li><div class="tocitem-container"><a href="../backends_and_output/figure_size">Exporting a Figure with physical dimensions</a></div></li><li><div class="tocitem-container"><a href="../backends_and_output/wglmakie">JSServe and WGLMakie</a></div></li></ul></li><li><div class="tocitem-container"><a href="../cameras">Cameras</a></div></li><li><div class="tocitem-container"><a href="../colors">Colors</a></div></li><li><div class="tocitem-container"><a href="../events">Events</a></div></li><li><div class="tocitem-container"><a href="../faq">Frequently Asked Questions</a></div></li><li><div class="tocitem-container"><a href="../figure">Figures</a></div></li><li><div class="tocitem-container"><a href="../inspector">Inspecting Data</a></div></li><li><div class="tocitem-container"><a href="../latex">LaTeX</a></div></li><li><div class="tocitem-container"><a href="../layoutables">Layoutables</a></div></li><li><div class="tocitem-container"><a href="../layouting">How layouts work</a></div></li><li><div class="tocitem-container"><a href="../lighting">Lighting</a></div></li><li><div class="tocitem-container"><a href="../news">News</a></div></li><li><div class="tocitem-container"><a href="../nodes">Observables &amp; Interaction</a></div></li><li><div class="tocitem-container"><a href="../plot_method_signatures">Plot Method Signatures</a></div></li><li><div class="tocitem-container"><a href="../recipes">Plot Recipes</a></div></li><li><div class="tocitem-container"><a href="../remote">Remote servers</a></div></li><li><div class="tocitem-container"><a href="../scenes">Scenes</a></div></li><li><input class="collapse-toggle" id="menuitem-4-20" type="checkbox"/><div class="tocitem-container"><label class="tocexpander" for="menuitem-4-20"><i class="docs-chevron"></i></label><a href="../theming">Theming</a></div><ul><li><div class="tocitem-container"><a href="../theming/predefined_themes">Predefined themes</a></div></li></ul></li></ul></li></ul></div></div><div class="franklin-content"><h1 id="api_reference"><a class="header-anchor" href="#api_reference">API reference</a></h1><div class="docstring"><div class="doc-header" id=".."><a href="#..">..</a></div><div class="doc-content"><pre><code>...</code></pre><p>The "splat" operator, <code>...</code>, represents a sequence of arguments. <code>...</code> can be used in function definitions, to indicate that the function accepts an arbitrary number of arguments. <code>...</code> can also be used to apply a function to a sequence of arguments.</p><h1>Examples</h1><pre><code class="language-jldoctest">julia&gt; add(xs...) = reduce(+, xs)
add (generic function with 1 method)

julia&gt; add(1, 2, 3, 4, 5)
15

julia&gt; add([1, 2, 3]...)
6

julia&gt; add(7, 1:100..., 1000:1100...)
111107</code></pre></div></div><div class="docstring"><div class="doc-header" id="@L_str"><a href="#@L_str">@L_str</a></div><div class="doc-content"><pre><code>L"..."</code></pre><p>Creates a <code>LaTeXString</code> and is equivalent to <code>latexstring(raw"...")</code>, except that <code>%$</code> can be used for interpolation.</p><pre><code class="language-jldoctest">julia&gt; L"x = \sqrt{2}"
L"$x = \sqrt{2}$"

julia&gt; L"x = %$(sqrt(2))"
L"$x = 1.4142135623730951$"</code></pre></div></div><div class="docstring"><div class="doc-header" id="@extract"><a href="#@extract">@extract</a></div><div class="doc-content"><p>usage @exctract scene (a, b, c, d)</p></div></div><div class="docstring"><div class="doc-header" id="@extractvalue"><a href="#@extractvalue">@extractvalue</a></div><div class="doc-content"><p>usage @extractvalue scene (a, b, c, d) will become:</p><pre><code class="language-julia">begin
    a = to_value(scene[:a])
    b = to_value(scene[:b])
    c = to_value(scene[:c])
    (a, b, c)
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="@get_attribute"><a href="#@get_attribute">@get_attribute</a></div><div class="doc-content"><pre><code>@get_attribute scene (a, b, c, d)</code></pre><p>This will extract attribute <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> from <code>scene</code> and apply the correct attribute conversions + will extract the value if it's a signal. It will make those attributes available as variables and return them as a tuple. So the above is equal to: will become:</p><pre><code class="language-julia">begin
    a = get_attribute(scene, :a)
    b = get_attribute(scene, :b)
    c = get_attribute(scene, :c)
    (a, b, c)
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="@key_str"><a href="#@key_str">@key_str</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.@key_str</code> is a macro.</p><pre><code># 1 method for macro "@key_str":
[1] var"@key_str"(__source__::LineNumberNode, __module__::Module, arg) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/types.jl:40</code></pre></div></div><div class="docstring"><div class="doc-header" id="@lift"><a href="#@lift">@lift</a></div><div class="doc-content"><p>Replaces an expression with lift(argtuple -&gt; expression, args...), where args are all expressions inside the main one that begin with $.</p><h1>Example:</h1><p>x = Node(rand(100)) y = Node(rand(100))</p><h2>before</h2><p>z = lift((x, y) -&gt; x .+ y, x, y)</p><h2>after</h2><p>z = @lift(x .+ y)</p><p>You can also use parentheses around an expression if that expression evaluates to a node.</p><pre><code class="language-julia">nt = (x = Node(1), y = Node(2))
@lift($(nt.x) + $(nt.y))</code></pre></div></div><div class="docstring"><div class="doc-header" id="@recipe"><a href="#@recipe">@recipe</a></div><div class="doc-content"><h1>Plot Recipes in <code>Makie</code></h1><p>There's two types of recipes. <em>Type recipes</em> define a simple mapping from a user defined type to an existing plot type. <em>Full recipes</em> can customize the theme and define a custom plotting function.</p><h2>Type recipes</h2><p>Type recipe are really simple and just overload the argument conversion pipeline. This can be done for all plot types or for a subset of plot types:</p><pre><code># All plot types
convert_arguments(P::Type{&lt;:AbstractPlot}, x::MyType) = convert_arguments(P, rand(10, 10))
# Only for scatter plots
convert_arguments(P::Type{&lt;:Scatter}, x::MyType) = convert_arguments(P, rand(10, 10))</code></pre><p>Optionally you may define the default plot type so that <code>plot(x::MyType)</code> will use this:</p><pre><code>plottype(::MyType) = Surface</code></pre><h2>Full recipes with the <code>@recipe</code> macro</h2><p>A full recipe for <code>MyPlot</code> comes in two parts. First is the plot type name, arguments and theme definition which are defined using the <code>@recipe</code> macro. Second is a custom <code>plot!</code> for <code>MyPlot</code>, implemented in terms of the atomic plotting functions.</p><p>We use an example to show how this works:</p><pre><code># arguments (x, y, z) &amp;&amp; theme are optional
@recipe(MyPlot, x, y, z) do scene
    Attributes(
        plot_color =&gt; :red
    )
end</code></pre><p>This macro expands to several things. Firstly a type definition:</p><pre><code>const MyPlot{ArgTypes} = Combined{myplot, ArgTypes}</code></pre><p>The type parameter of <code>Combined</code> contains the function instead of e.g. a symbol. This way the mapping from <code>MyPlot</code> to <code>myplot</code> is safer and simpler. (The downside is we always need a function <code>myplot</code> - TODO: is this a problem?)</p><p>The following signatures are defined to make <code>MyPlot</code> nice to use:</p><pre><code>myplot(args...; kw_args...) = ...
myplot!(scene, args...; kw_args...) = ...
myplot(kw_args::Dict, args...) = ...
myplot!(scene, kw_args::Dict, args...) = ...
#etc (not 100% settled what signatures there will be)</code></pre><p>A specialization of <code>argument_names</code> is emitted if you have an argument list <code>(x,y,z)</code> provided to the recipe macro:</p><pre><code>argument_names(::Type{&lt;: MyPlot}) = (:x, :y, :z)</code></pre><p>This is optional but it will allow the use of <code>plot_object[:x]</code> to fetch the first argument from the call <code>plot_object = myplot(rand(10), rand(10), rand(10))</code>, for example. Alternatively you can always fetch the <code>i</code>th argument using <code>plot_object[i]</code>, and if you leave out the <code>(x,y,z)</code>, the default version of <code>argument_names</code> will provide <code>plot_object[:arg1]</code> etc.</p><p>The theme given in the body of the <code>@recipe</code> invocation is inserted into a specialization of <code>default_theme</code> which inserts the theme into any scene that plots <code>MyPlot</code>:</p><pre><code>function default_theme(scene, ::MyPlot)
    Attributes(
        plot_color =&gt; :red
    )
end</code></pre><p>As the second part of defining <code>MyPlot</code>, you should implement the actual plotting of the <code>MyPlot</code> object by specializing <code>plot!</code>:</p><pre><code>function plot!(plot::MyPlot)
    # normal plotting code, building on any previously defined recipes
    # or atomic plotting operations, and adding to the combined `plot`:
    lines!(plot, rand(10), color = plot[:plot_color])
    plot!(plot, plot[:x], plot[:y])
    plot
end</code></pre><p>It's possible to add specializations here, depending on the argument <em>types</em> supplied to <code>myplot</code>. For example, to specialize the behavior of <code>myplot(a)</code> when <code>a</code> is a 3D array of floating point numbers:</p><pre><code>const MyVolume = MyPlot{Tuple{&lt;:AbstractArray{&lt;: AbstractFloat, 3}}}
argument_names(::Type{&lt;: MyVolume}) = (:volume,) # again, optional
function plot!(plot::MyVolume)
    # plot a volume with a colormap going from fully transparent to plot_color
    volume!(plot, plot[:volume], colormap = :transparent =&gt; plot[:plot_color])
    plot
end</code></pre><p>The docstring given to the recipe will be transferred to the functions it generates.</p></div></div><div class="docstring"><div class="doc-header" id="Absolute"><a href="#Absolute">Absolute</a></div><div class="doc-content"><pre><code>Absolute</code></pre><p>Force transformation to be absolute, not relative to the current state. This is the default setting.</p></div></div><div class="docstring"><div class="doc-header" id="Absorption"><a href="#Absorption">Absorption</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Absorption</code> is of type <code>Makie.RaymarchAlgorithm</code>.</p><h1>Summary</h1><pre><code>primitive type Makie.RaymarchAlgorithm &lt;: Enum{Int32}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Makie.RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbsorptionRGBA"><a href="#AbsorptionRGBA">AbsorptionRGBA</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.AbsorptionRGBA</code> is of type <code>Makie.RaymarchAlgorithm</code>.</p><h1>Summary</h1><pre><code>primitive type Makie.RaymarchAlgorithm &lt;: Enum{Int32}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Makie.RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbstractCamera"><a href="#AbstractCamera">AbstractCamera</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type Makie.AbstractCamera &lt;: Any</code></pre><h1>Subtypes</h1><pre><code>Makie.Camera2D
Makie.Camera3D
Makie.EmptyCamera
Makie.OldCamera3D
Makie.PixelCamera</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbstractPlot"><a href="#AbstractPlot">AbstractPlot</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.AbstractPlot</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbstractScene"><a href="#AbstractScene">AbstractScene</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type MakieCore.AbstractScene &lt;: MakieCore.Transformable</code></pre><h1>Subtypes</h1><pre><code>Makie.Scene</code></pre><h1>Supertype Hierarchy</h1><pre><code>MakieCore.AbstractScene &lt;: MakieCore.Transformable &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AbstractScreen"><a href="#AbstractScreen">AbstractScreen</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type MakieCore.AbstractScreen &lt;: AbstractDisplay</code></pre><h1>Subtypes</h1><pre><code>CairoMakie.CairoScreen
GLMakie.GLScreen</code></pre><h1>Supertype Hierarchy</h1><pre><code>MakieCore.AbstractScreen &lt;: AbstractDisplay &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Accum"><a href="#Accum">Accum</a></div><div class="doc-content"><pre><code>Accum</code></pre><p>Force transformation to be relative to the current state, not absolute.</p></div></div><div class="docstring"><div class="doc-header" id="Annotations"><a href="#Annotations">Annotations</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Annotations</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Arc"><a href="#Arc">Arc</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Arc</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Arrows"><a href="#Arrows">Arrows</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Arrows</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Aspect"><a href="#Aspect">Aspect</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.Aspect &lt;: GridLayoutBase.ContentSize</code></pre><h1>Fields</h1><pre><code>index :: Int64
ratio :: Float64</code></pre><h1>Supertype Hierarchy</h1><pre><code>GridLayoutBase.Aspect &lt;: GridLayoutBase.ContentSize &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Atomic"><a href="#Atomic">Atomic</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Atomic</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Attributes"><a href="#Attributes">Attributes</a></div><div class="doc-content"><p>Main structure for holding attributes, for theming plots etc! Will turn all values into nodes, so that they can be updated.</p></div></div><div class="docstring"><div class="doc-header" id="Auto"><a href="#Auto">Auto</a></div><div class="doc-content"><pre><code>struct Auto &lt;: ContentSize</code></pre><p>If used as a <code>GridLayout</code>'s row / column size and <code>trydetermine == true</code>, signals to the <code>GridLayout</code> that the row / column should shrink to match the largest determinable element inside. If no size of a content element can be determined, the remaining space is split between all <code>Auto</code> rows / columns according to their <code>ratio</code>.</p><p>If used as width / height of a layoutable element and <code>trydetermine == true</code>, the element's computed width / height will report the auto width / height if it can be determined. This enables a parent <code>GridLayout</code> to adjust its column / rowsize to the element's width / height. If <code>trydetermine == false</code>, the element's computed width / height will report <code>nothing</code> even if an auto width / height can be determined, which will prohibit a parent <code>GridLayout</code> from adjusting a row / column to the element's width / height. This is useful to, e.g., prohibit a <code>GridLayout</code> from shrinking a column's width to the width of a super title, even though the title's width can be auto-determined.</p><p>The <code>ratio</code> is ignored if <code>Auto</code> is used as an element size.</p></div></div><div class="docstring"><div class="doc-header" id="Axis"><a href="#Axis">Axis</a></div><div class="doc-content"><p>Axis has the following attributes:</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The align mode of the axis in its parent GridLayout.</p><p><code>aspect</code><br/>Default: <code>nothing</code><br/>The forced aspect ratio of the axis. <code>nothing</code> leaves the axis unconstrained, <code>DataAspect()</code> forces the same ratio as the ratio in data limits between x and y axis, <code>AxisAspect(ratio)</code> sets a manual ratio.</p><p><code>autolimitaspect</code><br/>Default: <code>nothing</code><br/>Constrains the data aspect ratio (<code>nothing</code> leaves the ratio unconstrained).</p><p><code>backgroundcolor</code><br/>Default: <code>:white</code><br/>The background color of the axis.</p><p><code>bottomspinecolor</code><br/>Default: <code>:black</code><br/>The color of the bottom axis spine.</p><p><code>bottomspinevisible</code><br/>Default: <code>true</code><br/>Controls if the bottom axis spine is visible.</p><p><code>flip_ylabel</code><br/>Default: <code>false</code><br/>Controls if the ylabel's rotation is flipped.</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the axis within its suggested bounding box.</p><p><code>height</code><br/>Default: <code>nothing</code><br/>The height of the axis.</p><p><code>leftspinecolor</code><br/>Default: <code>:black</code><br/>The color of the left axis spine.</p><p><code>leftspinevisible</code><br/>Default: <code>true</code><br/>Controls if the left axis spine is visible.</p><p><code>limits</code><br/>Default: <code>(nothing, nothing)</code><br/>The limits that the user has manually set. They are reinstated when calling <code>reset_limits!</code> and are set to nothing by <code>autolimits!</code>. Can be either a tuple (xlow, xhigh, ylow, high) or a tuple (nothing<em>or</em>xlims, nothing<em>or</em>ylims). Are set by <code>xlims!</code>, <code>ylims!</code> and <code>limits!</code>.</p><p><code>palette</code><br/>Default: <code>if scene !== nothing &amp;&amp; haskey(scene.attributes, :palette)     deepcopy(scene.palette) else     Attributes() end</code><br/>Attributes with one palette per key, for example <code>color = [:red, :green, :blue]</code></p><p><code>panbutton</code><br/>Default: <code>Makie.Mouse.right</code><br/>The button for panning.</p><p><code>rightspinecolor</code><br/>Default: <code>:black</code><br/>The color of the right axis spine.</p><p><code>rightspinevisible</code><br/>Default: <code>true</code><br/>Controls if the right axis spine is visible.</p><p><code>spinewidth</code><br/>Default: <code>1.0</code><br/>The width of the axis spines.</p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>title</code><br/>Default: <code>""</code><br/>The axis title string.</p><p><code>titlealign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the title.</p><p><code>titlecolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The color of the title</p><p><code>titlefont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The font family of the title.</p><p><code>titlegap</code><br/>Default: <code>4.0</code><br/>The gap between axis and title.</p><p><code>titlesize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The title's font size.</p><p><code>titlevisible</code><br/>Default: <code>true</code><br/>Controls if the title is visible.</p><p><code>topspinecolor</code><br/>Default: <code>:black</code><br/>The color of the top axis spine.</p><p><code>topspinevisible</code><br/>Default: <code>true</code><br/>Controls if the top axis spine is visible.</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the axis within its suggested bounding box.</p><p><code>width</code><br/>Default: <code>nothing</code><br/>The width of the axis.</p><p><code>xautolimitmargin</code><br/>Default: <code>(0.05f0, 0.05f0)</code><br/>The relative margins added to the autolimits in x direction.</p><p><code>xaxisposition</code><br/>Default: <code>:bottom</code><br/>The position of the x axis (<code>:bottom</code> or <code>:top</code>).</p><p><code>xgridcolor</code><br/>Default: <code>RGBAf(0, 0, 0, 0.12)</code><br/>The color of the x grid lines.</p><p><code>xgridstyle</code><br/>Default: <code>nothing</code><br/>The linestyle of the x grid lines.</p><p><code>xgridvisible</code><br/>Default: <code>true</code><br/>Controls if the x grid lines are visible.</p><p><code>xgridwidth</code><br/>Default: <code>1.0</code><br/>The width of the x grid lines.</p><p><code>xlabel</code><br/>Default: <code>""</code><br/>The xlabel string.</p><p><code>xlabelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The color of the xlabel.</p><p><code>xlabelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The font family of the xlabel.</p><p><code>xlabelpadding</code><br/>Default: <code>3.0</code><br/>The padding between the xlabel and the ticks or axis.</p><p><code>xlabelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The font size of the xlabel.</p><p><code>xlabelvisible</code><br/>Default: <code>true</code><br/>Controls if the xlabel is visible.</p><p><code>xminorgridcolor</code><br/>Default: <code>RGBAf(0, 0, 0, 0.05)</code><br/>The color of the x minor grid lines.</p><p><code>xminorgridstyle</code><br/>Default: <code>nothing</code><br/>The linestyle of the x minor grid lines.</p><p><code>xminorgridvisible</code><br/>Default: <code>false</code><br/>Controls if the x minor grid lines are visible.</p><p><code>xminorgridwidth</code><br/>Default: <code>1.0</code><br/>The width of the x minor grid lines.</p><p><code>xminortickalign</code><br/>Default: <code>0.0</code><br/>The alignment of x minor ticks on the axis spine</p><p><code>xminortickcolor</code><br/>Default: <code>:black</code><br/>The tick color of x minor ticks</p><p><code>xminorticks</code><br/>Default: <code>IntervalsBetween(2)</code><br/>The tick locator for the x minor ticks</p><p><code>xminorticksize</code><br/>Default: <code>4.0</code><br/>The tick size of x minor ticks</p><p><code>xminorticksvisible</code><br/>Default: <code>false</code><br/>Controls if minor ticks on the x axis are visible</p><p><code>xminortickwidth</code><br/>Default: <code>1.0</code><br/>The tick width of x minor ticks</p><p><code>xpankey</code><br/>Default: <code>Makie.Keyboard.x</code><br/>The key for limiting panning to the x direction.</p><p><code>xpanlock</code><br/>Default: <code>false</code><br/>Locks interactive panning in the x direction.</p><p><code>xrectzoom</code><br/>Default: <code>true</code><br/>Controls if rectangle zooming affects the x dimension.</p><p><code>xreversed</code><br/>Default: <code>false</code><br/>Controls if the x axis goes rightwards (false) or leftwards (true)</p><p><code>xscale</code><br/>Default: <code>identity</code><br/>The x axis scale</p><p><code>xtickalign</code><br/>Default: <code>0.0</code><br/>The alignment of the xtick marks relative to the axis spine (0 = out, 1 = in).</p><p><code>xtickcolor</code><br/>Default: <code>RGBf(0, 0, 0)</code><br/>The color of the xtick marks.</p><p><code>xtickformat</code><br/>Default: <code>Makie.automatic</code><br/>Format for xticks.</p><p><code>xticklabelalign</code><br/>Default: <code>Makie.automatic</code><br/>The horizontal and vertical alignment of the xticklabels.</p><p><code>xticklabelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The color of xticklabels.</p><p><code>xticklabelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The font family of the xticklabels.</p><p><code>xticklabelpad</code><br/>Default: <code>2.0</code><br/>The space between xticks and xticklabels.</p><p><code>xticklabelrotation</code><br/>Default: <code>0.0</code><br/>The counterclockwise rotation of the xticklabels in radians.</p><p><code>xticklabelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The font size of the xticklabels.</p><p><code>xticklabelspace</code><br/>Default: <code>Makie.automatic</code><br/>The space reserved for the xticklabels.</p><p><code>xticklabelsvisible</code><br/>Default: <code>true</code><br/>Controls if the xticklabels are visible.</p><p><code>xticks</code><br/>Default: <code>Makie.automatic</code><br/>The xticks.</p><p><code>xticksize</code><br/>Default: <code>6.0</code><br/>The size of the xtick marks.</p><p><code>xticksvisible</code><br/>Default: <code>true</code><br/>Controls if the xtick marks are visible.</p><p><code>xtickwidth</code><br/>Default: <code>1.0</code><br/>The width of the xtick marks.</p><p><code>xtrimspine</code><br/>Default: <code>false</code><br/>Controls if the x spine is limited to the furthest tick marks or not.</p><p><code>xzoomkey</code><br/>Default: <code>Makie.Keyboard.x</code><br/>The key for limiting zooming to the x direction.</p><p><code>xzoomlock</code><br/>Default: <code>false</code><br/>Locks interactive zooming in the x direction.</p><p><code>yautolimitmargin</code><br/>Default: <code>(0.05f0, 0.05f0)</code><br/>The relative margins added to the autolimits in y direction.</p><p><code>yaxisposition</code><br/>Default: <code>:left</code><br/>The position of the y axis (<code>:left</code> or <code>:right</code>).</p><p><code>ygridcolor</code><br/>Default: <code>RGBAf(0, 0, 0, 0.12)</code><br/>The color of the y grid lines.</p><p><code>ygridstyle</code><br/>Default: <code>nothing</code><br/>The linestyle of the y grid lines.</p><p><code>ygridvisible</code><br/>Default: <code>true</code><br/>Controls if the y grid lines are visible.</p><p><code>ygridwidth</code><br/>Default: <code>1.0</code><br/>The width of the y grid lines.</p><p><code>ylabel</code><br/>Default: <code>""</code><br/>The ylabel string.</p><p><code>ylabelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The color of the ylabel.</p><p><code>ylabelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The font family of the ylabel.</p><p><code>ylabelpadding</code><br/>Default: <code>5.0</code><br/>The padding between the ylabel and the ticks or axis.</p><p><code>ylabelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The font size of the ylabel.</p><p><code>ylabelvisible</code><br/>Default: <code>true</code><br/>Controls if the ylabel is visible.</p><p><code>yminorgridcolor</code><br/>Default: <code>RGBAf(0, 0, 0, 0.05)</code><br/>The color of the y minor grid lines.</p><p><code>yminorgridstyle</code><br/>Default: <code>nothing</code><br/>The linestyle of the y minor grid lines.</p><p><code>yminorgridvisible</code><br/>Default: <code>false</code><br/>Controls if the y minor grid lines are visible.</p><p><code>yminorgridwidth</code><br/>Default: <code>1.0</code><br/>The width of the y minor grid lines.</p><p><code>yminortickalign</code><br/>Default: <code>0.0</code><br/>The alignment of y minor ticks on the axis spine</p><p><code>yminortickcolor</code><br/>Default: <code>:black</code><br/>The tick color of y minor ticks</p><p><code>yminorticks</code><br/>Default: <code>IntervalsBetween(2)</code><br/>The tick locator for the y minor ticks</p><p><code>yminorticksize</code><br/>Default: <code>4.0</code><br/>The tick size of y minor ticks</p><p><code>yminorticksvisible</code><br/>Default: <code>false</code><br/>Controls if minor ticks on the y axis are visible</p><p><code>yminortickwidth</code><br/>Default: <code>1.0</code><br/>The tick width of y minor ticks</p><p><code>ypankey</code><br/>Default: <code>Makie.Keyboard.y</code><br/>The key for limiting panning to the y direction.</p><p><code>ypanlock</code><br/>Default: <code>false</code><br/>Locks interactive panning in the y direction.</p><p><code>yrectzoom</code><br/>Default: <code>true</code><br/>Controls if rectangle zooming affects the y dimension.</p><p><code>yreversed</code><br/>Default: <code>false</code><br/>Controls if the y axis goes upwards (false) or downwards (true)</p><p><code>yscale</code><br/>Default: <code>identity</code><br/>The y axis scale</p><p><code>ytickalign</code><br/>Default: <code>0.0</code><br/>The alignment of the ytick marks relative to the axis spine (0 = out, 1 = in).</p><p><code>ytickcolor</code><br/>Default: <code>RGBf(0, 0, 0)</code><br/>The color of the ytick marks.</p><p><code>ytickformat</code><br/>Default: <code>Makie.automatic</code><br/>Format for yticks.</p><p><code>yticklabelalign</code><br/>Default: <code>Makie.automatic</code><br/>The horizontal and vertical alignment of the yticklabels.</p><p><code>yticklabelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The color of yticklabels.</p><p><code>yticklabelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The font family of the yticklabels.</p><p><code>yticklabelpad</code><br/>Default: <code>4.0</code><br/>The space between yticks and yticklabels.</p><p><code>yticklabelrotation</code><br/>Default: <code>0.0</code><br/>The counterclockwise rotation of the yticklabels in radians.</p><p><code>yticklabelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The font size of the yticklabels.</p><p><code>yticklabelspace</code><br/>Default: <code>Makie.automatic</code><br/>The space reserved for the yticklabels.</p><p><code>yticklabelsvisible</code><br/>Default: <code>true</code><br/>Controls if the yticklabels are visible.</p><p><code>yticks</code><br/>Default: <code>Makie.automatic</code><br/>The yticks.</p><p><code>yticksize</code><br/>Default: <code>6.0</code><br/>The size of the ytick marks.</p><p><code>yticksvisible</code><br/>Default: <code>true</code><br/>Controls if the ytick marks are visible.</p><p><code>ytickwidth</code><br/>Default: <code>1.0</code><br/>The width of the ytick marks.</p><p><code>ytrimspine</code><br/>Default: <code>false</code><br/>Controls if the y spine is limited to the furthest tick marks or not.</p><p><code>yzoomkey</code><br/>Default: <code>Makie.Keyboard.y</code><br/>The key for limiting zooming to the y direction.</p><p><code>yzoomlock</code><br/>Default: <code>false</code><br/>Locks interactive zooming in the y direction.</p></div></div><div class="docstring"><div class="doc-header" id="Axis3"><a href="#Axis3">Axis3</a></div><div class="doc-content"><p>Axis3 has the following attributes:</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The alignment of the scene in its suggested bounding box.</p><p><code>aspect</code><br/>Default: <code>(1, 1, 2 / 3)</code><br/>Aspects of the 3 axes with each other</p><p><code>azimuth</code><br/>Default: <code>1.275pi</code><br/>The azimuth angle of the camera</p><p><code>backgroundcolor</code><br/>Default: <code>:transparent</code><br/>The background color</p><p><code>elevation</code><br/>Default: <code>pi / 8</code><br/>The elevation angle of the camera</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the scene in its suggested bounding box.</p><p><code>height</code><br/>Default: <code>nothing</code><br/>The height setting of the scene.</p><p><code>limits</code><br/>Default: <code>(nothing, nothing, nothing)</code><br/>The limits that the user has manually set. They are reinstated when calling <code>reset_limits!</code> and are set to nothing by <code>autolimits!</code>. Can be either a tuple (xlow, xhigh, ylow, high, zlow, zhigh) or a tuple (nothing<em>or</em>xlims, nothing<em>or</em>ylims, nothing<em>or</em>zlims). Are set by <code>xlims!</code>, <code>ylims!</code>, <code>zlims!</code> and <code>limits!</code>.</p><p><code>palette</code><br/>Default: <code>if scene !== nothing &amp;&amp; haskey(scene.attributes, :palette)     deepcopy(scene.palette) else     Attributes() end</code><br/>Attributes with one palette per key, for example <code>color = [:red, :green, :blue]</code></p><p><code>perspectiveness</code><br/>Default: <code>0.0</code><br/>A number between 0 and 1, where 0 is orthographic, and 1 full perspective</p><p><code>protrusions</code><br/>Default: <code>30</code><br/>The protrusions on the sides of the axis, how much gap space is reserved for labels etc.</p><p><code>targetlimits</code><br/>Default: <code>Rect3f(Vec3f(0, 0, 0), Vec3f(1, 1, 1))</code><br/>The limits that the axis tries to set given other constraints like aspect. Don't set this directly, use <code>xlims!</code>, <code>ylims!</code> or <code>limits!</code> instead.</p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>title</code><br/>Default: <code>""</code><br/>The axis title string.</p><p><code>titlealign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the title.</p><p><code>titlecolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The color of the title</p><p><code>titlefont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The font family of the title.</p><p><code>titlegap</code><br/>Default: <code>4.0</code><br/>The gap between axis and title.</p><p><code>titlesize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The title's font size.</p><p><code>titlevisible</code><br/>Default: <code>true</code><br/>Controls if the title is visible.</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the scene in its suggested bounding box.</p><p><code>viewmode</code><br/>Default: <code>:fitzoom</code><br/>The view mode which affects the final projection. <code>:fit</code> results in the projection that always fits the limits into the viewport, invariant to rotation. <code>:fitzoom</code> keeps the x/y ratio intact but stretches the view so the corners touch the scene viewport. <code>:stretch</code> scales separately in both x and y direction to fill the viewport, which can distort the <code>aspect</code> that is set.</p><p><code>width</code><br/>Default: <code>nothing</code><br/>The width setting of the scene.</p><p><code>xautolimitmargin</code><br/>Default: <code>(0.05, 0.05)</code><br/>The relative margins added to the autolimits in x direction.</p><p><code>xgridcolor</code><br/>Default: <code>RGBAf(0, 0, 0, 0.12)</code><br/>The x grid color</p><p><code>xgridvisible</code><br/>Default: <code>true</code><br/>Controls if the x grid is visible</p><p><code>xgridwidth</code><br/>Default: <code>1</code><br/>The x grid width</p><p><code>xlabel</code><br/>Default: <code>"x"</code><br/>The x label</p><p><code>xlabelalign</code><br/>Default: <code>Makie.automatic</code><br/>The x label align</p><p><code>xlabelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The x label color</p><p><code>xlabelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The x label font</p><p><code>xlabeloffset</code><br/>Default: <code>40</code><br/>The x label offset</p><p><code>xlabelrotation</code><br/>Default: <code>Makie.automatic</code><br/>The x label rotation</p><p><code>xlabelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The x label size</p><p><code>xlabelvisible</code><br/>Default: <code>true</code><br/>Controls if the x label is visible</p><p><code>xspinecolor_1</code><br/>Default: <code>:black</code><br/>The color of x spine 1 where the ticks are displayed</p><p><code>xspinecolor_2</code><br/>Default: <code>:black</code><br/>The color of x spine 2 towards the center</p><p><code>xspinecolor_3</code><br/>Default: <code>:black</code><br/>The color of x spine 3 opposite of the ticks</p><p><code>xspinesvisible</code><br/>Default: <code>true</code><br/>Controls if the x spine is visible</p><p><code>xspinewidth</code><br/>Default: <code>1</code><br/>The x spine width</p><p><code>xtickcolor</code><br/>Default: <code>:black</code><br/>The x tick color</p><p><code>xtickformat</code><br/>Default: <code>Makie.automatic</code><br/>The x tick format</p><p><code>xticklabelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The x ticklabel color</p><p><code>xticklabelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The x ticklabel font</p><p><code>xticklabelpad</code><br/>Default: <code>5</code><br/>The x ticklabel pad</p><p><code>xticklabelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The x ticklabel size</p><p><code>xticklabelsvisible</code><br/>Default: <code>true</code><br/>Controls if the x ticklabels are visible</p><p><code>xticks</code><br/>Default: <code>WilkinsonTicks(5; k_min = 3)</code><br/>The x ticks</p><p><code>xticksvisible</code><br/>Default: <code>true</code><br/>Controls if the x ticks are visible</p><p><code>xtickwidth</code><br/>Default: <code>1</code><br/>The x tick width</p><p><code>xypanelcolor</code><br/>Default: <code>:transparent</code><br/>The color of the xy panel</p><p><code>xypanelvisible</code><br/>Default: <code>true</code><br/>Controls if the xy panel is visible</p><p><code>xzpanelcolor</code><br/>Default: <code>:transparent</code><br/>The color of the xz panel</p><p><code>xzpanelvisible</code><br/>Default: <code>true</code><br/>Controls if the xz panel is visible</p><p><code>yautolimitmargin</code><br/>Default: <code>(0.05, 0.05)</code><br/>The relative margins added to the autolimits in y direction.</p><p><code>ygridcolor</code><br/>Default: <code>RGBAf(0, 0, 0, 0.12)</code><br/>The y grid color</p><p><code>ygridvisible</code><br/>Default: <code>true</code><br/>Controls if the y grid is visible</p><p><code>ygridwidth</code><br/>Default: <code>1</code><br/>The y grid width</p><p><code>ylabel</code><br/>Default: <code>"y"</code><br/>The y label</p><p><code>ylabelalign</code><br/>Default: <code>Makie.automatic</code><br/>The y label align</p><p><code>ylabelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The y label color</p><p><code>ylabelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The y label font</p><p><code>ylabeloffset</code><br/>Default: <code>40</code><br/>The y label offset</p><p><code>ylabelrotation</code><br/>Default: <code>Makie.automatic</code><br/>The y label rotation</p><p><code>ylabelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The y label size</p><p><code>ylabelvisible</code><br/>Default: <code>true</code><br/>Controls if the y label is visible</p><p><code>yspinecolor_1</code><br/>Default: <code>:black</code><br/>The color of y spine 1 where the ticks are displayed</p><p><code>yspinecolor_2</code><br/>Default: <code>:black</code><br/>The color of y spine 2 towards the center</p><p><code>yspinecolor_3</code><br/>Default: <code>:black</code><br/>The color of y spine 3 opposite of the ticks</p><p><code>yspinesvisible</code><br/>Default: <code>true</code><br/>Controls if the y spine is visible</p><p><code>yspinewidth</code><br/>Default: <code>1</code><br/>The y spine width</p><p><code>ytickcolor</code><br/>Default: <code>:black</code><br/>The y tick color</p><p><code>ytickformat</code><br/>Default: <code>Makie.automatic</code><br/>The y tick format</p><p><code>yticklabelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The y ticklabel color</p><p><code>yticklabelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The y ticklabel font</p><p><code>yticklabelpad</code><br/>Default: <code>5</code><br/>The y ticklabel pad</p><p><code>yticklabelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The y ticklabel size</p><p><code>yticklabelsvisible</code><br/>Default: <code>true</code><br/>Controls if the y ticklabels are visible</p><p><code>yticks</code><br/>Default: <code>WilkinsonTicks(5; k_min = 3)</code><br/>The y ticks</p><p><code>yticksvisible</code><br/>Default: <code>true</code><br/>Controls if the y ticks are visible</p><p><code>ytickwidth</code><br/>Default: <code>1</code><br/>The y tick width</p><p><code>yzpanelcolor</code><br/>Default: <code>:transparent</code><br/>The color of the yz panel</p><p><code>yzpanelvisible</code><br/>Default: <code>true</code><br/>Controls if the yz panel is visible</p><p><code>zautolimitmargin</code><br/>Default: <code>(0.05, 0.05)</code><br/>The relative margins added to the autolimits in z direction.</p><p><code>zgridcolor</code><br/>Default: <code>RGBAf(0, 0, 0, 0.12)</code><br/>The z grid color</p><p><code>zgridvisible</code><br/>Default: <code>true</code><br/>Controls if the z grid is visible</p><p><code>zgridwidth</code><br/>Default: <code>1</code><br/>The z grid width</p><p><code>zlabel</code><br/>Default: <code>"z"</code><br/>The z label</p><p><code>zlabelalign</code><br/>Default: <code>Makie.automatic</code><br/>The z label align</p><p><code>zlabelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The z label color</p><p><code>zlabelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The z label font</p><p><code>zlabeloffset</code><br/>Default: <code>50</code><br/>The z label offset</p><p><code>zlabelrotation</code><br/>Default: <code>Makie.automatic</code><br/>The z label rotation</p><p><code>zlabelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The z label size</p><p><code>zlabelvisible</code><br/>Default: <code>true</code><br/>Controls if the z label is visible</p><p><code>zspinecolor_1</code><br/>Default: <code>:black</code><br/>The color of z spine 1 where the ticks are displayed</p><p><code>zspinecolor_2</code><br/>Default: <code>:black</code><br/>The color of z spine 2 towards the center</p><p><code>zspinecolor_3</code><br/>Default: <code>:black</code><br/>The color of z spine 3 opposite of the ticks</p><p><code>zspinesvisible</code><br/>Default: <code>true</code><br/>Controls if the z spine is visible</p><p><code>zspinewidth</code><br/>Default: <code>1</code><br/>The z spine width</p><p><code>ztickcolor</code><br/>Default: <code>:black</code><br/>The z tick color</p><p><code>ztickformat</code><br/>Default: <code>Makie.automatic</code><br/>The z tick format</p><p><code>zticklabelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The z ticklabel color</p><p><code>zticklabelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The z ticklabel font</p><p><code>zticklabelpad</code><br/>Default: <code>10</code><br/>The z ticklabel pad</p><p><code>zticklabelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The z ticklabel size</p><p><code>zticklabelsvisible</code><br/>Default: <code>true</code><br/>Controls if the z ticklabels are visible</p><p><code>zticks</code><br/>Default: <code>WilkinsonTicks(5; k_min = 3)</code><br/>The z ticks</p><p><code>zticksvisible</code><br/>Default: <code>true</code><br/>Controls if the z ticks are visible</p><p><code>ztickwidth</code><br/>Default: <code>1</code><br/>The z tick width</p></div></div><div class="docstring"><div class="doc-header" id="Axis3D"><a href="#Axis3D">Axis3D</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Axis3D</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="AxisAspect"><a href="#AxisAspect">AxisAspect</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.MakieLayout.AxisAspect &lt;: Any</code></pre><h1>Fields</h1><pre><code>aspect :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="BBox"><a href="#BBox">BBox</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.BBox</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "BBox":
[1] BBox(left::Number, right::Number, bottom::Number, top::Number) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/geometry_integration.jl:10</code></pre></div></div><div class="docstring"><div class="doc-header" id="Band"><a href="#Band">Band</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Band</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="BarPlot"><a href="#BarPlot">BarPlot</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.BarPlot</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Billboard"><a href="#Billboard">Billboard</a></div><div class="doc-content"><pre><code>Billboard([angle::Real])
Billboard([angles::Vector{&lt;: Real}])</code></pre><p>Billboard attribute to always have a primitive face the camera. Can be used for rotation.</p></div></div><div class="docstring"><div class="doc-header" id="Bottom"><a href="#Bottom">Bottom</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.Bottom &lt;: GridLayoutBase.Side</code></pre><h1>Supertype Hierarchy</h1><pre><code>GridLayoutBase.Bottom &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="BottomLeft"><a href="#BottomLeft">BottomLeft</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.BottomLeft &lt;: GridLayoutBase.Side</code></pre><h1>Supertype Hierarchy</h1><pre><code>GridLayoutBase.BottomLeft &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="BottomRight"><a href="#BottomRight">BottomRight</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.BottomRight &lt;: GridLayoutBase.Side</code></pre><h1>Supertype Hierarchy</h1><pre><code>GridLayoutBase.BottomRight &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Box"><a href="#Box">Box</a></div><div class="doc-content"><p>Box has the following attributes:</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The align mode of the rectangle in its parent GridLayout.</p><p><code>color</code><br/>Default: <code>RGBf(0.9, 0.9, 0.9)</code><br/>The color of the rectangle.</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the rectangle in its suggested boundingbox</p><p><code>height</code><br/>Default: <code>nothing</code><br/>The height setting of the rectangle.</p><p><code>padding</code><br/>Default: <code>(0.0f0, 0.0f0, 0.0f0, 0.0f0)</code><br/>The extra space added to the sides of the rectangle boundingbox.</p><p><code>strokecolor</code><br/>Default: <code>RGBf(0, 0, 0)</code><br/>The color of the border.</p><p><code>strokevisible</code><br/>Default: <code>true</code><br/>Controls if the border of the rectangle is visible.</p><p><code>strokewidth</code><br/>Default: <code>1.0</code><br/>The line width of the rectangle's border.</p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the rectangle in its suggested boundingbox</p><p><code>visible</code><br/>Default: <code>true</code><br/>Controls if the rectangle is visible.</p><p><code>width</code><br/>Default: <code>nothing</code><br/>The width setting of the rectangle.</p></div></div><div class="docstring"><div class="doc-header" id="BoxPlot"><a href="#BoxPlot">BoxPlot</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.BoxPlot</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Button"><a href="#Button">Button</a></div><div class="doc-content"><p>Button has the following attributes:</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The align mode of the button in its parent GridLayout.</p><p><code>buttoncolor</code><br/>Default: <code>RGBf(0.94, 0.94, 0.94)</code><br/>The color of the button.</p><p><code>buttoncolor_active</code><br/>Default: <code>COLOR_ACCENT[]</code><br/>The color of the button when the mouse clicks the button.</p><p><code>buttoncolor_hover</code><br/>Default: <code>COLOR_ACCENT_DIMMED[]</code><br/>The color of the button when the mouse hovers over the button.</p><p><code>clicks</code><br/>Default: <code>0</code><br/>The number of clicks that have been registered by the button.</p><p><code>cornerradius</code><br/>Default: <code>4</code><br/>The radius of the rounded corners of the button.</p><p><code>cornersegments</code><br/>Default: <code>10</code><br/>The number of poly segments used for each rounded corner.</p><p><code>font</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The font family of the button label.</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the button in its suggested boundingbox</p><p><code>height</code><br/>Default: <code>Auto()</code><br/>The height setting of the button.</p><p><code>label</code><br/>Default: <code>"Button"</code><br/>The text of the button label.</p><p><code>labelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The color of the label.</p><p><code>labelcolor_active</code><br/>Default: <code>:white</code><br/>The color of the label when the mouse clicks the button.</p><p><code>labelcolor_hover</code><br/>Default: <code>:black</code><br/>The color of the label when the mouse hovers over the button.</p><p><code>padding</code><br/>Default: <code>(10.0f0, 10.0f0, 10.0f0, 10.0f0)</code><br/>The extra space added to the sides of the button label's boundingbox.</p><p><code>strokecolor</code><br/>Default: <code>:transparent</code><br/>The color of the button border.</p><p><code>strokewidth</code><br/>Default: <code>2.0</code><br/>The line width of the button border.</p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>textsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The font size of the button label.</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the button in its suggested boundingbox</p><p><code>width</code><br/>Default: <code>Auto()</code><br/>The width setting of the button.</p></div></div><div class="docstring"><div class="doc-header" id="Camera"><a href="#Camera">Camera</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>mutable struct Makie.Camera &lt;: Any</code></pre><h1>Fields</h1><pre><code>pixel_space    :: Observables.Observable{StaticArrays.SMatrix{4, 4, Float32, 16}}
view           :: Observables.Observable{StaticArrays.SMatrix{4, 4, Float32, 16}}
projection     :: Observables.Observable{StaticArrays.SMatrix{4, 4, Float32, 16}}
projectionview :: Observables.Observable{StaticArrays.SMatrix{4, 4, Float32, 16}}
resolution     :: Observables.Observable{GeometryBasics.Vec{2, Float32}}
eyeposition    :: Observables.Observable{GeometryBasics.Vec{3, Float32}}
steering_nodes :: Vector{Observables.ObserverFunction}</code></pre></div></div><div class="docstring"><div class="doc-header" id="Camera2D"><a href="#Camera2D">Camera2D</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.Camera2D &lt;: Makie.AbstractCamera</code></pre><h1>Fields</h1><pre><code>area          :: Observables.Observable{GeometryBasics.HyperRectangle{2, Float32}}
zoomspeed     :: Observables.Observable{Float32}
zoombutton    :: Observables.Observable{Union{Nothing, Makie.Keyboard.Button, Makie.Mouse.Button}}
panbutton     :: Observables.Observable{Union{Nothing, Makie.Keyboard.Button, Makie.Mouse.Button, Vector{Union{Nothing, Makie.Keyboard.Button, Makie.Mouse.Button}}}}
padding       :: Observables.Observable{Float32}
last_area     :: Observables.Observable{GeometryBasics.Vec2{Int64}}
update_limits :: Observables.Observable{Bool}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Makie.Camera2D &lt;: Makie.AbstractCamera &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Camera3D"><a href="#Camera3D">Camera3D</a></div><div class="doc-content"><pre><code>Camera3D(scene[; attributes...])</code></pre><p>Creates a 3d camera with a lot of controls.</p><p>The 3D camera is (or can be) unrestricted in terms of rotations and translations. Both <code>cam3d!(scene)</code> and <code>cam3d_cad!(scene)</code> create this camera type. Unlike the 2D camera, settings and controls are stored in the <code>cam.attributes</code> field rather than in the struct directly, but can still be passed as keyword arguments. The general camera settings include</p><ul><li><p><code>fov = 45f0</code> sets the "neutral" field of view, i.e. the fov corresponding to no zoom. This is irrelevant if the camera uses an orthographic projection.</p></li><li><p><code>near = automatic</code> sets the value of the near clip. By default this will be chosen based on the scenes bounding box. The final value is in <code>cam.near</code>.</p></li><li><p><code>far = automatic</code> sets the value of the far clip. By default this will be chosen based on the scenes bounding box. The final value is in <code>cam.far</code>.</p></li><li><p><code>rotation_center = :lookat</code> sets the default center for camera rotations. Currently allows <code>:lookat</code> or <code>:eyeposition</code>.</p></li><li><p><code>projectiontype = Perspective</code> sets the type of the projection. Can be <code>Orthographic</code> or <code>Perspective</code>.</p></li><li><p><code>fixed_axis = false</code>: If true panning uses the (world/plot) z-axis instead of the camera up direction.</p></li><li><p><code>zoom_shift_lookat = true</code>: If true attempts to keep data under the cursor in view when zooming.</p></li><li><p><code>cad = false</code>: If true rotates the view around <code>lookat</code> when zooming off-center.</p></li></ul><p>The camera view follows from the position of the camera <code>eyeposition</code>, the point which the camera focuses <code>lookat</code> and the up direction of the camera <code>upvector</code>. These can be accessed as <code>cam.eyeposition</code> etc and adjusted via <code>update_cam!(scene, cameracontrols(scene), eyeposition, lookat[, upvector = Vec3f(0, 0, 1)])</code>. They can also be passed as keyword arguments when the camera is constructed.</p><p>The camera can be controlled by keyboard and mouse. The keyboard has the following available attributes</p><ul><li><p><code>up_key   = Keyboard.r</code> sets the key for translations towards the top of the screen.</p></li><li><p><code>down_key = Keyboard.f</code> sets the key for translations towards the bottom of the screen.</p></li><li><p><code>left_key  = Keyboard.a</code> sets the key for translations towards the left of the screen.</p></li><li><p><code>right_key = Keyboard.d</code> sets the key for translations towards the right of the screen.</p></li><li><p><code>forward_key  = Keyboard.w</code> sets the key for translations into the screen.</p></li><li><p><code>backward_key = Keyboard.s</code> sets the key for translations out of the screen.</p></li><li><p><code>zoom_in_key   = Keyboard.u</code> sets the key for zooming into the scene (enlarge, via fov).</p></li><li><p><code>zoom_out_key  = Keyboard.o</code> sets the key for zooming out of the scene (shrink, via fov).</p></li><li><p><code>stretch_view_key  = Keyboard.page_up</code> sets the key for moving <code>eyepostion</code> away from <code>lookat</code>.</p></li><li><p><code>contract_view_key = Keyboard.page_down</code> sets the key for moving <code>eyeposition</code> towards <code>lookat</code>.</p></li><li><p><code>pan_left_key  = Keyboard.j</code> sets the key for rotations around the screens vertical axis.</p></li><li><p><code>pan_right_key = Keyboard.l</code> sets the key for rotations around the screens vertical axis.</p></li><li><p><code>tilt_up_key   = Keyboard.i</code> sets the key for rotations around the screens horizontal axis.</p></li><li><p><code>tilt_down_key = Keyboard.k</code> sets the key for rotations around the screens horizontal axis.</p></li><li><p><code>roll_clockwise_key        = Keyboard.e</code> sets the key for rotations of the screen.</p></li><li><p><code>roll_counterclockwise_key = Keyboard.q</code> sets the key for rotations of the screen.</p></li><li><p><code>keyboard_rotationspeed = 1f0</code> sets the speed of keyboard based rotations.</p></li><li><p><code>keyboard_translationspeed = 0.5f0</code> sets the speed of keyboard based translations.</p></li><li><p><code>keyboard_zoomspeed = 1f0</code> sets the speed of keyboard based zooms.</p></li><li><p><code>update_rate = 1/30</code> sets the rate at which keyboard based camera updates are evaluated.</p></li></ul><p>and mouse interactions are controlled by</p><ul><li><p><code>translation_button   = Mouse.right</code> sets the mouse button for drag-translations. (up/down/left/right)</p></li><li><p><code>translation_modifier = nothing</code> sets additional keys that need to be held for mouse translations.</p></li><li><p><code>rotation_button    = Mouse.left</code> sets the mouse button for drag-rotations. (pan, tilt)</p></li><li><p><code>rotation_modifier  = nothing</code> sets additional keys that need to be held for mouse rotations.</p></li><li><p><code>mouse_rotationspeed = 1f0</code> sets the speed of mouse rotations.</p></li><li><p><code>mouse_translationspeed = 0.5f0</code> sets the speed of mouse translations.</p></li><li><p><code>mouse_zoomspeed = 1f0</code> sets the speed of mouse zooming (mousewheel).</p></li><li><p><code>circular_rotation = (true, true, true)</code> enables circular rotations for (fixed x, fixed y, fixed z) rotation axis. (This means drawing a circle with your mouse around the center of the scene will result in a continuous rotation.)</p></li></ul><p>There are also a few generally applicable controls:</p><ul><li><p><code>fix_x_key = Keyboard.x</code> sets the key for fixing translations and rotations to the (world/plot) x-axis.</p></li><li><p><code>fix_y_key = Keyboard.y</code> sets the key for fixing translations and rotations to the (world/plot) y-axis.</p></li><li><p><code>fix_z_key = Keyboard.z</code> sets the key for fixing translations and rotations to the (world/plot) z-axis.</p></li><li><p><code>reset = Keyboard.home</code> sets the key for fully resetting the camera. This equivalent to setting <code>lookat = Vec3f(0)</code>, <code>upvector = Vec3f(0, 0, 1)</code>, <code>eyeposition = Vec3f(3)</code> and then calling <code>center!(scene)</code>.</p></li></ul><p>You can also make adjustments to the camera position, rotation and zoom by calling relevant functions:</p><ul><li><p><code>translate_cam!(scene, v)</code> will translate the camera by the given world/plot space vector <code>v</code>.</p></li><li><p><code>rotate_cam!(scene, angles)</code> will rotate the camera around its axes with the corresponding angles. The first angle will rotate around the cameras "right" that is the screens horizontal axis, the second around the up vector/vertical axis or <code>Vec3f(0, 0, +-1)</code> if <code>fixed_axis = true</code>, and the third will rotate around the view direction i.e. the axis out of the screen. The rotation respects the the current <code>rotation_center</code> of the camera.</p></li><li><p><code>zoom!(scene, zoom_step)</code> will change the zoom level of the scene without translating or rotating the scene. <code>zoom_step</code> applies multiplicatively to <code>cam.zoom_mult</code> which is used as a multiplier to the fov (perspective projection) or width and height (orthographic projection).</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Circle"><a href="#Circle">Circle</a></div><div class="doc-content"><pre><code>Circle{T}</code></pre><p>An alias for a HyperSphere of dimension 2. (i.e. <code>HyperSphere{2, T}</code>)</p></div></div><div class="docstring"><div class="doc-header" id="Colorbar"><a href="#Colorbar">Colorbar</a></div><div class="doc-content"><pre><code>Colorbar(parent; kwargs...)
Colorbar(parent, plotobject; kwargs...)
Colorbar(parent, heatmap::Heatmap; kwargs...)
Colorbar(parent, contourf::Contourf; kwargs...)</code></pre><p>Add a Colorbar to <code>parent</code>. If you pass a <code>plotobject</code>, a <code>heatmap</code> or <code>contourf</code>, the Colorbar is set up automatically such that it tracks these objects' relevant attributes like <code>colormap</code>, <code>colorrange</code>, <code>highclip</code> and <code>lowclip</code>. If you want to adjust these attributes afterwards, change them in the plot object, otherwise the Colorbar and the plot object will go out of sync.</p><p>Colorbar has the following attributes:</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The align mode of the colorbar in its parent GridLayout.</p><p><code>bottomspinecolor</code><br/>Default: <code>RGBf(0, 0, 0)</code><br/>The color of the bottom spine.</p><p><code>bottomspinevisible</code><br/>Default: <code>true</code><br/>Controls if the bottom spine is visible.</p><p><code>colormap</code><br/>Default: <code>lift_parent_attribute(scene, :colormap, :viridis)</code><br/>The colormap that the colorbar uses.</p><p><code>colorrange</code><br/>Default: <code>nothing</code><br/>The range of values depicted in the colorbar.</p><p><code>flip_vertical_label</code><br/>Default: <code>false</code><br/>Flips the colorbar label if the axis is vertical.</p><p><code>flipaxis</code><br/>Default: <code>true</code><br/>Flips the axis to the right if vertical and to the top if horizontal.</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the colorbar in its suggested bounding box.</p><p><code>height</code><br/>Default: <code>Makie.automatic</code><br/>The height setting of the colorbar.</p><p><code>highclip</code><br/>Default: <code>nothing</code><br/>The color of the high clip triangle.</p><p><code>label</code><br/>Default: <code>""</code><br/>The color bar label string.</p><p><code>labelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The label color.</p><p><code>labelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The label font family.</p><p><code>labelpadding</code><br/>Default: <code>5.0</code><br/>The gap between the label and the ticks.</p><p><code>labelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The label font size.</p><p><code>labelvisible</code><br/>Default: <code>true</code><br/>Controls if the label is visible.</p><p><code>leftspinecolor</code><br/>Default: <code>RGBf(0, 0, 0)</code><br/>The color of the left spine.</p><p><code>leftspinevisible</code><br/>Default: <code>true</code><br/>Controls if the left spine is visible.</p><p><code>limits</code><br/>Default: <code>nothing</code><br/>The range of values depicted in the colorbar.</p><p><code>lowclip</code><br/>Default: <code>nothing</code><br/>The color of the low clip triangle.</p><p><code>minortickalign</code><br/>Default: <code>0.0</code><br/>The alignment of minor ticks on the axis spine</p><p><code>minortickcolor</code><br/>Default: <code>:black</code><br/>The tick color of minor ticks</p><p><code>minorticks</code><br/>Default: <code>IntervalsBetween(5)</code><br/>The tick locator for the minor ticks</p><p><code>minorticksize</code><br/>Default: <code>4.0</code><br/>The tick size of minor ticks</p><p><code>minorticksvisible</code><br/>Default: <code>false</code><br/>Controls if minor ticks are visible</p><p><code>minortickwidth</code><br/>Default: <code>1.0</code><br/>The tick width of minor ticks</p><p><code>nsteps</code><br/>Default: <code>100</code><br/>The number of steps in the heatmap underlying the colorbar gradient.</p><p><code>rightspinecolor</code><br/>Default: <code>RGBf(0, 0, 0)</code><br/>The color of the right spine.</p><p><code>rightspinevisible</code><br/>Default: <code>true</code><br/>Controls if the right spine is visible.</p><p><code>scale</code><br/>Default: <code>identity</code><br/>The axis scale</p><p><code>size</code><br/>Default: <code>16</code><br/>The width or height of the colorbar, depending on if it's vertical or horizontal, unless overridden by <code>width</code> / <code>height</code></p><p><code>spinewidth</code><br/>Default: <code>1.0</code><br/>The line width of the spines.</p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>tickalign</code><br/>Default: <code>0.0</code><br/>The alignment of the tick marks relative to the axis spine (0 = out, 1 = in).</p><p><code>tickcolor</code><br/>Default: <code>RGBf(0, 0, 0)</code><br/>The color of the tick marks.</p><p><code>tickformat</code><br/>Default: <code>Makie.automatic</code><br/>Format for ticks.</p><p><code>ticklabelalign</code><br/>Default: <code>Makie.automatic</code><br/>The horizontal and vertical alignment of the tick labels.</p><p><code>ticklabelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The color of the tick labels.</p><p><code>ticklabelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The font family of the tick labels.</p><p><code>ticklabelpad</code><br/>Default: <code>3.0</code><br/>The gap between tick labels and tick marks.</p><p><code>ticklabelrotation</code><br/>Default: <code>0.0</code><br/>The rotation of the ticklabels</p><p><code>ticklabelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The font size of the tick labels.</p><p><code>ticklabelspace</code><br/>Default: <code>Makie.automatic</code><br/>The space reserved for the tick labels.</p><p><code>ticklabelsvisible</code><br/>Default: <code>true</code><br/>Controls if the tick labels are visible.</p><p><code>ticks</code><br/>Default: <code>Makie.automatic</code><br/>The ticks.</p><p><code>ticksize</code><br/>Default: <code>6.0</code><br/>The size of the tick marks.</p><p><code>ticksvisible</code><br/>Default: <code>true</code><br/>Controls if the tick marks are visible.</p><p><code>tickwidth</code><br/>Default: <code>1.0</code><br/>The line width of the tick marks.</p><p><code>topspinecolor</code><br/>Default: <code>RGBf(0, 0, 0)</code><br/>The color of the top spine.</p><p><code>topspinevisible</code><br/>Default: <code>true</code><br/>Controls if the top spine is visible.</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the colorbar in its suggested bounding box.</p><p><code>vertical</code><br/>Default: <code>true</code><br/>Controls if the colorbar is oriented vertically.</p><p><code>width</code><br/>Default: <code>Makie.automatic</code><br/>The width setting of the colorbar. Use <code>size</code> to set width or height relative to colorbar orientation instead.</p></div></div><div class="docstring"><div class="doc-header" id="Combined"><a href="#Combined">Combined</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.Combined</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Consume"><a href="#Consume">Consume</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.Consume &lt;: Any</code></pre><h1>Fields</h1><pre><code>x :: Bool</code></pre></div></div><div class="docstring"><div class="doc-header" id="ContinuousSurface"><a href="#ContinuousSurface">ContinuousSurface</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct MakieCore.ContinuousSurface &lt;: MakieCore.SurfaceLike</code></pre><h1>Supertype Hierarchy</h1><pre><code>MakieCore.ContinuousSurface &lt;: MakieCore.SurfaceLike &lt;: MakieCore.ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Contour"><a href="#Contour">Contour</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Contour</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Contour3d"><a href="#Contour3d">Contour3d</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Contour3d</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Contourf"><a href="#Contourf">Contourf</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Contourf</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="ConversionTrait"><a href="#ConversionTrait">ConversionTrait</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type MakieCore.ConversionTrait &lt;: Any</code></pre><h1>Subtypes</h1><pre><code>Makie.SampleBased
MakieCore.NoConversion
MakieCore.PointBased
MakieCore.SurfaceLike</code></pre></div></div><div class="docstring"><div class="doc-header" id="CrossBar"><a href="#CrossBar">CrossBar</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.CrossBar</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Cycle"><a href="#Cycle">Cycle</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.MakieLayout.Cycle &lt;: Any</code></pre><h1>Fields</h1><pre><code>cycle  :: Vector{Pair{Vector{Symbol}, Symbol}}
covary :: Bool</code></pre></div></div><div class="docstring"><div class="doc-header" id="DataAspect"><a href="#DataAspect">DataAspect</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.MakieLayout.DataAspect &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="DataInspector"><a href="#DataInspector">DataInspector</a></div><div class="doc-content"><pre><code>DataInspector(figure; kwargs...)</code></pre><p>Creates a data inspector which will show relevant information in a tooltip when you hover over a plot. If you wish to exclude a plot you may set <code>plot.inspectable[] = false</code>.</p><h3>Keyword Arguments:</h3><ul><li><p><code>range = 10</code>: Controls the snapping range for selecting an element of a plot.</p></li><li><p><code>enabled = true</code>: Disables inspection of plots when set to false. Can also be   adjusted with <code>enable!(inspector)</code> and <code>disable!(inspector)</code>.</p></li><li><p><code>text_padding = Vec4f(5, 5, 3, 3)</code>: Padding for the box drawn around the   tooltip text. (left, right, bottom, top)</p></li><li><p><code>text_align = (:left, :bottom)</code>: Alignment of text within the tooltip. This   does not affect the alignment of the tooltip relative to the cursor.</p></li><li><p><code>textcolor = :black</code>: Tooltip text color.</p></li><li><p><code>textsize = 20</code>: Tooltip text size.</p></li><li><p><code>font = "Dejavu Sans"</code>: Tooltip font.</p></li><li><p><code>background_color = :white</code>: Background color of the tooltip.</p></li><li><p><code>outline_color = :grey</code>: Outline color of the tooltip.</p></li><li><p><code>outline_linestyle = nothing</code>: Linestyle of the tooltip outline.</p></li><li><p><code>outline_linewidth = 2</code>: Linewidth of the tooltip outline.</p></li><li><p><code>indicator_color = :red</code>: Color of the selection indicator.</p></li><li><p><code>indicator_linewidth = 2</code>: Linewidth of the selection indicator.</p></li><li><p><code>indicator_linestyle = nothing</code>: Linestyle of the selection indicator</p></li><li><p><code>tooltip_align = (:center, :top)</code>: Default position of the tooltip relative to   the cursor or current selection. The real align may adjust to keep the   tooltip in view.</p></li><li><p><code>tooltip_offset = Vec2f(20)</code>: Offset from the indicator to the tooltip.</p></li><li><p><code>depth = 9e3</code>: Depth value of the tooltip. This should be high so that the   tooltip is always in front.</p></li><li><p><code>priority = 100</code>: The priority of creating a tooltip on a mouse movement or   scrolling event.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Density"><a href="#Density">Density</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Density</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="DiscreteSurface"><a href="#DiscreteSurface">DiscreteSurface</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct MakieCore.DiscreteSurface &lt;: MakieCore.SurfaceLike</code></pre><h1>Supertype Hierarchy</h1><pre><code>MakieCore.DiscreteSurface &lt;: MakieCore.SurfaceLike &lt;: MakieCore.ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="EmptyCamera"><a href="#EmptyCamera">EmptyCamera</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.EmptyCamera &lt;: Makie.AbstractCamera</code></pre><h1>Supertype Hierarchy</h1><pre><code>Makie.EmptyCamera &lt;: Makie.AbstractCamera &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Errorbars"><a href="#Errorbars">Errorbars</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Errorbars</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Events"><a href="#Events">Events</a></div><div class="doc-content"><p>This struct provides accessible <code>PriorityObservable</code>s to monitor the events associated with a Scene.</p><p>Functions that act on a <code>PriorityObservable</code> must return <code>Consume()</code> if the function consumes an event. When an event is consumed it does not trigger other observer functions. The order in which functions are exectued can be controlled via the <code>priority</code> keyword (default 0) in <code>on</code>.</p><p>Example:</p><pre><code>on(events(scene).mousebutton, priority = Int8(20)) do event
    if is_correct_event(event)
        do_something()
        return Consume()
    end
    return
end</code></pre><h2>Fields</h2><ul><li><p><code>window_area::Makie.PriorityObservable{GeometryBasics.HyperRectangle{2, Int64}}</code></p><p>The area of the window in pixels, as a <code>Rect2</code>.</p></li></ul><ul><li><p><code>window_dpi::Makie.PriorityObservable{Float64}</code></p><p>The DPI resolution of the window, as a <code>Float64</code>.</p></li></ul><ul><li><p><code>window_open::Makie.PriorityObservable{Bool}</code></p><p>The state of the window (open =&gt; true, closed =&gt; false).</p></li></ul><ul><li><p><code>mousebutton::Makie.PriorityObservable{Makie.MouseButtonEvent}</code></p><p>Most recently triggered <code>MouseButtonEvent</code>. Contains the relevant <code>event.button</code> and <code>event.action</code> (press/release)</p><p>See also <a href="@ref"><code>ispressed</code></a>.</p></li></ul><ul><li><p><code>mousebuttonstate::Set{Makie.Mouse.Button}</code></p><p>A Set of all currently pressed mousebuttons.</p></li></ul><ul><li><p><code>mouseposition::Makie.PriorityObservable{Tuple{Float64, Float64}}</code></p><p>The position of the mouse as a <code>NTuple{2, Float64}</code>. Updates once per event poll/frame.</p></li></ul><ul><li><p><code>scroll::Makie.PriorityObservable{Tuple{Float64, Float64}}</code></p><p>The direction of scroll</p></li></ul><ul><li><p><code>keyboardbutton::Makie.PriorityObservable{Makie.KeyEvent}</code></p><p>Most recently triggered <code>KeyEvent</code>. Contains the relevant <code>event.key</code> and <code>event.action</code> (press/repeat/release)</p><p>See also <a href="@ref"><code>ispressed</code></a>.</p></li></ul><ul><li><p><code>keyboardstate::Set{Makie.Keyboard.Button}</code></p><p>Contains all currently pressed keys.</p></li></ul><ul><li><p><code>unicode_input::Makie.PriorityObservable{Char}</code></p><p>Contains the last typed character.</p></li></ul><ul><li><p><code>dropped_files::Makie.PriorityObservable{Vector{String}}</code></p><p>Contains a list of filepaths to files dragged into the scene.</p></li></ul><ul><li><p><code>hasfocus::Makie.PriorityObservable{Bool}</code></p><p>Whether the Scene window is in focus or not.</p></li></ul><ul><li><p><code>entered_window::Makie.PriorityObservable{Bool}</code></p><p>Whether the mouse is inside the window or not.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="FRect"><a href="#FRect">FRect</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.FRect</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="FRect2D"><a href="#FRect2D">FRect2D</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="FRect3D"><a href="#FRect3D">FRect3D</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Figure"><a href="#Figure">Figure</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.Figure &lt;: Any</code></pre><h1>Fields</h1><pre><code>scene        :: Makie.Scene
layout       :: GridLayoutBase.GridLayout
content      :: Vector{T} where T
attributes   :: MakieCore.Attributes
current_axis :: Ref{Any}</code></pre></div></div><div class="docstring"><div class="doc-header" id="Fixed"><a href="#Fixed">Fixed</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.Fixed &lt;: GridLayoutBase.GapSize</code></pre><h1>Fields</h1><pre><code>x :: Float64</code></pre><h1>Supertype Hierarchy</h1><pre><code>GridLayoutBase.Fixed &lt;: GridLayoutBase.GapSize &lt;: GridLayoutBase.ContentSize &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="GLNormalUVMesh"><a href="#GLNormalUVMesh">GLNormalUVMesh</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.GLNormalUVMesh</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="GridLayout"><a href="#GridLayout">GridLayout</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>mutable struct GridLayoutBase.GridLayout &lt;: Any</code></pre><h1>Fields</h1><pre><code>parent              :: Any
content             :: Vector{GridLayoutBase.GridContent}
nrows               :: Int64
ncols               :: Int64
rowsizes            :: Vector{GridLayoutBase.ContentSize}
colsizes            :: Vector{GridLayoutBase.ContentSize}
addedrowgaps        :: Vector{GridLayoutBase.GapSize}
addedcolgaps        :: Vector{GridLayoutBase.GapSize}
alignmode           :: Observables.Observable{GridLayoutBase.AlignMode}
equalprotrusiongaps :: Tuple{Bool, Bool}
needs_update        :: Observables.Observable{Bool}
block_updates       :: Bool
layoutobservables   :: GridLayoutBase.LayoutObservables
width               :: Observables.Observable
height              :: Observables.Observable
tellwidth           :: Observables.Observable
tellheight          :: Observables.Observable
halign              :: Observables.Observable
valign              :: Observables.Observable
default_rowgap      :: GridLayoutBase.GapSize
default_colgap      :: GridLayoutBase.GapSize
_update_func_handle :: Union{Nothing, Function}</code></pre></div></div><div class="docstring"><div class="doc-header" id="GridLayoutSpec"><a href="#GridLayoutSpec">GridLayoutSpec</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.GridLayoutSpec &lt;: Any</code></pre><h1>Fields</h1><pre><code>content :: Vector{Pair{Tuple{Union{Colon, Int64, UnitRange}, Union{Colon, Int64, UnitRange}, GridLayoutBase.Side}, Any}}
kwargs  :: Dict{Symbol, Any}</code></pre></div></div><div class="docstring"><div class="doc-header" id="GridPosition"><a href="#GridPosition">GridPosition</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.GridPosition &lt;: Any</code></pre><h1>Fields</h1><pre><code>layout :: GridLayoutBase.GridLayout
span   :: GridLayoutBase.Span
side   :: GridLayoutBase.Side</code></pre></div></div><div class="docstring"><div class="doc-header" id="GridSubposition"><a href="#GridSubposition">GridSubposition</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.GridSubposition &lt;: Any</code></pre><h1>Fields</h1><pre><code>parent :: Union{GridLayoutBase.GridPosition, GridLayoutBase.GridSubposition}
rows   :: Any
cols   :: Any
side   :: GridLayoutBase.Side</code></pre></div></div><div class="docstring"><div class="doc-header" id="Heatmap"><a href="#Heatmap">Heatmap</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.Heatmap</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Hist"><a href="#Hist">Hist</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Hist</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="IRect"><a href="#IRect">IRect</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.IRect</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="IRect2D"><a href="#IRect2D">IRect2D</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="IRect3D"><a href="#IRect3D">IRect3D</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Image"><a href="#Image">Image</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.Image</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="IndexedAbsorptionRGBA"><a href="#IndexedAbsorptionRGBA">IndexedAbsorptionRGBA</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.IndexedAbsorptionRGBA</code> is of type <code>Makie.RaymarchAlgorithm</code>.</p><h1>Summary</h1><pre><code>primitive type Makie.RaymarchAlgorithm &lt;: Enum{Int32}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Makie.RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Inside"><a href="#Inside">Inside</a></div><div class="doc-content"><p>AlignMode that excludes the protrusions from the bounding box.</p></div></div><div class="docstring"><div class="doc-header" id="IntervalSlider"><a href="#IntervalSlider">IntervalSlider</a></div><div class="doc-content"><p>IntervalSlider has the following attributes:</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The align mode of the slider in its parent GridLayout.</p><p><code>color_active</code><br/>Default: <code>COLOR_ACCENT[]</code><br/>The color of the slider when the mouse clicks and drags the slider.</p><p><code>color_active_dimmed</code><br/>Default: <code>COLOR_ACCENT_DIMMED[]</code><br/>The color of the slider when the mouse hovers over it.</p><p><code>color_inactive</code><br/>Default: <code>RGBf(0.94, 0.94, 0.94)</code><br/>The color of the slider when it is not interacted with.</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the slider in its suggested bounding box.</p><p><code>height</code><br/>Default: <code>Auto()</code><br/>The height setting of the slider.</p><p><code>horizontal</code><br/>Default: <code>true</code><br/>Controls if the slider has a horizontal orientation or not.</p><p><code>interval</code><br/>Default: <code>(0, 0)</code><br/>The current interval of the slider. Don't set this manually, use the function <code>set_close_to!</code>.</p><p><code>linewidth</code><br/>Default: <code>15</code><br/>The width of the slider line</p><p><code>range</code><br/>Default: <code>0:0.01:10</code><br/>The range of values that the slider can pick from.</p><p><code>snap</code><br/>Default: <code>true</code><br/>Controls if the buttons snap to valid positions or move freely</p><p><code>startvalues</code><br/>Default: <code>Makie.automatic</code><br/>The start values of the slider or the values that are closest in the slider range.</p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the slider in its suggested bounding box.</p><p><code>width</code><br/>Default: <code>Auto()</code><br/>The width setting of the slider.</p></div></div><div class="docstring"><div class="doc-header" id="IntervalsBetween"><a href="#IntervalsBetween">IntervalsBetween</a></div><div class="doc-content"><pre><code>IntervalsBetween(n::Int, mirror::Bool = true)</code></pre><p>Indicates to create n-1 minor ticks between every pair of adjacent major ticks.</p></div></div><div class="docstring"><div class="doc-header" id="IsoValue"><a href="#IsoValue">IsoValue</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.IsoValue</code> is of type <code>Makie.RaymarchAlgorithm</code>.</p><h1>Summary</h1><pre><code>primitive type Makie.RaymarchAlgorithm &lt;: Enum{Int32}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Makie.RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Keyboard"><a href="#Keyboard">Keyboard</a></div><div class="doc-content"><p>Backend independent enums which represent keyboard buttons.</p></div></div><div class="docstring"><div class="doc-header" id="KeysEvent"><a href="#KeysEvent">KeysEvent</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.MakieLayout.KeysEvent &lt;: Any</code></pre><h1>Fields</h1><pre><code>keys :: Set{Makie.Keyboard.Button}</code></pre></div></div><div class="docstring"><div class="doc-header" id="LScene"><a href="#LScene">LScene</a></div><div class="doc-content"><p>LScene has the following attributes:</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The alignment of the scene in its suggested bounding box.</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the scene in its suggested bounding box.</p><p><code>height</code><br/>Default: <code>nothing</code><br/>The height setting of the scene.</p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the scene in its suggested bounding box.</p><p><code>width</code><br/>Default: <code>nothing</code><br/>The width setting of the scene.</p></div></div><div class="docstring"><div class="doc-header" id="Label"><a href="#Label">Label</a></div><div class="doc-content"><p>Label has the following attributes:</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The align mode of the text in its parent GridLayout.</p><p><code>color</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The color of the text.</p><p><code>font</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The font family of the text.</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the text in its suggested boundingbox</p><p><code>height</code><br/>Default: <code>Auto()</code><br/>The height setting of the text.</p><p><code>padding</code><br/>Default: <code>(0.0f0, 0.0f0, 0.0f0, 0.0f0)</code><br/>The extra space added to the sides of the text boundingbox.</p><p><code>rotation</code><br/>Default: <code>0.0</code><br/>The counterclockwise rotation of the text in radians.</p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>text</code><br/>Default: <code>"Text"</code><br/>The displayed text string.</p><p><code>textsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The font size of the text.</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the text in its suggested boundingbox</p><p><code>visible</code><br/>Default: <code>true</code><br/>Controls if the text is visible.</p><p><code>width</code><br/>Default: <code>Auto()</code><br/>The width setting of the text.</p></div></div><div class="docstring"><div class="doc-header" id="LayoutObservables"><a href="#LayoutObservables">LayoutObservables</a></div><div class="doc-content"><pre><code>mutable struct LayoutObservables{T, G}</code></pre><p><code>T</code> is the same type parameter of contained <code>GridContent</code>, <code>G</code> is <code>GridLayout</code> which is defined only after <code>LayoutObservables</code>.</p><p>A collection of <code>Observable</code>s and an optional <code>GridContent</code> that are needed to interface with the MakieLayout layouting system.</p><ul><li><p><code>suggestedbbox::Observable{Rect2f}</code>: The bounding box that an element should place itself in. Depending on the element's <code>width</code> and <code>height</code> attributes, this is not necessarily equal to the computedbbox.</p></li><li><p><code>protrusions::Observable{RectSides{Float32}}</code>: The sizes of content "sticking out" of the main element into the <code>GridLayout</code> gaps.</p></li><li><p><code>reportedsize::Observable{NTuple{2, Optional{Float32}}}</code>: The width and height that the element computes for itself if possible (else <code>nothing</code>).</p></li><li><p><code>autosize::Observable{NTuple{2, Optional{Float32}}}</code>: The width and height that the element reports to its parent <code>GridLayout</code>. If the element doesn't want to cause the parent to adjust to its size, autosize can hide the reportedsize from it by being set to <code>nothing</code>.</p></li><li><p><code>computedbbox::Observable{Rect2f}</code>: The bounding box that the element computes for itself after it has received a suggestedbbox.</p></li><li><p><code>gridcontent::Optional{GridContent{G, T}}</code>: A reference of a <code>GridContent</code> if the element is currently placed in a <code>GridLayout</code>. This can be used to retrieve the parent layout, remove the element from it or change its position, and assign it to a different layout.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Left"><a href="#Left">Left</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.Left &lt;: GridLayoutBase.Side</code></pre><h1>Supertype Hierarchy</h1><pre><code>GridLayoutBase.Left &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Legend"><a href="#Legend">Legend</a></div><div class="doc-content"><p>Legend has the following attributes:</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The align mode of the legend in its parent GridLayout.</p><p><code>bgcolor</code><br/>Default: <code>:white</code><br/>The background color of the legend.</p><p><code>colgap</code><br/>Default: <code>16</code><br/>The gap between the label of one legend entry and the patch of the next.</p><p><code>framecolor</code><br/>Default: <code>:black</code><br/>The color of the legend border.</p><p><code>framevisible</code><br/>Default: <code>true</code><br/>Controls if the legend border is visible.</p><p><code>framewidth</code><br/>Default: <code>1.0</code><br/>The line width of the legend border.</p><p><code>gridshalign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of entry groups in their parent GridLayout.</p><p><code>gridsvalign</code><br/>Default: <code>:center</code><br/>The vertical alignment of entry groups in their parent GridLayout.</p><p><code>groupgap</code><br/>Default: <code>16</code><br/>The gap between each group and the next.</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the legend in its suggested bounding box.</p><p><code>height</code><br/>Default: <code>Auto()</code><br/>The height setting of the legend.</p><p><code>label</code><br/>Default: <code>"undefined"</code><br/>The default entry label.</p><p><code>labelcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The color of the entry labels.</p><p><code>labelfont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The font family of the entry labels.</p><p><code>labelhalign</code><br/>Default: <code>:left</code><br/>The horizontal alignment of the entry labels.</p><p><code>labelsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The font size of the entry labels.</p><p><code>labelvalign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the entry labels.</p><p><code>linecolor</code><br/>Default: <code>theme(scene, :linecolor)</code><br/>The default line color used for LineElements</p><p><code>linepoints</code><br/>Default: <code>[Point2f(0, 0.5), Point2f(1, 0.5)]</code><br/>The default points used for LineElements in normalized coordinates relative to each label patch.</p><p><code>linestyle</code><br/>Default: <code>:solid</code><br/>The default line style used for LineElements</p><p><code>linewidth</code><br/>Default: <code>theme(scene, :linewidth)</code><br/>The default line width used for LineElements.</p><p><code>margin</code><br/>Default: <code>(0.0f0, 0.0f0, 0.0f0, 0.0f0)</code><br/>The additional space between the legend and its suggested boundingbox.</p><p><code>marker</code><br/>Default: <code>theme(scene, :marker)</code><br/>The default marker for MarkerElements</p><p><code>markercolor</code><br/>Default: <code>theme(scene, :markercolor)</code><br/>The default marker color for MarkerElements</p><p><code>markerpoints</code><br/>Default: <code>[Point2f(0.5, 0.5)]</code><br/>The default marker points used for MarkerElements in normalized coordinates relative to each label patch.</p><p><code>markersize</code><br/>Default: <code>theme(scene, :markersize)</code><br/>The default marker size used for MarkerElements.</p><p><code>markerstrokecolor</code><br/>Default: <code>theme(scene, :markerstrokecolor)</code><br/>The default marker stroke color used for MarkerElements.</p><p><code>markerstrokewidth</code><br/>Default: <code>theme(scene, :markerstrokewidth)</code><br/>The default marker stroke width used for MarkerElements.</p><p><code>nbanks</code><br/>Default: <code>1</code><br/>The number of banks in which the legend entries are grouped. Columns if the legend is vertically oriented, otherwise rows.</p><p><code>orientation</code><br/>Default: <code>:vertical</code><br/>The orientation of the legend (:horizontal or :vertical).</p><p><code>padding</code><br/>Default: <code>(10.0f0, 10.0f0, 8.0f0, 8.0f0)</code><br/>The additional space between the legend content and the border.</p><p><code>patchcolor</code><br/>Default: <code>:transparent</code><br/>The color of the patches containing the legend markers.</p><p><code>patchlabelgap</code><br/>Default: <code>5</code><br/>The gap between the patch and the label of each legend entry.</p><p><code>patchsize</code><br/>Default: <code>(20.0f0, 20.0f0)</code><br/>The size of the rectangles containing the legend markers.</p><p><code>patchstrokecolor</code><br/>Default: <code>:transparent</code><br/>The color of the border of the patches containing the legend markers.</p><p><code>patchstrokewidth</code><br/>Default: <code>1.0</code><br/>The line width of the border of the patches containing the legend markers.</p><p><code>polycolor</code><br/>Default: <code>theme(scene, :patchcolor)</code><br/>The default poly color used for PolyElements.</p><p><code>polypoints</code><br/>Default: <code>[Point2f(0, 0), Point2f(1, 0), Point2f(1, 1), Point2f(0, 1)]</code><br/>The default poly points used for PolyElements in normalized coordinates relative to each label patch.</p><p><code>polystrokecolor</code><br/>Default: <code>theme(scene, :patchstrokecolor)</code><br/>The default poly stroke color used for PolyElements.</p><p><code>polystrokewidth</code><br/>Default: <code>theme(scene, :patchstrokewidth)</code><br/>The default poly stroke width used for PolyElements.</p><p><code>rowgap</code><br/>Default: <code>3</code><br/>The gap between the entry rows.</p><p><code>tellheight</code><br/>Default: <code>automatic</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>automatic</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>titlecolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>The color of the legend titles</p><p><code>titlefont</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>The font family of the legend group titles.</p><p><code>titlegap</code><br/>Default: <code>8</code><br/>The gap between each group title and its group.</p><p><code>titlehalign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the legend group titles.</p><p><code>titleposition</code><br/>Default: <code>:top</code><br/>The group title positions relative to their groups. Can be <code>:top</code> or <code>:left</code>.</p><p><code>titlesize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>The font size of the legend group titles.</p><p><code>titlevalign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the legend group titles.</p><p><code>titlevisible</code><br/>Default: <code>true</code><br/>Controls if the legend titles are visible.</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the legend in its suggested bounding box.</p><p><code>width</code><br/>Default: <code>Auto()</code><br/>The width setting of the legend.</p></div></div><div class="docstring"><div class="doc-header" id="LegendElement"><a href="#LegendElement">LegendElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type Makie.MakieLayout.LegendElement &lt;: Any</code></pre><h1>Subtypes</h1><pre><code>Makie.MakieLayout.LineElement
Makie.MakieLayout.MarkerElement
Makie.MakieLayout.PolyElement</code></pre></div></div><div class="docstring"><div class="doc-header" id="LegendEntry"><a href="#LegendEntry">LegendEntry</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.MakieLayout.LegendEntry &lt;: Any</code></pre><h1>Fields</h1><pre><code>elements   :: Vector{Makie.MakieLayout.LegendElement}
attributes :: MakieCore.Attributes</code></pre></div></div><div class="docstring"><div class="doc-header" id="LineElement"><a href="#LineElement">LineElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.MakieLayout.LineElement &lt;: Makie.MakieLayout.LegendElement</code></pre><h1>Fields</h1><pre><code>attributes :: MakieCore.Attributes</code></pre><h1>Supertype Hierarchy</h1><pre><code>Makie.MakieLayout.LineElement &lt;: Makie.MakieLayout.LegendElement &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="LineSegments"><a href="#LineSegments">LineSegments</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.LineSegments</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="LinearTicks"><a href="#LinearTicks">LinearTicks</a></div><div class="doc-content"><p>LinearTicks with ideally a number of <code>n_ideal</code> tick marks.</p></div></div><div class="docstring"><div class="doc-header" id="Lines"><a href="#Lines">Lines</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.Lines</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="LogTicks"><a href="#LogTicks">LogTicks</a></div><div class="doc-content"><pre><code>LogTicks{T}(linear_ticks::T)</code></pre><p>Wraps any other tick object. Used to apply a linear tick searching algorithm on a log-transformed interval.</p></div></div><div class="docstring"><div class="doc-header" id="Makie"><a href="#Makie">Makie</a></div><div class="doc-content"><p>No documentation found.</p><p>No docstring found for module <code>Makie</code>.</p></div></div><div class="docstring"><div class="doc-header" id="MakieLayout"><a href="#MakieLayout">MakieLayout</a></div><div class="doc-content"><p>No documentation found.</p><p>No docstring found for module <code>Makie.MakieLayout</code>.</p></div></div><div class="docstring"><div class="doc-header" id="MarkerElement"><a href="#MarkerElement">MarkerElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.MakieLayout.MarkerElement &lt;: Makie.MakieLayout.LegendElement</code></pre><h1>Fields</h1><pre><code>attributes :: MakieCore.Attributes</code></pre><h1>Supertype Hierarchy</h1><pre><code>Makie.MakieLayout.MarkerElement &lt;: Makie.MakieLayout.LegendElement &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="MaximumIntensityProjection"><a href="#MaximumIntensityProjection">MaximumIntensityProjection</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.MaximumIntensityProjection</code> is of type <code>Makie.RaymarchAlgorithm</code>.</p><h1>Summary</h1><pre><code>primitive type Makie.RaymarchAlgorithm &lt;: Enum{Int32}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Makie.RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Menu"><a href="#Menu">Menu</a></div><div class="doc-content"><pre><code>Menu(parent::Scene; bbox = nothing, kwargs...)</code></pre><p>Create a drop-down menu with multiple selectable options. You can pass options with the keyword argument <code>options</code>. Options are given as an iterable of elements. For each element, the option label in the menu is determined with <code>optionlabel(element)</code> and the option value with <code>optionvalue(element)</code>. These functions can be overloaded for custom types. The default is that tuples of two elements are expected to be label and value, where <code>string(label)</code> is used as the label, while for all other objects, label = <code>string(object)</code> and value = object.</p><p>When an item is selected in the menu, the menu's <code>selection</code> attribute is set to <code>optionvalue(selected_element)</code>.</p><p>If the menu is located close to the lower scene border, you can change its open direction to <code>direction = :up</code>.</p><h1>Example</h1><p>Menu with string entries:</p><pre><code class="language-julia">menu1 = Menu(scene, options = ["first", "second", "third"])</code></pre><p>Menu with two-element entries, label and function:</p><pre><code class="language-julia">funcs = [sin, cos, tan]
labels = ["Sine", "Cosine", "Tangens"]

menu2 = Menu(scene, options = zip(labels, funcs))</code></pre><p>Lifting on the selection value:</p><pre><code class="language-julia">on(menu2.selection) do func
    # do something with the selected function
end</code></pre><p>Menu has the following attributes:</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The alignment of the menu in its suggested bounding box.</p><p><code>cell_color_active</code><br/>Default: <code>COLOR_ACCENT[]</code><br/>Cell color when active</p><p><code>cell_color_hover</code><br/>Default: <code>COLOR_ACCENT_DIMMED[]</code><br/>Cell color when hovered</p><p><code>cell_color_inactive_even</code><br/>Default: <code>RGBf(0.97, 0.97, 0.97)</code><br/>Cell color when inactive even</p><p><code>cell_color_inactive_odd</code><br/>Default: <code>RGBf(0.97, 0.97, 0.97)</code><br/>Cell color when inactive odd</p><p><code>direction</code><br/>Default: <code>automatic</code><br/>The opening direction of the menu (:up or :down)</p><p><code>dropdown_arrow_color</code><br/>Default: <code>(:black, 0.2)</code><br/>Color of the dropdown arrow</p><p><code>dropdown_arrow_size</code><br/>Default: <code>12px</code><br/>Size of the dropdown arrow</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the menu in its suggested bounding box.</p><p><code>height</code><br/>Default: <code>Auto()</code><br/>The height setting of the menu.</p><p><code>i_selected</code><br/>Default: <code>0</code><br/>Index of selected item</p><p><code>is_open</code><br/>Default: <code>false</code><br/>Is the menu showing the available options</p><p><code>options</code><br/>Default: <code>["no options"]</code><br/>The list of options selectable in the menu. This can be any iterable of a mixture of strings and containers with one string and one other value. If an entry is just a string, that string is both label and selection. If an entry is a container with one string and one other value, the string is the label and the other value is the selection.</p><p><code>prompt</code><br/>Default: <code>"Select..."</code><br/>The default message prompting a selection when i == 0</p><p><code>selection</code><br/>Default: <code>nothing</code><br/>Selected item value</p><p><code>selection_cell_color_inactive</code><br/>Default: <code>RGBf(0.94, 0.94, 0.94)</code><br/>Selection cell color when inactive</p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>textcolor</code><br/>Default: <code>:black</code><br/>Color of entry texts</p><p><code>textpadding</code><br/>Default: <code>(10, 10, 10, 10)</code><br/>Padding of entry texts</p><p><code>textsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>Font size of the cell texts</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the menu in its suggested bounding box.</p><p><code>width</code><br/>Default: <code>nothing</code><br/>The width setting of the menu.</p></div></div><div class="docstring"><div class="doc-header" id="Mesh"><a href="#Mesh">Mesh</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.Mesh</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="MeshScatter"><a href="#MeshScatter">MeshScatter</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.MeshScatter</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Mixed"><a href="#Mixed">Mixed</a></div><div class="doc-content"><p>AlignMode that is Inside where padding is Nothing, Outside where it is Real, and overrides the protrusion with a fixed value where it is a <code>Protrusion</code>.</p></div></div><div class="docstring"><div class="doc-header" id="Mouse"><a href="#Mouse">Mouse</a></div><div class="doc-content"><p>Backend independent enums and fields which represent mouse actions.</p></div></div><div class="docstring"><div class="doc-header" id="MouseEvent"><a href="#MouseEvent">MouseEvent</a></div><div class="doc-content"><pre><code>MouseEvent</code></pre><p>Describes a mouse state change. Fields:</p><ul><li><p><code>type</code>: MouseEventType</p></li><li><p><code>t</code>: Time of the event</p></li><li><p><code>data</code>: Mouse position in data coordinates</p></li><li><p><code>px</code>: Mouse position in px relative to scene origin</p></li><li><p><code>prev_t</code>: Time of previous event</p></li><li><p><code>prev_data</code>: Previous mouse position in data coordinates</p></li><li><p><code>prev_px</code>: Previous mouse position in data coordinates</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="MouseEventTypes"><a href="#MouseEventTypes">MouseEventTypes</a></div><div class="doc-content"><p>No documentation found.</p><p>No docstring found for module <code>Makie.MakieLayout.MouseEventTypes</code>.</p></div></div><div class="docstring"><div class="doc-header" id="MultiplesTicks"><a href="#MultiplesTicks">MultiplesTicks</a></div><div class="doc-content"><p>Like LinearTicks but for multiples of <code>multiple</code>. Example where approximately 5 numbers should be found that are multiples of pi, printed like "1π", "2π", etc.:</p><pre><code>MultiplesTicks(5, pi, "π")</code></pre></div></div><div class="docstring"><div class="doc-header" id="NoConversion"><a href="#NoConversion">NoConversion</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct MakieCore.NoConversion &lt;: MakieCore.ConversionTrait</code></pre><h1>Supertype Hierarchy</h1><pre><code>MakieCore.NoConversion &lt;: MakieCore.ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Node"><a href="#Node">Node</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Node</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Observable"><a href="#Observable">Observable</a></div><div class="doc-content"><pre><code>obs = Observable(val)
obs = Observable{T}(val)</code></pre><p>Like a <code>Ref</code>, but updates can be watched by adding a handler using <a href="@ref"><code>on</code></a> or <a href="@ref"><code>map</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="OldAxis"><a href="#OldAxis">OldAxis</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.OldAxis &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Outside"><a href="#Outside">Outside</a></div><div class="doc-content"><p>AlignMode that includes the protrusions within the bounding box, plus paddings.</p></div></div><div class="docstring"><div class="doc-header" id="Pattern"><a href="#Pattern">Pattern</a></div><div class="doc-content"><pre><code>Pattern(image)
Pattern(mask[; color1, color2])</code></pre><p>Creates an <code>ImagePattern</code> from an <code>image</code> (a matrix of colors) or a <code>mask</code> (a matrix of real numbers). The pattern can be passed as a <code>color</code> to a plot to texture it. If a <code>mask</code> is passed, one can specify to colors between which colors are interpolated.</p><pre><code>Pattern(style::String = "/"; kwargs...)
Pattern(style::Char = '/'; kwargs...)</code></pre><p>Creates a line pattern based on the given argument. Available patterns are <code>'/'</code>, <code>'\'</code>, <code>'-'</code>, <code>'|'</code>, <code>'x'</code>, and <code>'+'</code>. All keyword arguments correspond to the keyword arguments for <a href="@ref"><code>LinePattern</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="Pie"><a href="#Pie">Pie</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Pie</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Pixel"><a href="#Pixel">Pixel</a></div><div class="doc-content"><p>Unit in pixels on screen. This one is a bit tricky, since it refers to a static attribute (pixels on screen don't change) but since every visual is attached to a camera, the exact scale might change. So in the end, this is just relative to some normed camera - the value on screen, depending on the camera, will not actually sit on those pixels. Only camera that guarantees the correct mapping is the <code>:pixel</code> camera type.</p></div></div><div class="docstring"><div class="doc-header" id="PixelSpace"><a href="#PixelSpace">PixelSpace</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.PixelSpace</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="PlotSpec"><a href="#PlotSpec">PlotSpec</a></div><div class="doc-content"><p><code>PlotSpec{P&lt;:AbstractPlot}(args...; kwargs...)</code></p><p>Object encoding positional arguments (<code>args</code>), a <code>NamedTuple</code> of attributes (<code>kwargs</code>) as well as plot type <code>P</code> of a basic plot.</p></div></div><div class="docstring"><div class="doc-header" id="Point"><a href="#Point">Point</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Point</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point2"><a href="#Point2">Point2</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Point2</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point2f"><a href="#Point2f">Point2f</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Point</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point2f0"><a href="#Point2f0">Point2f0</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Point</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point3"><a href="#Point3">Point3</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Point3</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point3f"><a href="#Point3f">Point3f</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Point</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point3f0"><a href="#Point3f0">Point3f0</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Point</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point4"><a href="#Point4">Point4</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Point4</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point4f"><a href="#Point4f">Point4f</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Point</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Point4f0"><a href="#Point4f0">Point4f0</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Point</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="PointBased"><a href="#PointBased">PointBased</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct MakieCore.PointBased &lt;: MakieCore.ConversionTrait</code></pre><h1>Supertype Hierarchy</h1><pre><code>MakieCore.PointBased &lt;: MakieCore.ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Poly"><a href="#Poly">Poly</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Poly</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="PolyElement"><a href="#PolyElement">PolyElement</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.MakieLayout.PolyElement &lt;: Makie.MakieLayout.LegendElement</code></pre><h1>Fields</h1><pre><code>attributes :: MakieCore.Attributes</code></pre><h1>Supertype Hierarchy</h1><pre><code>Makie.MakieLayout.PolyElement &lt;: Makie.MakieLayout.LegendElement &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="QQNorm"><a href="#QQNorm">QQNorm</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.QQNorm</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="QQPlot"><a href="#QQPlot">QQPlot</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.QQPlot</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Quaternion"><a href="#Quaternion">Quaternion</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Quaternion</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Quaternionf"><a href="#Quaternionf">Quaternionf</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Quaternion</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="RGBAf"><a href="#RGBAf">RGBAf</a></div><div class="doc-content"><p>No documentation found.</p><p><code>ColorTypes.RGBA</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="RGBf"><a href="#RGBf">RGBf</a></div><div class="doc-content"><p><code>RGB</code> is the standard Red-Green-Blue (sRGB) colorspace.  Values of the individual color channels range from 0 (black) to 1 (saturated). If you want "Integer" storage types (e.g., 255 for full color), use <code>N0f8(1)</code> instead (see FixedPointNumbers).</p></div></div><div class="docstring"><div class="doc-header" id="Rangebars"><a href="#Rangebars">Rangebars</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Rangebars</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="RaymarchAlgorithm"><a href="#RaymarchAlgorithm">RaymarchAlgorithm</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>primitive type Makie.RaymarchAlgorithm &lt;: Enum{Int32}</code></pre><h1>Supertype Hierarchy</h1><pre><code>Makie.RaymarchAlgorithm &lt;: Enum{Int32} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="RealVector"><a href="#RealVector">RealVector</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.RealVector</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="RecordEvents"><a href="#RecordEvents">RecordEvents</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.RecordEvents &lt;: Any</code></pre><h1>Fields</h1><pre><code>scene :: Makie.Scene
path  :: String</code></pre></div></div><div class="docstring"><div class="doc-header" id="Rect"><a href="#Rect">Rect</a></div><div class="doc-content"><pre><code>Rect(vals::Number...)</code></pre><pre><code>Rect(vals::Number...)</code></pre><p>Rect constructor for indidually specified intervals. e.g. Rect(0,0,1,2) has origin == Vec(0,0) and width == Vec(1,2)</p><p>Construct a HyperRectangle enclosing all points.</p></div></div><div class="docstring"><div class="doc-header" id="Rect2"><a href="#Rect2">Rect2</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Rect2</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Rect2D"><a href="#Rect2D">Rect2D</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Rect2D</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Rect2f"><a href="#Rect2f">Rect2f</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect2i"><a href="#Rect2i">Rect2i</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect3"><a href="#Rect3">Rect3</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Rect3</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Rect3D"><a href="#Rect3D">Rect3D</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Rect3D</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Rect3f"><a href="#Rect3f">Rect3f</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rect3i"><a href="#Rect3i">Rect3i</a></div><div class="doc-content"><pre><code>HyperRectangle{N, T}</code></pre><p>A <code>HyperRectangle</code> is a generalization of a rectangle into N-dimensions. Formally it is the cartesian product of intervals, which is represented by the <code>origin</code> and <code>widths</code> fields, whose indices correspond to each of the <code>N</code> axes.</p></div></div><div class="docstring"><div class="doc-header" id="Rectf"><a href="#Rectf">Rectf</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Rectf</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Recti"><a href="#Recti">Recti</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Recti</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Relative"><a href="#Relative">Relative</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.Relative &lt;: GridLayoutBase.GapSize</code></pre><h1>Fields</h1><pre><code>x :: Float64</code></pre><h1>Supertype Hierarchy</h1><pre><code>GridLayoutBase.Relative &lt;: GridLayoutBase.GapSize &lt;: GridLayoutBase.ContentSize &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Reverse"><a href="#Reverse">Reverse</a></div><div class="doc-content"><p>Reverses the attribute T upon conversion</p></div></div><div class="docstring"><div class="doc-header" id="Right"><a href="#Right">Right</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.Right &lt;: GridLayoutBase.Side</code></pre><h1>Supertype Hierarchy</h1><pre><code>GridLayoutBase.Right &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Scatter"><a href="#Scatter">Scatter</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.Scatter</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="ScatterLines"><a href="#ScatterLines">ScatterLines</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.ScatterLines</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Scene"><a href="#Scene">Scene</a></div><div class="doc-content"><pre><code>Scene TODO document this</code></pre><h2>Constructors</h2><h2>Fields</h2><ul><li><p><code>parent</code></p><p>The parent of the Scene; if it is a top-level Scene, <code>parent == nothing</code>.</p></li><li><p><code>events</code></p><p><a href="@ref"><code>Events</code></a> associated with the Scene.</p></li><li><p><code>px_area</code></p><p>The current pixel area of the Scene.</p></li><li><p><code>clear</code></p><p>Whether the scene should be cleared.</p></li><li><p><code>camera</code></p><p>The <code>Camera</code> associated with the Scene.</p></li><li><p><code>camera_controls</code></p><p>The controls for the camera of the Scene.</p></li><li><p><code>data_limits</code></p><p>The limits of the data plotted in this scene. Can't be set by user and is only used to store calculated data bounds.</p></li></ul><ul><li><p><code>transformation</code></p><p>The <a href="@ref"><code>Transformation</code></a> of the Scene.</p></li><li><p><code>plots</code></p><p>The plots contained in the Scene.</p></li><li><p><code>theme</code></p></li><li><p><code>attributes</code></p></li><li><p><code>children</code></p><p>Children of the Scene inherit its transformation.</p></li><li><p><code>current_screens</code></p><p>The Screens which the Scene is displayed to.</p></li></ul><ul><li><p><code>updated</code></p><p>Signal to indicate whether layouting should happen. If updated to true, the Scene will be layouted according to its attributes (<code>raw</code>, <code>center</code>, or <code>scale_plot</code>).</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="SceneLike"><a href="#SceneLike">SceneLike</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.SceneLike</code> is of type <code>Union</code>.</p><h1>Summary</h1><pre><code>struct Union &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>a :: Any
b :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>Union &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="SceneSpace"><a href="#SceneSpace">SceneSpace</a></div><div class="doc-content"><p>Unit space of the scene it's displayed on. Also referred to as data units</p></div></div><div class="docstring"><div class="doc-header" id="ScrollEvent"><a href="#ScrollEvent">ScrollEvent</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.MakieLayout.ScrollEvent &lt;: Any</code></pre><h1>Fields</h1><pre><code>x :: Float32
y :: Float32</code></pre></div></div><div class="docstring"><div class="doc-header" id="Series"><a href="#Series">Series</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Series</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Slider"><a href="#Slider">Slider</a></div><div class="doc-content"><p>Slider has the following attributes:</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The align mode of the slider in its parent GridLayout.</p><p><code>color_active</code><br/>Default: <code>COLOR_ACCENT[]</code><br/>The color of the slider when the mouse clicks and drags the slider.</p><p><code>color_active_dimmed</code><br/>Default: <code>COLOR_ACCENT_DIMMED[]</code><br/>The color of the slider when the mouse hovers over it.</p><p><code>color_inactive</code><br/>Default: <code>RGBf(0.94, 0.94, 0.94)</code><br/>The color of the slider when it is not interacted with.</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the slider in its suggested bounding box.</p><p><code>height</code><br/>Default: <code>Auto()</code><br/>The height setting of the slider.</p><p><code>horizontal</code><br/>Default: <code>true</code><br/>Controls if the slider has a horizontal orientation or not.</p><p><code>linewidth</code><br/>Default: <code>15</code><br/>The width of the slider line</p><p><code>range</code><br/>Default: <code>0:0.01:10</code><br/>The range of values that the slider can pick from.</p><p><code>snap</code><br/>Default: <code>true</code><br/>Controls if the button snaps to valid positions or moves freely</p><p><code>startvalue</code><br/>Default: <code>0</code><br/>The start value of the slider or the value that is closest in the slider range.</p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the slider in its suggested bounding box.</p><p><code>value</code><br/>Default: <code>0</code><br/>The current value of the slider. Don't set this manually, use the function <code>set_close_to!</code>.</p><p><code>width</code><br/>Default: <code>Auto()</code><br/>The width setting of the slider.</p></div></div><div class="docstring"><div class="doc-header" id="Sphere"><a href="#Sphere">Sphere</a></div><div class="doc-content"><pre><code>Sphere{T}</code></pre><p>An alias for a HyperSphere of dimension 3. (i.e. <code>HyperSphere{3, T}</code>)</p></div></div><div class="docstring"><div class="doc-header" id="Spy"><a href="#Spy">Spy</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Spy</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Stairs"><a href="#Stairs">Stairs</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Stairs</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Stem"><a href="#Stem">Stem</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Stem</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Stepper"><a href="#Stepper">Stepper</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Stepper</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "Stepper":
[1] Stepper(scene::Union{Makie.Figure, Makie.FigureAxisPlot, Makie.Scene}; format) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/display.jl:144
[2] Stepper(scene::Union{Makie.Figure, Makie.FigureAxisPlot, Makie.Scene}, path::String; format) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/display.jl:146
[3] Stepper(scene::Union{Makie.Figure, Makie.FigureAxisPlot, Makie.Scene}, path::String, step::Int64; format) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/display.jl:143</code></pre></div></div><div class="docstring"><div class="doc-header" id="StreamPlot"><a href="#StreamPlot">StreamPlot</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.StreamPlot</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Surface"><a href="#Surface">Surface</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.Surface</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="SurfaceLike"><a href="#SurfaceLike">SurfaceLike</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>abstract type MakieCore.SurfaceLike &lt;: MakieCore.ConversionTrait</code></pre><h1>Subtypes</h1><pre><code>MakieCore.ContinuousSurface
MakieCore.DiscreteSurface</code></pre><h1>Supertype Hierarchy</h1><pre><code>MakieCore.SurfaceLike &lt;: MakieCore.ConversionTrait &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Text"><a href="#Text">Text</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.Text</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Textbox"><a href="#Textbox">Textbox</a></div><div class="doc-content"><pre><code>Textbox(parent::Scene; bbox = nothing, kwargs...)</code></pre><p>Textbox has the following attributes: <code>alignmode</code><br/>Default: <code>Inside()</code><br/>The alignment of the textbox in its suggested bounding box.</p><p><code>bordercolor</code><br/>Default: <code>RGBf(0.8, 0.8, 0.8)</code><br/>Color of the box border.</p><p><code>bordercolor_focused</code><br/>Default: <code>COLOR_ACCENT[]</code><br/>Color of the box border when focused.</p><p><code>bordercolor_focused_invalid</code><br/>Default: <code>RGBf(1, 0, 0)</code><br/>Color of the box border when focused and invalid.</p><p><code>bordercolor_hover</code><br/>Default: <code>COLOR_ACCENT_DIMMED[]</code><br/>Color of the box border when hovered.</p><p><code>borderwidth</code><br/>Default: <code>2.0</code><br/>Width of the box border.</p><p><code>boxcolor</code><br/>Default: <code>:transparent</code><br/>Color of the box.</p><p><code>boxcolor_focused</code><br/>Default: <code>:transparent</code><br/>Color of the box when focused.</p><p><code>boxcolor_focused_invalid</code><br/>Default: <code>RGBAf(1, 0, 0, 0.3)</code><br/>Color of the box when focused.</p><p><code>boxcolor_hover</code><br/>Default: <code>:transparent</code><br/>Color of the box when hovered.</p><p><code>cornerradius</code><br/>Default: <code>8</code><br/>Corner radius of text box.</p><p><code>cornersegments</code><br/>Default: <code>20</code><br/>Corner segments of one rounded corner.</p><p><code>cursorcolor</code><br/>Default: <code>:transparent</code><br/>The color of the cursor.</p><p><code>defocus_on_submit</code><br/>Default: <code>true</code><br/>Controls if the textbox is defocused when a string is submitted.</p><p><code>displayed_string</code><br/>Default: <code>nothing</code><br/>The currently displayed string (for internal use).</p><p><code>focused</code><br/>Default: <code>false</code><br/>If the textbox is focused and receives text input.</p><p><code>font</code><br/>Default: <code>lift_parent_attribute(scene, :font, "DejaVu Sans")</code><br/>Font family.</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the textbox in its suggested bounding box.</p><p><code>height</code><br/>Default: <code>Auto()</code><br/>The height setting of the textbox.</p><p><code>placeholder</code><br/>Default: <code>"Click to edit..."</code><br/>A placeholder text that is displayed when the saved string is nothing.</p><p><code>reset_on_defocus</code><br/>Default: <code>false</code><br/>Controls if the displayed text is reset to the stored text when defocusing the textbox without submitting.</p><p><code>restriction</code><br/>Default: <code>nothing</code><br/>Restricts the allowed unicode input via is_allowed(char, restriction).</p><p><code>stored_string</code><br/>Default: <code>nothing</code><br/>The currently stored string.</p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height.</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width.</p><p><code>textcolor</code><br/>Default: <code>lift_parent_attribute(scene, :textcolor, :black)</code><br/>Text color.</p><p><code>textcolor_placeholder</code><br/>Default: <code>RGBf(0.5, 0.5, 0.5)</code><br/>Text color for the placeholder.</p><p><code>textpadding</code><br/>Default: <code>(10, 10, 10, 10)</code><br/>Padding of the text against the box.</p><p><code>textsize</code><br/>Default: <code>lift_parent_attribute(scene, :fontsize, 16.0f0)</code><br/>Text size.</p><p><code>validator</code><br/>Default: <code>str-&gt;begin         #= /home/runner/work/Makie.jl/Makie.jl/src/makielayout/defaultattributes.jl:969 =#         true     end</code><br/>Validator that is called with validate_textbox(string, validator) to determine if the current string is valid. Can by default be a RegEx that needs to match the complete string, or a function taking a string as input and returning a Bool. If the validator is a type T (for example Float64), validation will be <code>tryparse(string, T)</code>.</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the textbox in its suggested bounding box.</p><p><code>width</code><br/>Default: <code>Auto()</code><br/>The width setting of the textbox.</p></div></div><div class="docstring"><div class="doc-header" id="Theme"><a href="#Theme">Theme</a></div><div class="doc-content"><p>Main structure for holding attributes, for theming plots etc! Will turn all values into nodes, so that they can be updated.</p></div></div><div class="docstring"><div class="doc-header" id="TimeSeries"><a href="#TimeSeries">TimeSeries</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.TimeSeries</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Toggle"><a href="#Toggle">Toggle</a></div><div class="doc-content"><p>Toggle has the following attributes:</p><p><code>active</code><br/>Default: <code>false</code><br/>Indicates if the toggle is active or not.</p><p><code>alignmode</code><br/>Default: <code>Inside()</code><br/>The align mode of the toggle in its parent GridLayout.</p><p><code>buttoncolor</code><br/>Default: <code>COLOR_ACCENT[]</code><br/>The color of the toggle button.</p><p><code>cornersegments</code><br/>Default: <code>15</code><br/>The number of poly segments in each rounded corner.</p><p><code>framecolor_active</code><br/>Default: <code>COLOR_ACCENT_DIMMED[]</code><br/>The color of the border when the toggle is hovered.</p><p><code>framecolor_inactive</code><br/>Default: <code>RGBf(0.94, 0.94, 0.94)</code><br/>The color of the border when the toggle is inactive.</p><p><code>halign</code><br/>Default: <code>:center</code><br/>The horizontal alignment of the toggle in its suggested bounding box.</p><p><code>height</code><br/>Default: <code>28</code><br/>The height of the toggle.</p><p><code>rimfraction</code><br/>Default: <code>0.33</code><br/>The border width as a fraction of the toggle height </p><p><code>tellheight</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's height</p><p><code>tellwidth</code><br/>Default: <code>true</code><br/>Controls if the parent layout can adjust to this element's width</p><p><code>toggleduration</code><br/>Default: <code>0.15</code><br/>The duration of the toggle animation.</p><p><code>valign</code><br/>Default: <code>:center</code><br/>The vertical alignment of the toggle in its suggested bounding box.</p><p><code>width</code><br/>Default: <code>60</code><br/>The width of the toggle.</p></div></div><div class="docstring"><div class="doc-header" id="Top"><a href="#Top">Top</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.Top &lt;: GridLayoutBase.Side</code></pre><h1>Supertype Hierarchy</h1><pre><code>GridLayoutBase.Top &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="TopLeft"><a href="#TopLeft">TopLeft</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.TopLeft &lt;: GridLayoutBase.Side</code></pre><h1>Supertype Hierarchy</h1><pre><code>GridLayoutBase.TopLeft &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="TopRight"><a href="#TopRight">TopRight</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct GridLayoutBase.TopRight &lt;: GridLayoutBase.Side</code></pre><h1>Supertype Hierarchy</h1><pre><code>GridLayoutBase.TopRight &lt;: GridLayoutBase.Side &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Transformation"><a href="#Transformation">Transformation</a></div><div class="doc-content"><p>Holds the transformations for Scenes.</p><h2>Fields</h2><ul><li><p><code>parent::Base.RefValue{MakieCore.Transformable}</code></p></li><li><p><code>translation::Observables.Observable{GeometryBasics.Vec{3, Float32}}</code></p></li><li><p><code>scale::Observables.Observable{GeometryBasics.Vec{3, Float32}}</code></p></li><li><p><code>rotation::Observables.Observable{Makie.Quaternionf}</code></p></li><li><p><code>model::Observables.Observable{StaticArrays.SMatrix{4, 4, Float32, 16}}</code></p></li><li><p><code>flip::Observables.Observable{Tuple{Bool, Bool, Bool}}</code></p></li><li><p><code>align::Observables.Observable{GeometryBasics.Vec{2, Float32}}</code></p></li><li><p><code>transform_func::Observables.Observable{Any}</code></p></li></ul></div></div><div class="docstring"><div class="doc-header" id="Unit"><a href="#Unit">Unit</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.Unit</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec"><a href="#Vec">Vec</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Vec</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec2"><a href="#Vec2">Vec2</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Vec2</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec2f"><a href="#Vec2f">Vec2f</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Vec</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec2f0"><a href="#Vec2f0">Vec2f0</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Vec</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec3"><a href="#Vec3">Vec3</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Vec3</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec3f"><a href="#Vec3f">Vec3f</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Vec</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec3f0"><a href="#Vec3f0">Vec3f0</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Vec</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec4"><a href="#Vec4">Vec4</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Vec4</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec4f"><a href="#Vec4f">Vec4f</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Vec</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Vec4f0"><a href="#Vec4f0">Vec4f0</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.Vec</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VecTypes"><a href="#VecTypes">VecTypes</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.VecTypes</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VideoStream"><a href="#VideoStream">VideoStream</a></div><div class="doc-content"><pre><code>VideoStream(scene::Scene, framerate = 24)</code></pre><p>Returns a stream and a buffer that you can use, which don't allocate for new frames. Use <a href="@ref"><code>recordframe!(stream)</code></a> to add new video frames to the stream, and <a href="@ref"><code>save(path, stream)</code></a> to save the video.</p></div></div><div class="docstring"><div class="doc-header" id="Violin"><a href="#Violin">Violin</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Violin</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="Volume"><a href="#Volume">Volume</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.Volume</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VolumeLike"><a href="#VolumeLike">VolumeLike</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct MakieCore.VolumeLike &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="VolumeSlices"><a href="#VolumeSlices">VolumeSlices</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.VolumeSlices</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="WilkinsonTicks"><a href="#WilkinsonTicks">WilkinsonTicks</a></div><div class="doc-content"><p>No documentation found.</p><h1>Summary</h1><pre><code>struct Makie.MakieLayout.WilkinsonTicks &lt;: Any</code></pre><h1>Fields</h1><pre><code>k_ideal            :: Int64
k_min              :: Int64
k_max              :: Int64
Q                  :: Vector{Tuple{Float64, Float64}}
granularity_weight :: Float64
simplicity_weight  :: Float64
coverage_weight    :: Float64
niceness_weight    :: Float64
min_px_dist        :: Float64</code></pre></div></div><div class="docstring"><div class="doc-header" id="Wireframe"><a href="#Wireframe">Wireframe</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.Wireframe</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="_Inspector"><a href="#_Inspector">_Inspector</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie._Inspector</code> is of type <code>UnionAll</code>.</p><h1>Summary</h1><pre><code>struct UnionAll &lt;: Type{T}</code></pre><h1>Fields</h1><pre><code>var  :: TypeVar
body :: Any</code></pre><h1>Supertype Hierarchy</h1><pre><code>UnionAll &lt;: Type{T} &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="_inspector"><a href="#_inspector">_inspector</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie._inspector</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "_inspector":
[1] _inspector() in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:170
[2] _inspector(args...; attributes...) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:30</code></pre></div></div><div class="docstring"><div class="doc-header" id="_inspector!"><a href="#_inspector!">_inspector!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie._inspector!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "_inspector!":
[1] _inspector!(args...; attributes...) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:34</code></pre></div></div><div class="docstring"><div class="doc-header" id="abline!"><a href="#abline!">abline!</a></div><div class="doc-content"><pre><code>abline!(axis::Axis, a::Number, b::Number; line_kw_args...)</code></pre><p>Adds a line defined by <code>f(x) = x * b + a</code> to the axis. kwargs are the same as for a <code>line</code> plot and are passed directly to the line attributess.</p></div></div><div class="docstring"><div class="doc-header" id="activate_interaction!"><a href="#activate_interaction!">activate_interaction!</a></div><div class="doc-content"><pre><code>activate_interaction!(parent, name::Symbol)</code></pre><p>Activate the interaction named <code>name</code> registered in <code>parent</code>.</p></div></div><div class="docstring"><div class="doc-header" id="addmouseevents!"><a href="#addmouseevents!">addmouseevents!</a></div><div class="doc-content"><pre><code>addmouseevents!(scene, elements...)</code></pre><p>Returns a <code>MouseEventHandle</code> with an observable inside which is triggered by all mouse interactions with the <code>scene</code> and optionally restricted to all given plot objects in <code>elements</code>.</p><p>To react to mouse events, use the onmouse... handlers.</p><p>Example:</p><pre><code>mouseevents = addmouseevents!(scene, scatterplot)

onmouseleftclick(mouseevents) do event
    # do something with the mouseevent
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="annotations"><a href="#annotations">annotations</a></div><div class="doc-content"><pre><code>annotations(strings::Vector{String}, positions::Vector{Point})</code></pre><p>Plots an array of texts at each position in <code>positions</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.annotations, T} where T</code> are: </p><pre><code>  _glyphlayout    "nothing"
  align           (:left, :bottom)
  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  diffuse         Float32[0.4, 0.4, 0.4]
  font            "Dejavu Sans"
  inspectable     true
  justification   MakieCore.Automatic()
  lightposition   :eyeposition
  lineheight      1.0
  linewidth       1
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  offset          (0.0, 0.0)
  overdraw        false
  position        (0.0, 0.0)
  rotation        0.0
  shininess       32.0f0
  space           :screen
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  strokecolor     (:black, 0.0)
  strokewidth     0
  textsize        20
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="annotations!"><a href="#annotations!">annotations!</a></div><div class="doc-content"><pre><code>annotations(strings::Vector{String}, positions::Vector{Point})</code></pre><p>Plots an array of texts at each position in <code>positions</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.annotations!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="arc"><a href="#arc">arc</a></div><div class="doc-content"><pre><code>arc(origin, radius, start_angle, stop_angle; kwargs...)</code></pre><p>This function plots a circular arc, centered at <code>origin</code> with radius <code>radius</code>, from <code>start_angle</code> to <code>stop_angle</code>. <code>origin</code> must be a coordinate in 2 dimensions (i.e., a <code>Point2</code>); the rest of the arguments must be <code>&lt;: Number</code>.</p><p>Examples:</p><p><code>arc(Point2f(0), 1, 0.0, π)</code><code>arc(Point2f(1, 2), 0.3. π, -π)</code></p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.arc, T} where T</code> are: </p><pre><code>  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  cycle           [:color]
  diffuse         Float32[0.4, 0.4, 0.4]
  inspectable     true
  lightposition   :eyeposition
  linestyle       "nothing"
  linewidth       1.5
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  resolution      361
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="arc!"><a href="#arc!">arc!</a></div><div class="doc-content"><pre><code>arc(origin, radius, start_angle, stop_angle; kwargs...)</code></pre><p>This function plots a circular arc, centered at <code>origin</code> with radius <code>radius</code>, from <code>start_angle</code> to <code>stop_angle</code>. <code>origin</code> must be a coordinate in 2 dimensions (i.e., a <code>Point2</code>); the rest of the arguments must be <code>&lt;: Number</code>.</p><p>Examples:</p><p><code>arc(Point2f(0), 1, 0.0, π)</code><code>arc(Point2f(1, 2), 0.3. π, -π)</code></p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.arc!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="arrows"><a href="#arrows">arrows</a></div><div class="doc-content"><pre><code>arrows(points, directions; kwargs...)
arrows(x, y, u, v)
arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)
arrows(x, y, z, u, v, w)</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each 'row' is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.arrows, T} where T</code> are: </p><pre><code>  align           :origin
  ambient         Float32[0.55, 0.55, 0.55]
  arrowcolor      MakieCore.Automatic()
  arrowhead       MakieCore.Automatic()
  arrowsize       MakieCore.Automatic()
  arrowtail       MakieCore.Automatic()
  color           :black
  colormap        :viridis
  diffuse         Float32[0.4, 0.4, 0.4]
  inspectable     true
  lengthscale     1.0f0
  lightposition   :eyeposition
  linecolor       MakieCore.Automatic()
  linestyle       "nothing"
  linewidth       MakieCore.Automatic()
  markerspace     MakieCore.Pixel
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  normalize       false
  overdraw        false
  quality         32
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="arrows!"><a href="#arrows!">arrows!</a></div><div class="doc-content"><pre><code>arrows(points, directions; kwargs...)
arrows(x, y, u, v)
arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)
arrows(x, y, z, u, v, w)</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each 'row' is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.arrows!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="assetpath"><a href="#assetpath">assetpath</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.assetpath</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "assetpath":
[1] assetpath(files...) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/Makie.jl:248</code></pre></div></div><div class="docstring"><div class="doc-header" id="attributes"><a href="#attributes">attributes</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.attributes</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "attributes":
[1] attributes(x::MakieCore.Attributes) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/attributes.jl:33</code></pre></div></div><div class="docstring"><div class="doc-header" id="autolimits!"><a href="#autolimits!">autolimits!</a></div><div class="doc-content"><pre><code>autolimits!(la::Axis)</code></pre><p>Reset manually specified limits of <code>la</code> to an automatically determined rectangle, that depends on the data limits of all plot objects in the axis, as well as the autolimit margins for x and y axis.</p></div></div><div class="docstring"><div class="doc-header" id="available_gradients"><a href="#available_gradients">available_gradients</a></div><div class="doc-content"><pre><code>available_gradients()</code></pre><p>Prints all available gradient names.</p></div></div><div class="docstring"><div class="doc-header" id="axis3d"><a href="#axis3d">axis3d</a></div><div class="doc-content"><pre><code class="language-julia">axis3d(args; attributes...)
</code></pre><p>Plots a 3-dimensional OldAxis.</p><h2>Attributes</h2><p>OldAxis attributes and their defaults for <code>MakieCore.Combined{Makie.axis3d, T} where T</code> are: </p><pre><code>    showaxis: (true, true, true)
    showgrid: (true, true, true)
    padding: 0.1
    visible: true
    ticks: 
        rotation: (-0.7071067811865475 + -0.0im + -0.0jm - 0.7071067811865476km, -4.371139e-8 + 0.0im + 0.0jm + 1.0km, -3.090861907263062e-8 + 3.090861907263061e-8im + 0.7071067811865475jm + 0.7071067811865476km)
        font: ("Dejavu Sans", "Dejavu Sans", "Dejavu Sans")
        ranges_labels: (MakieCore.Automatic(), MakieCore.Automatic())
        formatter: plain
        textcolor: (RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.6f0))
        align: ((:left, :center), (:right, :center), (:right, :center))
        textsize: (5, 5, 5)
        gap: 3
    frame: 
        axiscolor: (:black, :black, :black)
        axislinewidth: (1.5, 1.5, 1.5)
        linewidth: (1, 1, 1)
        linecolor: (RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0), RGBA{Float32}(0.5f0,0.5f0,0.5f0,0.4f0))
    names: 
        axisnames: ("x", "y", "z")
        rotation: (-0.7071067811865475 + -0.0im + -0.0jm - 0.7071067811865476km, -4.371139e-8 + 0.0im + 0.0jm + 1.0km, -3.090861907263062e-8 + 3.090861907263061e-8im + 0.7071067811865475jm + 0.7071067811865476km)
        font: ("Dejavu Sans", "Dejavu Sans", "Dejavu Sans")
        textcolor: (:black, :black, :black)
        align: ((:left, :center), (:right, :center), (:right, :center))
        textsize: (6.0, 6.0, 6.0)
        gap: 3
    inspectable: false
    showticks: (true, true, true)
    scale: Float32[1.0, 1.0, 1.0]</code></pre></div></div><div class="docstring"><div class="doc-header" id="axis3d!"><a href="#axis3d!">axis3d!</a></div><div class="doc-content"><pre><code class="language-julia">axis3d!(args; attributes...)
</code></pre><p>Plots a 3-dimensional OldAxis.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.axis3d!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="axislegend"><a href="#axislegend">axislegend</a></div><div class="doc-content"><pre><code>axislegend(ax, args...; position = :rt, kwargs...)
axislegend(ax, args...; position = (1, 1), kwargs...)
axislegend(ax = current_axis(); kwargs...)
axislegend(title::AbstractString; kwargs...)</code></pre><p>Create a legend that sits inside an Axis's plot area.</p><p>The position can be a Symbol where the first letter controls the horizontal alignment and can be l, r or c, and the second letter controls the vertical alignment and can be t, b or c. Or it can be a tuple where the first element is set as the Legend's halign and the second element as its valign.</p></div></div><div class="docstring"><div class="doc-header" id="band"><a href="#band">band</a></div><div class="doc-content"><pre><code>band(x, ylower, yupper; kwargs...)
band(lower, upper; kwargs...)</code></pre><p>Plots a band from <code>ylower</code> to <code>yupper</code> along <code>x</code>. The form <code>band(lower, upper)</code> plots a <a href="https://en.wikipedia.org/wiki/Ruled_surface">ruled surface</a> between the points in <code>lower</code> and <code>upper</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.band, T} where T</code> are: </p><pre><code>  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  cycle           [:color =&gt; :patchcolor]
  diffuse         Float32[0.4, 0.4, 0.4]
  inspectable     true
  interpolate     false
  lightposition   :eyeposition
  linewidth       1
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shading         true
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="band!"><a href="#band!">band!</a></div><div class="doc-content"><pre><code>band(x, ylower, yupper; kwargs...)
band(lower, upper; kwargs...)</code></pre><p>Plots a band from <code>ylower</code> to <code>yupper</code> along <code>x</code>. The form <code>band(lower, upper)</code> plots a <a href="https://en.wikipedia.org/wiki/Ruled_surface">ruled surface</a> between the points in <code>lower</code> and <code>upper</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.band!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="barplot"><a href="#barplot">barplot</a></div><div class="doc-content"><pre><code>barplot(x, y; kwargs...)</code></pre><p>Plots a barplot; <code>y</code> defines the height.  <code>x</code> and <code>y</code> should be 1 dimensional.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.barplot, T} where T</code> are: </p><pre><code>  bar_labels             "nothing"
  color                  RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  color_over_background  MakieCore.Automatic()
  color_over_bar         MakieCore.Automatic()
  colormap               :viridis
  colorrange             MakieCore.Automatic()
  cycle                  [:color =&gt; :patchcolor]
  direction              :y
  dodge                  MakieCore.Automatic()
  dodge_gap              0.03
  fillto                 MakieCore.Automatic()
  flip_labels_at         Inf
  inspectable            true
  label_color            :black
  label_font             "Dejavu Sans"
  label_formatter        Makie.bar_label_formatter
  label_offset           5
  label_size             20
  marker                 GeometryBasics.HyperRectangle
  n_dodge                MakieCore.Automatic()
  offset                 0.0
  stack                  MakieCore.Automatic()
  strokecolor            :black
  strokewidth            0
  visible                true
  width                  MakieCore.Automatic()
  x_gap                  0.2</code></pre></div></div><div class="docstring"><div class="doc-header" id="barplot!"><a href="#barplot!">barplot!</a></div><div class="doc-content"><pre><code>barplot(x, y; kwargs...)</code></pre><p>Plots a barplot; <code>y</code> defines the height.  <code>x</code> and <code>y</code> should be 1 dimensional.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.barplot!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="bottom"><a href="#bottom">bottom</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.MakieLayout.bottom</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "bottom":
[1] bottom(rect::GeometryBasics.Rect2{T} where T) in Makie.MakieLayout at /home/runner/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:4</code></pre></div></div><div class="docstring"><div class="doc-header" id="boundingbox"><a href="#boundingbox">boundingbox</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.boundingbox</code> is a <code>Function</code>.</p><pre><code># 7 methods for generic function "boundingbox":
[1] boundingbox(scene::Makie.Scene) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:43
[2] boundingbox(glyphcollection::Makie.GlyphCollection, position::GeometryBasics.Point{3, Float32}, rotation::Makie.Quaternion) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:99
[3] boundingbox(layouts::AbstractArray{var"#s739", N} where {var"#s739"&lt;:Makie.GlyphCollection, N}, positions, rotations) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:125
[4] boundingbox(x::MakieCore.Text{var"#s739"} where var"#s739"&lt;:(Tuple{var"#s738"} where var"#s738"&lt;:Makie.GlyphCollection)) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:143
[5] boundingbox(x::MakieCore.Text{var"#s739"} where var"#s739"&lt;:(Tuple{var"#s738"} where var"#s738"&lt;:(AbstractArray{var"#s737", N} where {var"#s737"&lt;:Makie.GlyphCollection, N}))) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:151
[6] boundingbox(x::Union{MakieCore.Text{Arg}, MakieCore.MeshScatter{Arg}, MakieCore.Scatter{Arg}, MakieCore.Mesh{Arg}, MakieCore.LineSegments{Arg}, MakieCore.Lines{Arg}, MakieCore.Surface{Arg}, MakieCore.Volume{Arg}, MakieCore.Heatmap{Arg}, MakieCore.Image{Arg}} where Arg) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:38
[7] boundingbox(x) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/layouting/boundingbox.jl:18</code></pre></div></div><div class="docstring"><div class="doc-header" id="boxplot"><a href="#boxplot">boxplot</a></div><div class="doc-content"><pre><code>boxplot(x, y; kwargs...)</code></pre><p>Draw a Tukey style boxplot. The boxplot has 3 components:</p><ul><li><p>a <code>crossbar</code> spanning the interquartile (IQR) range with a midline marking the   median</p></li><li><p>an <code>errorbar</code> whose whiskers span <code>range * iqr</code></p></li><li><p>points marking outliers, that is, data outside the whiskers</p></li></ul><h1>Arguments</h1><ul><li><p><code>x</code>: positions of the categories</p></li><li><p><code>y</code>: variables within the boxes</p></li></ul><h1>Keywords</h1><ul><li><p><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=0.8</code>: width of the box</p></li><li><p><code>show_notch=false</code>: draw the notch</p></li><li><p><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</p></li><li><p><code>show_median=true</code>: show median as midline</p></li><li><p><code>range</code>: multiple of IQR controlling whisker length</p></li><li><p><code>whiskerwidth</code>: multiplier of <code>width</code> for width of T's on whiskers, or   <code>:match</code> to match <code>width</code></p></li><li><p><code>show_outliers</code>: show outliers as points</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="boxplot!"><a href="#boxplot!">boxplot!</a></div><div class="doc-content"><pre><code>boxplot(x, y; kwargs...)</code></pre><p>Draw a Tukey style boxplot. The boxplot has 3 components:</p><ul><li><p>a <code>crossbar</code> spanning the interquartile (IQR) range with a midline marking the   median</p></li><li><p>an <code>errorbar</code> whose whiskers span <code>range * iqr</code></p></li><li><p>points marking outliers, that is, data outside the whiskers</p></li></ul><h1>Arguments</h1><ul><li><p><code>x</code>: positions of the categories</p></li><li><p><code>y</code>: variables within the boxes</p></li></ul><h1>Keywords</h1><ul><li><p><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=0.8</code>: width of the box</p></li><li><p><code>show_notch=false</code>: draw the notch</p></li><li><p><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</p></li><li><p><code>show_median=true</code>: show median as midline</p></li><li><p><code>range</code>: multiple of IQR controlling whisker length</p></li><li><p><code>whiskerwidth</code>: multiplier of <code>width</code> for width of T's on whiskers, or   <code>:match</code> to match <code>width</code></p></li><li><p><code>show_outliers</code>: show outliers as points</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="broadcast_foreach"><a href="#broadcast_foreach">broadcast_foreach</a></div><div class="doc-content"><pre><code>broadcast_foreach(f, args...)</code></pre><p>Like broadcast but for foreach. Doesn't care about shape and treats Tuples &amp;&amp; StaticVectors as scalars. This method is meant for broadcasting across attributes that can either have scalar or vector / array form. An example would be a collection of scatter markers that have different sizes but a single color. The length of an attribute is determined with <code>attr_broadcast_length</code> and elements are accessed with <code>attr_broadcast_getindex</code>.</p></div></div><div class="docstring"><div class="doc-header" id="cam2d"><a href="#cam2d">cam2d</a></div><div class="doc-content"><p>Creates a subscene with a pixel camera</p></div></div><div class="docstring"><div class="doc-header" id="cam2d!"><a href="#cam2d!">cam2d!</a></div><div class="doc-content"><pre><code>cam2d!(scene::SceneLike, kwargs...)</code></pre><p>Creates a 2D camera for the given Scene.</p></div></div><div class="docstring"><div class="doc-header" id="cam3d!"><a href="#cam3d!">cam3d!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.cam3d!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "cam3d!":
[1] cam3d!(scene; zoom_shift_lookat, fixed_axis, kwargs...) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/camera/camera3d.jl:223</code></pre></div></div><div class="docstring"><div class="doc-header" id="cam3d_cad!"><a href="#cam3d_cad!">cam3d_cad!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.cam3d_cad!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "cam3d_cad!":
[1] cam3d_cad!(scene; cad, zoom_shift_lookat, fixed_axis, kwargs...) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/camera/camera3d.jl:226</code></pre></div></div><div class="docstring"><div class="doc-header" id="camera"><a href="#camera">camera</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.camera</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "camera":
[1] camera(scene::Makie.Scene) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:404
[2] camera(scene::Union{MakieCore.AbstractScene, MakieCore.ScenePlot}) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:405</code></pre></div></div><div class="docstring"><div class="doc-header" id="cameracontrols"><a href="#cameracontrols">cameracontrols</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.cameracontrols</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "cameracontrols":
[1] cameracontrols(scene::Makie.Scene) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:407
[2] cameracontrols(scene::Union{MakieCore.AbstractScene, MakieCore.ScenePlot}) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:408</code></pre></div></div><div class="docstring"><div class="doc-header" id="cameracontrols!"><a href="#cameracontrols!">cameracontrols!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.cameracontrols!</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "cameracontrols!":
[1] cameracontrols!(scene::Makie.Scene, cam) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:410
[2] cameracontrols!(scene::Union{MakieCore.AbstractScene, MakieCore.ScenePlot}, cam) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:411</code></pre></div></div><div class="docstring"><div class="doc-header" id="campixel"><a href="#campixel">campixel</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.campixel</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "campixel":
[1] campixel(scene::Makie.Scene) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:322</code></pre></div></div><div class="docstring"><div class="doc-header" id="campixel!"><a href="#campixel!">campixel!</a></div><div class="doc-content"><pre><code>campixel!(scene)</code></pre><p>Creates a pixel-level camera for the <code>Scene</code>.  No controls!</p></div></div><div class="docstring"><div class="doc-header" id="center!"><a href="#center!">center!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.center!</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "center!":
[1] center!(scene::Makie.Scene) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:484
[2] center!(scene::Makie.Scene, padding) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:484</code></pre></div></div><div class="docstring"><div class="doc-header" id="cgrad"><a href="#cgrad">cgrad</a></div><div class="doc-content"><pre><code>cgrad(colors, [values]; categorical = nothing, scale = nothing, rev = false, alpha = nothing)</code></pre><p>Construct a Colorgradient with from <code>colors</code> and <code>values</code>.</p><p><code>colors</code> can be a symbol for Colorschemes.jl <code>ColorScheme</code>s, a <code>ColorScheme</code>, a vectors of colors, a <code>ColorGradient</code> or a <code>ColorPalettes</code>. If <code>values</code> is an integer, it specifies the numbers of colors chosen equidistantly from the colorscheme specified by colors. Otherwise vectors are accepted. For continuous color gradients <code>values</code> indicate where between 0 and 1 the colors are positioned. For categorical color gradients <code>values</code> indicate where a color ends and where a new one begins between 0 and 1. 0 and 1 are added to <code>values</code> if not already present.</p><p>If <code>rev</code> is <code>true</code> colors are reversed. <code>scale</code> accepts the symbols <code>:log</code>, <code>:log10</code>, <code>:log2</code>, <code>:ln</code>, <code>:exp</code>, <code>:exp10</code> or functions. If <code>alpha</code> is set, it is applied to all colors.</p></div></div><div class="docstring"><div class="doc-header" id="colgap!"><a href="#colgap!">colgap!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.colgap!</code> is a <code>Function</code>.</p><pre><code># 4 methods for generic function "colgap!":
[1] colgap!(gl::GridLayoutBase.GridLayout, i::Int64, s::GridLayoutBase.GapSize) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:572
[2] colgap!(gl::GridLayoutBase.GridLayout, i::Int64, s::Real) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:580
[3] colgap!(gl::GridLayoutBase.GridLayout, s::GridLayoutBase.GapSize) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:582
[4] colgap!(gl::GridLayoutBase.GridLayout, r::Real) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:587</code></pre></div></div><div class="docstring"><div class="doc-header" id="colsize!"><a href="#colsize!">colsize!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.colsize!</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "colsize!":
[1] colsize!(gl::GridLayoutBase.GridLayout, i::Int64, s::GridLayoutBase.ContentSize) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:552
[2] colsize!(gl::GridLayoutBase.GridLayout, i::Int64, s::Real) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:560</code></pre></div></div><div class="docstring"><div class="doc-header" id="connect!"><a href="#connect!">connect!</a></div><div class="doc-content"><pre><code>connect!(o1::AbstractObservable, o2::AbstractObservable)</code></pre><p>Forwards all updates from <code>o2</code> to <code>o1</code>.</p><p>See also <a href="@ref"><code>Observables.ObservablePair</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="content"><a href="#content">content</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.content</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "content":
[1] content(g::Union{GridLayoutBase.GridPosition, GridLayoutBase.GridSubposition}) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:1364</code></pre></div></div><div class="docstring"><div class="doc-header" id="contents"><a href="#contents">contents</a></div><div class="doc-content"><pre><code>contents(gp::GridPosition; exact::Bool = false)</code></pre><p>Retrieve all objects placed in the <code>GridLayout</code> at the <code>Span</code> and <code>Side</code> stored in the <code>GridPosition</code><code>gp</code>. If <code>exact == true</code>, elements are only included if they match the <code>Span</code> exactly, otherwise they can also be contained within the spanned layout area.</p><pre><code>contents(g::GridLayout)</code></pre><p>Retrieve all objects placed in the <code>GridLayout</code><code>g</code>, in the order they are stored, extracted from their containing <code>GridContent</code>s.</p></div></div><div class="docstring"><div class="doc-header" id="contour"><a href="#contour">contour</a></div><div class="doc-content"><pre><code>contour(x, y, z)
contour(z::Matrix)</code></pre><p>Creates a contour plot of the plane spanning x::Vector, y::Vector, z::Matrix If only <code>z::Matrix</code> is supplied, the indices of the elements in <code>z</code> will be used as the x and y locations when plotting the contour.</p><p>The attribute levels can be either</p><pre><code>an Int that produces n equally wide levels or bands

an AbstractVector{&lt;:Real} that lists n consecutive edges from low to high, which result in n-1 levels or bands</code></pre><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.contour, T} where T</code> are: </p><pre><code>  alpha           1.0
  ambient         Float32[0.55, 0.55, 0.55]
  color           "nothing"
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  diffuse         Float32[0.4, 0.4, 0.4]
  fillrange       false
  inspectable     true
  levels          5
  lightposition   :eyeposition
  linewidth       1.0
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="contour!"><a href="#contour!">contour!</a></div><div class="doc-content"><pre><code>contour(x, y, z)
contour(z::Matrix)</code></pre><p>Creates a contour plot of the plane spanning x::Vector, y::Vector, z::Matrix If only <code>z::Matrix</code> is supplied, the indices of the elements in <code>z</code> will be used as the x and y locations when plotting the contour.</p><p>The attribute levels can be either</p><pre><code>an Int that produces n equally wide levels or bands

an AbstractVector{&lt;:Real} that lists n consecutive edges from low to high, which result in n-1 levels or bands</code></pre><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.contour!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="contour3d"><a href="#contour3d">contour3d</a></div><div class="doc-content"><pre><code>contour3d(x, y, z)</code></pre><p>Creates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.contour3d, T} where T</code> are: </p><pre><code>  alpha           1.0
  ambient         Float32[0.55, 0.55, 0.55]
  color           "nothing"
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  diffuse         Float32[0.4, 0.4, 0.4]
  fillrange       false
  inspectable     true
  levels          5
  lightposition   :eyeposition
  linewidth       1.0
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="contour3d!"><a href="#contour3d!">contour3d!</a></div><div class="doc-content"><pre><code>contour3d(x, y, z)</code></pre><p>Creates a 3D contour plot of the plane spanning x::Vector, y::Vector, z::Matrix, with z-elevation for each level.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.contour3d!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="contourf"><a href="#contourf">contourf</a></div><div class="doc-content"><pre><code>contourf(xs, ys, zs; kwargs...)</code></pre><p>Plots a filled contour of the height information in <code>zs</code> at horizontal grid positions <code>xs</code> and vertical grid positions <code>ys</code>.</p><p>The attribute <code>levels</code> can be either</p><ul><li><p>an <code>Int</code> that produces n equally wide levels or bands</p></li><li><p>an <code>AbstractVector{&lt;:Real}</code> that lists n consecutive edges from low to high, which result in n-1 levels or bands</p></li></ul><p>You can also set the <code>mode</code> attribute to <code>:relative</code>. In this mode you specify edges by the fraction between minimum and maximum value of <code>zs</code>. This can be used for example to draw bands for the upper 90% while excluding the lower 10% with <code>levels = 0.1:0.1:1.0, mode = :relative</code>.</p><p>In :normal mode, if you want to show a band from <code>-Inf</code> to the low edge, set <code>extendlow</code> to <code>:auto</code> for the same color as the first level, or specify a different color (default <code>nothing</code> means no extended band) If you want to show a band from the high edge to <code>Inf</code>, set <code>extendhigh</code> to <code>:auto</code> for the same color as the last level, or specify a different color (default <code>nothing</code> means no extended band)</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.contourf, T} where T</code> are: </p><pre><code>  colormap     :viridis
  extendhigh   "nothing"
  extendlow    "nothing"
  inspectable  true
  levels       10
  mode         :normal</code></pre></div></div><div class="docstring"><div class="doc-header" id="contourf!"><a href="#contourf!">contourf!</a></div><div class="doc-content"><pre><code>contourf(xs, ys, zs; kwargs...)</code></pre><p>Plots a filled contour of the height information in <code>zs</code> at horizontal grid positions <code>xs</code> and vertical grid positions <code>ys</code>.</p><p>The attribute <code>levels</code> can be either</p><ul><li><p>an <code>Int</code> that produces n equally wide levels or bands</p></li><li><p>an <code>AbstractVector{&lt;:Real}</code> that lists n consecutive edges from low to high, which result in n-1 levels or bands</p></li></ul><p>You can also set the <code>mode</code> attribute to <code>:relative</code>. In this mode you specify edges by the fraction between minimum and maximum value of <code>zs</code>. This can be used for example to draw bands for the upper 90% while excluding the lower 10% with <code>levels = 0.1:0.1:1.0, mode = :relative</code>.</p><p>In :normal mode, if you want to show a band from <code>-Inf</code> to the low edge, set <code>extendlow</code> to <code>:auto</code> for the same color as the first level, or specify a different color (default <code>nothing</code> means no extended band) If you want to show a band from the high edge to <code>Inf</code>, set <code>extendhigh</code> to <code>:auto</code> for the same color as the last level, or specify a different color (default <code>nothing</code> means no extended band)</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.contourf!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="convert_arguments"><a href="#convert_arguments">convert_arguments</a></div><div class="doc-content"><p>Wrap a single point or equivalent object in a single-element array.</p><p>Enables to use scatter like a surface plot with x::Vector, y::Vector, z::Matrix spanning z over the grid spanned by x y</p><pre><code>convert_arguments(P, x, y, z)::(Vector)</code></pre><p>Takes vectors <code>x</code>, <code>y</code>, and <code>z</code> and turns it into a vector of 3D points of the values from <code>x</code>, <code>y</code>, and <code>z</code>. <code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input GeometryPrimitive <code>x</code> and decomposes it to points. <code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, y)::Vector</code></pre><p>Takes vector <code>y</code> and generates a range from 1 to the length of <code>y</code>, for plotting on an arbitrary <code>x</code> axis.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x)::(Vector)</code></pre><p>Takes an input <code>Rect</code><code>x</code> and decomposes it to points.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(PB, LineString)</code></pre><p>Takes an input <code>LineString</code> and decomposes it to points.</p><pre><code>convert_arguments(PB, Union{Array{&lt;:LineString}, MultiLineString})</code></pre><p>Takes an input <code>Array{LineString}</code> or a <code>MultiLineString</code> and decomposes it to points.</p><pre><code>convert_arguments(PB, Polygon)</code></pre><p>Takes an input <code>Polygon</code> and decomposes it to points.</p><pre><code>convert_arguments(PB, Union{Array{&lt;:Polygon}, MultiPolygon})</code></pre><p>Takes an input <code>Array{Polygon}</code> or a <code>MultiPolygon</code> and decomposes it to points.</p><pre><code>convert_arguments(SL::SurfaceLike, x::VecOrMat, y::VecOrMat, z::Matrix)</code></pre><p>If <code>SL</code> is <code>Heatmap</code> and <code>x</code> and <code>y</code> are vectors, infer from length of <code>x</code> and <code>y</code> whether they represent edges or centers of the heatmap bins. If they are centers, convert to edges. Convert eltypes to <code>Float32</code> and return outputs as a <code>Tuple</code>.</p><pre><code>convert_arguments(P, x, y, z)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes 2 ClosedIntervals's <code>x</code>, <code>y</code>, and an AbstractMatrix <code>z</code>, and converts the closed range to linspaces with size(z, 1/2) <code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an <code>AbstractMatrix</code>, converts the dimesions <code>n</code> and <code>m</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code> and <code>m</code>, plus the original matrix in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x, y, f)::(Vector, Vector, Matrix)</code></pre><p>Takes vectors <code>x</code> and <code>y</code> and the function <code>f</code>, and applies <code>f</code> on the grid that <code>x</code> and <code>y</code> span. This is equivalent to <code>f.(x, y')</code>. <code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, Matrix)::Tuple{ClosedInterval, ClosedInterval, ClosedInterval, Matrix}</code></pre><p>Takes an array of <code>{T, 3} where T</code>, converts the dimesions <code>n</code>, <code>m</code> and <code>k</code> into <code>ClosedInterval</code>, and stores the <code>ClosedInterval</code> to <code>n</code>, <code>m</code> and <code>k</code>, plus the original array in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x, y, z, i)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes 3 <code>AbstractVector</code><code>x</code>, <code>y</code>, and <code>z</code> and the <code>AbstractMatrix</code><code>i</code>, and puts everything in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p><pre><code>convert_arguments(P, x, y, z, f)::(Vector, Vector, Vector, Matrix)</code></pre><p>Takes <code>AbstractVector</code><code>x</code>, <code>y</code>, and <code>z</code> and the function <code>f</code>, evaluates <code>f</code> on the volume spanned by <code>x</code>, <code>y</code> and <code>z</code>, and puts <code>x</code>, <code>y</code>, <code>z</code> and <code>f(x,y,z)</code> in a Tuple.</p><p><code>P</code> is the plot Type (it is optional).</p><p>Accepts a Vector of Pair of Points (e.g. <code>[Point(0, 0) =&gt; Point(1, 1), ...]</code>) to encode e.g. linesegments or directions.</p><pre><code>convert_arguments(Mesh, x, y, z)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a mesh out of those, under the assumption that every 3 points form a triangle.</p><pre><code>convert_arguments(Mesh, xyz::AbstractVector)::GLNormalMesh</code></pre><p>Takes an input mesh and a vector <code>xyz</code> representing the vertices of the mesh, and creates indices under the assumption, that each triplet in <code>xyz</code> forms a triangle.</p><pre><code>convert_arguments(Mesh, x, y, z, indices)::GLNormalMesh</code></pre><p>Takes real vectors x, y, z and constructs a triangle mesh out of those, using the faces in <code>indices</code>, which can be integers (every 3 -&gt; one triangle), or GeometryBasics.NgonFace{N, &lt;: Integer}.</p><pre><code>convert_arguments(Mesh, vertices, indices)::GLNormalMesh</code></pre><p>Takes <code>vertices</code> and <code>indices</code>, and creates a triangle mesh out of those. See <a href="@ref"><code>to_vertices</code></a> and <a href="@ref"><code>to_triangles</code></a> for more information about accepted types.</p></div></div><div class="docstring"><div class="doc-header" id="convert_attribute"><a href="#convert_attribute">convert_attribute</a></div><div class="doc-content"><pre><code>`AbstractVector{&lt;:AbstractFloat}` for denoting sequences of fill/nofill. e.g.</code></pre><p>[0.5, 0.8, 1.2] will result in 0.5 filled, 0.3 unfilled, 0.4 filled. 1.0 unit is one linewidth!</p><pre><code>A `Symbol` equal to `:dash`, `:dot`, `:dashdot`, `:dashdotdot`</code></pre><pre><code>Text align, e.g.:</code></pre><pre><code>font conversion</code></pre><p>a string naming a font, e.g. helvetica</p><pre><code>rotation accepts:
to_rotation(b, quaternion)
to_rotation(b, tuple_float)
to_rotation(b, vec4)</code></pre><pre><code>to_colormap(b, x)</code></pre><p>An <code>AbstractVector{T}</code> with any object that <a href="@ref"><code>to_color</code></a> accepts.</p><p>Tuple(A, B) or Pair{A, B} with any object that <a href="@ref"><code>to_color</code></a> accepts</p><p>A Symbol/String naming the gradient. For more on what names are available please see: <code>available_gradients()</code>. For now, we support gradients from <code>PlotUtils</code> natively.</p><pre><code>to_volume_algorithm(b, x)</code></pre><p>Enum values: <code>IsoValue</code><code>Absorption</code><code>MaximumIntensityProjection</code><code>AbsorptionRGBA</code><code>AdditiveRGBA</code><code>IndexedAbsorptionRGBA</code></p><p>Symbol/String: iso, absorption, mip, absorptionrgba, indexedabsorption</p></div></div><div class="docstring"><div class="doc-header" id="crossbar"><a href="#crossbar">crossbar</a></div><div class="doc-content"><pre><code>crossbar(x, y, ymin, ymax; kwargs...)</code></pre><p>Draw a crossbar. A crossbar represents a range with a (potentially notched) box. It is most commonly used as part of the <code>boxplot</code>.</p><h1>Arguments</h1><ul><li><p><code>x</code>: position of the box</p></li><li><p><code>y</code>: position of the midline within the box</p></li><li><p><code>ymin</code>: lower limit of the box</p></li><li><p><code>ymax</code>: upper limit of the box</p></li></ul><h1>Keywords</h1><ul><li><p><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=0.8</code>: width of the box</p></li><li><p><code>show_notch=false</code>: draw the notch</p></li><li><p><code>notchmin=automatic</code>: lower limit of the notch</p></li><li><p><code>notchmax=automatic</code>: upper limit of the notch</p></li><li><p><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</p></li><li><p><code>show_midline=true</code>: show midline</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="crossbar!"><a href="#crossbar!">crossbar!</a></div><div class="doc-content"><pre><code>crossbar(x, y, ymin, ymax; kwargs...)</code></pre><p>Draw a crossbar. A crossbar represents a range with a (potentially notched) box. It is most commonly used as part of the <code>boxplot</code>.</p><h1>Arguments</h1><ul><li><p><code>x</code>: position of the box</p></li><li><p><code>y</code>: position of the midline within the box</p></li><li><p><code>ymin</code>: lower limit of the box</p></li><li><p><code>ymax</code>: upper limit of the box</p></li></ul><h1>Keywords</h1><ul><li><p><code>orientation=:vertical</code>: orientation of box (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=0.8</code>: width of the box</p></li><li><p><code>show_notch=false</code>: draw the notch</p></li><li><p><code>notchmin=automatic</code>: lower limit of the notch</p></li><li><p><code>notchmax=automatic</code>: upper limit of the notch</p></li><li><p><code>notchwidth=0.5</code>: multiplier of <code>width</code> for narrowest width of notch</p></li><li><p><code>show_midline=true</code>: show midline</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="current_axis"><a href="#current_axis">current_axis</a></div><div class="doc-content"><p>Returns the current active axis (or the last axis that got created)</p></div></div><div class="docstring"><div class="doc-header" id="current_axis!"><a href="#current_axis!">current_axis!</a></div><div class="doc-content"><p>Set <code>ax</code> as the current active axis in <code>fig</code></p></div></div><div class="docstring"><div class="doc-header" id="current_figure"><a href="#current_figure">current_figure</a></div><div class="doc-content"><p>Returns the current active figure (or the last figure that got created)</p></div></div><div class="docstring"><div class="doc-header" id="current_figure!"><a href="#current_figure!">current_figure!</a></div><div class="doc-content"><p>Set <code>fig</code> as the current active scene</p></div></div><div class="docstring"><div class="doc-header" id="deactivate_interaction!"><a href="#deactivate_interaction!">deactivate_interaction!</a></div><div class="doc-content"><pre><code>deactivate_interaction!(parent, name::Symbol)</code></pre><p>Deactivate the interaction named <code>name</code> registered in <code>parent</code>. It can be reactivated with <code>activate_interaction!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="decompose"><a href="#decompose">decompose</a></div><div class="doc-content"><pre><code>decompose(facetype, contour::AbstractArray{AbstractPoint})</code></pre><p>Triangulate a Polygon without hole.</p><p>Returns a Vector{<code>facetype</code>} defining indexes into <code>contour</code>.</p></div></div><div class="docstring"><div class="doc-header" id="default_theme"><a href="#default_theme">default_theme</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.default_theme</code> is a <code>Function</code>.</p><pre><code># 43 methods for generic function "default_theme":
[1] default_theme(scene) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/interfaces.jl:3
[2] default_theme(scene, ::Type{var"#s736"} where var"#s736"&lt;:(MakieCore.Combined{Makie.violin, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[3] default_theme(scene, ::Type{var"#s27"} where var"#s27"&lt;:(MakieCore.Image{ArgType} where ArgType)) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[4] default_theme(scene, ::Type{var"#s14"} where var"#s14"&lt;:(MakieCore.Heatmap{ArgType} where ArgType)) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[5] default_theme(scene, ::Type{var"#s14"} where var"#s14"&lt;:(MakieCore.Volume{ArgType} where ArgType)) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[6] default_theme(scene, ::Type{var"#s14"} where var"#s14"&lt;:(MakieCore.Surface{ArgType} where ArgType)) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[7] default_theme(scene, ::Type{var"#s14"} where var"#s14"&lt;:(MakieCore.Lines{ArgType} where ArgType)) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[8] default_theme(scene, ::Type{var"#s14"} where var"#s14"&lt;:(MakieCore.LineSegments{ArgType} where ArgType)) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[9] default_theme(scene, ::Type{var"#s14"} where var"#s14"&lt;:(MakieCore.Mesh{ArgType} where ArgType)) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[10] default_theme(scene, ::Type{var"#s14"} where var"#s14"&lt;:(MakieCore.Scatter{ArgType} where ArgType)) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[11] default_theme(scene, ::Type{var"#s14"} where var"#s14"&lt;:(MakieCore.MeshScatter{ArgType} where ArgType)) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[12] default_theme(scene, ::Type{var"#s14"} where var"#s14"&lt;:(MakieCore.Text{ArgType} where ArgType)) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[13] default_theme(scene, ::Type{var"#s1316"} where var"#s1316"&lt;:(MakieCore.Combined{Makie.series, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[14] default_theme(scene, ::Type{var"#s736"} where var"#s736"&lt;:(MakieCore.Combined{Makie._inspector, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[15] default_theme(scene, ::Type{var"#s736"} where var"#s736"&lt;:(MakieCore.Combined{Makie.boxplot, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[16] default_theme(scene, ::Type{var"#s736"} where var"#s736"&lt;:(MakieCore.Combined{Makie.crossbar, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[17] default_theme(scene, ::Type{var"#s736"} where var"#s736"&lt;:(MakieCore.Combined{Makie.qqplot, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[18] default_theme(scene, ::Type{var"#s736"} where var"#s736"&lt;:(MakieCore.Combined{Makie.qqnorm, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[19] default_theme(scene, ::Type{var"#s736"} where var"#s736"&lt;:(MakieCore.Combined{Makie.density, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[20] default_theme(scene, ::Type{var"#s736"} where var"#s736"&lt;:(MakieCore.Combined{Makie.hist, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[21] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.wireframe, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[22] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.volumeslices, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[23] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.timeseries, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[24] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.streamplot, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[25] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.stem, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[26] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.stairs, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[27] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.spy, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[28] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.scatterlines, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[29] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.poly, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[30] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.pie, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[31] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.rangebars, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[32] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.errorbars, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[33] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.contourf, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[34] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.contour3d, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[35] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.contour, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[36] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.barplot, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[37] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.band, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[38] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.axis3d, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[39] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.annotations, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[40] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.arc, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[41] default_theme(scene, ::Type{var"#s265"} where var"#s265"&lt;:(MakieCore.Combined{Makie.arrows, ArgType} where ArgType)) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[42] default_theme(scene, ::Type{var"#s45"} where var"#s45"&lt;:(MakieCore.Combined{Main.FD_SANDBOX_3118400072356428703.stockchart, ArgType} where ArgType)) in Main.FD_SANDBOX_3118400072356428703 at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:174
[43] default_theme(scene, T) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:60</code></pre></div></div><div class="docstring"><div class="doc-header" id="density"><a href="#density">density</a></div><div class="doc-content"><pre><code>density(values; npoints = 200, offset = 0.0, direction = :x)</code></pre><p>Plot a kernel density estimate of <code>values</code>. <code>npoints</code> controls the resolution of the estimate, the baseline can be shifted with <code>offset</code> and the <code>direction</code> set to :x or :y. <code>bandwidth</code> and <code>boundary</code> are determined automatically by default.</p><p><code>color</code> is usually set to a single color, but can also be set to <code>:x</code> or <code>:y</code> to color with a gradient. If you use <code>:y</code> when direction = <code>:x</code> (or vice versa), note that only 2-element colormaps can work correctly.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.density, T} where T</code> are: </p><pre><code>  bandwidth     MakieCore.Automatic()
  boundary      MakieCore.Automatic()
  color         RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  colormap      :viridis
  colorrange    MakieCore.Automatic()
  cycle         [:color =&gt; :patchcolor]
  direction     :x
  inspectable   true
  linestyle     "nothing"
  npoints       200
  offset        0.0
  strokearound  false
  strokecolor   :black
  strokewidth   0</code></pre></div></div><div class="docstring"><div class="doc-header" id="density!"><a href="#density!">density!</a></div><div class="doc-content"><pre><code>density(values; npoints = 200, offset = 0.0, direction = :x)</code></pre><p>Plot a kernel density estimate of <code>values</code>. <code>npoints</code> controls the resolution of the estimate, the baseline can be shifted with <code>offset</code> and the <code>direction</code> set to :x or :y. <code>bandwidth</code> and <code>boundary</code> are determined automatically by default.</p><p><code>color</code> is usually set to a single color, but can also be set to <code>:x</code> or <code>:y</code> to color with a gradient. If you use <code>:y</code> when direction = <code>:x</code> (or vice versa), note that only 2-element colormaps can work correctly.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.density!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="deregister_interaction!"><a href="#deregister_interaction!">deregister_interaction!</a></div><div class="doc-content"><pre><code>deregister_interaction!(parent, name::Symbol)</code></pre><p>Deregister the interaction named <code>name</code> registered in <code>parent</code>.</p></div></div><div class="docstring"><div class="doc-header" id="disconnect!"><a href="#disconnect!">disconnect!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.disconnect!</code> is a <code>Function</code>.</p><pre><code># 13 methods for generic function "disconnect!":
[1] disconnect!(c::Makie.Camera) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/camera/camera.jl:13
[2] disconnect!(nodes::Vector{T} where T) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/camera/camera.jl:21
[3] disconnect!(window::MakieCore.AbstractScreen, signal) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/interaction/events.jl:1
[4] disconnect!(window::GLFW.Window, ::typeof(Makie.entered_window)) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:287
[5] disconnect!(window::GLFW.Window, ::typeof(Makie.hasfocus)) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:265
[6] disconnect!(window::GLFW.Window, ::typeof(Makie.scroll)) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:242
[7] disconnect!(window::GLFW.Window, ::typeof(Makie.mouse_position)) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:220
[8] disconnect!(window::GLFW.Window, ::typeof(Makie.unicode_input)) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:154
[9] disconnect!(window::GLFW.Window, ::typeof(Makie.dropped_files)) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:131
[10] disconnect!(window::GLFW.Window, ::typeof(Makie.keyboard_buttons)) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:110
[11] disconnect!(window::GLFW.Window, ::typeof(Makie.mouse_buttons)) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:95
[12] disconnect!(window::GLFW.Window, ::typeof(Makie.window_area)) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:73
[13] disconnect!(window::GLFW.Window, ::typeof(Makie.window_open)) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:34</code></pre></div></div><div class="docstring"><div class="doc-header" id="dropped_files"><a href="#dropped_files">dropped_files</a></div><div class="doc-content"><p>Registers a callback for drag and drop of files. returns <code>Node{Vector{String}}</code>, which are absolute file paths <a href="http://www.glfw.org/docs/latest/group__input.html#gacc95e259ad21d4f666faa6280d4018fd">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="entered_window"><a href="#entered_window">entered_window</a></div><div class="doc-content"><p>Registers a callback for if the mouse has entered the window. returns an <code>Node{Bool}</code>, which is true whenever the cursor enters the window. <a href="http://www.glfw.org/docs/latest/group__input.html#ga762d898d9b0241d7e3e3b767c6cf318f">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="errorbars"><a href="#errorbars">errorbars</a></div><div class="doc-content"><pre><code>errorbars(x, y, error_both; kwargs...)
errorbars(x, y, error_low, error_high; kwargs...)
errorbars(x, y, error_low_high; kwargs...)

errorbars(xy, error_both; kwargs...)
errorbars(xy, error_low, error_high; kwargs...)
errorbars(xy, error_low_high; kwargs...)

errorbars(xy_error_both; kwargs...)
errorbars(xy_error_low_high; kwargs...)</code></pre><p>Plots errorbars at xy positions, extending by errors in the given <code>direction</code>.</p><p>If you want to plot intervals from low to high values instead of relative errors, use <code>rangebars</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.errorbars, T} where T</code> are: </p><pre><code>  color         :black
  colormap      :viridis
  direction     :y
  inspectable   true
  linewidth     1.5
  visible       true
  whiskerwidth  0</code></pre></div></div><div class="docstring"><div class="doc-header" id="errorbars!"><a href="#errorbars!">errorbars!</a></div><div class="doc-content"><pre><code>errorbars(x, y, error_both; kwargs...)
errorbars(x, y, error_low, error_high; kwargs...)
errorbars(x, y, error_low_high; kwargs...)

errorbars(xy, error_both; kwargs...)
errorbars(xy, error_low, error_high; kwargs...)
errorbars(xy, error_low_high; kwargs...)

errorbars(xy_error_both; kwargs...)
errorbars(xy_error_low_high; kwargs...)</code></pre><p>Plots errorbars at xy positions, extending by errors in the given <code>direction</code>.</p><p>If you want to plot intervals from low to high values instead of relative errors, use <code>rangebars</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.errorbars!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="events"><a href="#events">events</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.events</code> is a <code>Function</code>.</p><pre><code># 4 methods for generic function "events":
[1] events(scene::Makie.Scene) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:401
[2] events(scene::Union{MakieCore.AbstractScene, MakieCore.ScenePlot}) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:402
[3] events(fig::Makie.Figure) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/figures.jl:132
[4] events(fap::Makie.FigureAxisPlot) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/figures.jl:133</code></pre></div></div><div class="docstring"><div class="doc-header" id="fill_between!"><a href="#fill_between!">fill_between!</a></div><div class="doc-content"><pre><code>fill_between!(x, y1, y2; where = nothing, scene = current_scene(), kw_args...)</code></pre><p>fill the section between 2 lines with the condition <code>where</code></p></div></div><div class="docstring"><div class="doc-header" id="force_update!"><a href="#force_update!">force_update!</a></div><div class="doc-content"><p>Forces the scene to be re-rendered</p></div></div><div class="docstring"><div class="doc-header" id="grid!"><a href="#grid!">grid!</a></div><div class="doc-content"><pre><code>grid!(content::Vararg{Pair}; kwargs...)</code></pre><p>Creates a GridLayout with all pairs contained in <code>content</code>. Each pair consists of an iterable with row and column spans, and a content object. Each content object is then placed in the GridLayout at the span from its pair.</p><p>Example:</p><p>grid!(     [1, 1] =&gt; obj1,     [1, 2] =&gt; obj2,     [2, :] =&gt; obj3, )</p><pre><code>grid!(content::AbstractMatrix; kwargs...)</code></pre><p>Creates a GridLayout filled with matrix-like content. The size of the grid will be the size of the matrix.</p></div></div><div class="docstring"><div class="doc-header" id="gridnest!"><a href="#gridnest!">gridnest!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.gridnest!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "gridnest!":
[1] gridnest!(gl::GridLayoutBase.GridLayout, rows::Union{Colon, Int64, UnitRange}, cols::Union{Colon, Int64, UnitRange}) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:478</code></pre></div></div><div class="docstring"><div class="doc-header" id="hasfocus"><a href="#hasfocus">hasfocus</a></div><div class="doc-content"><p>Registers a callback for the focus of a window. returns an <code>Node{Bool}</code>, which is true whenever the window has focus. <a href="http://www.glfw.org/docs/latest/group__window.html#ga6b5f973531ea91663ad707ba4f2ac104">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="heatmap"><a href="#heatmap">heatmap</a></div><div class="doc-content"><pre><code>heatmap(x, y, values)
heatmap(values)</code></pre><p>Plots a heatmap as an image on <code>x, y</code> (defaults to interpretation as dimensions).</p></div></div><div class="docstring"><div class="doc-header" id="heatmap!"><a href="#heatmap!">heatmap!</a></div><div class="doc-content"><pre><code>heatmap(x, y, values)
heatmap(values)</code></pre><p>Plots a heatmap as an image on <code>x, y</code> (defaults to interpretation as dimensions).</p></div></div><div class="docstring"><div class="doc-header" id="height"><a href="#height">height</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.height</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "height":
[1] height(rect::GeometryBasics.Rect2{T} where T) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/geometry_integration.jl:7</code></pre></div></div><div class="docstring"><div class="doc-header" id="help"><a href="#help">help</a></div><div class="doc-content"><pre><code>help(func[; extended = false])</code></pre><p>Welcome to the main help function of <code>Makie.jl</code> / <code>Makie.jl</code>.</p><p>For help on a specific function's arguments, type <code>help_arguments(function_name)</code>.</p><p>For help on a specific function's attributes, type <code>help_attributes(plot_Type)</code>.</p><p>Use the optional <code>extended = true</code> keyword argument to see more details.</p></div></div><div class="docstring"><div class="doc-header" id="help_arguments"><a href="#help_arguments">help_arguments</a></div><div class="doc-content"><pre><code>help_arguments([io], func)</code></pre><p>Returns a list of signatures for function <code>func</code>.</p></div></div><div class="docstring"><div class="doc-header" id="help_attributes"><a href="#help_attributes">help_attributes</a></div><div class="doc-content"><pre><code>help_attributes([io], Union{PlotType, PlotFunction}; extended = false)</code></pre><p>Returns a list of attributes for the plot type <code>Typ</code>. The attributes returned extend those attributes found in the <code>default_theme</code>.</p><p>Use the optional keyword argument <code>extended</code> (default = <code>false</code>) to show in addition the default values of each attribute. usage:</p><pre><code class="language-julia">&gt;help_attributes(scatter)
    alpha
    color
    colormap
    colorrange
    distancefield
    glowcolor
    glowwidth
    linewidth
    marker
    marker_offset
    markersize
    overdraw
    rotations
    strokecolor
    strokewidth
    transform_marker
    transparency
    uv_offset_width
    visible</code></pre></div></div><div class="docstring"><div class="doc-header" id="hgrid!"><a href="#hgrid!">hgrid!</a></div><div class="doc-content"><pre><code>hbox!(content::Vararg; kwargs...)</code></pre><p>Creates a single-row GridLayout with all elements contained in <code>content</code> placed from left to right.</p></div></div><div class="docstring"><div class="doc-header" id="hidedecorations!"><a href="#hidedecorations!">hidedecorations!</a></div><div class="doc-content"><pre><code>hidedecorations!(la::Axis)</code></pre><p>Hide decorations of both x and y-axis: label, ticklabels, ticks and grid.</p></div></div><div class="docstring"><div class="doc-header" id="hidespines!"><a href="#hidespines!">hidespines!</a></div><div class="doc-content"><pre><code>hidespines!(la::Axis, spines::Symbol... = (:l, :r, :b, :t)...)</code></pre><p>Hide all specified axis spines. Hides all spines by default, otherwise choose with the symbols :l, :r, :b and :t.</p></div></div><div class="docstring"><div class="doc-header" id="hidexdecorations!"><a href="#hidexdecorations!">hidexdecorations!</a></div><div class="doc-content"><pre><code>hidexdecorations!(la::Axis; label = true, ticklabels = true, ticks = true, grid = true,
    minorgrid = true, minorticks = true)</code></pre><p>Hide decorations of the x-axis: label, ticklabels, ticks and grid.</p></div></div><div class="docstring"><div class="doc-header" id="hideydecorations!"><a href="#hideydecorations!">hideydecorations!</a></div><div class="doc-content"><pre><code>hideydecorations!(la::Axis; label = true, ticklabels = true, ticks = true, grid = true,
    minorgrid = true, minorticks = true)</code></pre><p>Hide decorations of the y-axis: label, ticklabels, ticks and grid.</p></div></div><div class="docstring"><div class="doc-header" id="hist"><a href="#hist">hist</a></div><div class="doc-content"><pre><code>hist(values; bins = 15, normalization = :none)</code></pre><p>Plot a histogram of <code>values</code>. <code>bins</code> can be an <code>Int</code> to create that number of equal-width bins over the range of <code>values</code>. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting <code>normalization</code>. Possible values are:</p><ul><li><p><code>:pdf</code>: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.</p></li><li><p><code>:density</code>: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1. Will not modify the  histogram if it already represents a density (<code>h.isdensity == 1</code>).</p></li><li><p><code>:probability</code>: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.</p></li><li><p><code>:none</code>: Do not normalize.</p></li></ul><p>The following attributes can move the histogram around, which comes in handy when placing multiple histograms into one plot:</p><ul><li><p>offset = 0.0: adds an offset to every value</p></li><li><p>fillto = 0.0: defines where the bar starts</p></li><li><p>scale_to = nothing: allows to scale all values to a certain height</p></li><li><p>flip = false: flips all values</p></li></ul><p>Color can either be:</p><ul><li><p>a vector of <code>bins</code> colors</p></li><li><p>a single color</p></li><li><p><code>:values</code>, to color the bars with the values from the histogram</p></li></ul><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.hist, T} where T</code> are: </p><pre><code>  bar_labels             "nothing"
  bins                   15
  color                  RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  cycle                  [:color =&gt; :patchcolor]
  fillto                 MakieCore.Automatic()
  flip_labels_at         Inf
  label_color            :black
  label_font             "Dejavu Sans"
  label_formatter        Makie.bar_label_formatter
  label_offset           5
  label_size             20
  normalization          :none
  offset                 0.0
  over_background_color  MakieCore.Automatic()
  over_bar_color         MakieCore.Automatic()
  scale_to               "nothing"</code></pre></div></div><div class="docstring"><div class="doc-header" id="hist!"><a href="#hist!">hist!</a></div><div class="doc-content"><pre><code>hist(values; bins = 15, normalization = :none)</code></pre><p>Plot a histogram of <code>values</code>. <code>bins</code> can be an <code>Int</code> to create that number of equal-width bins over the range of <code>values</code>. Alternatively, it can be a sorted iterable of bin edges. The histogram can be normalized by setting <code>normalization</code>. Possible values are:</p><ul><li><p><code>:pdf</code>: Normalize by sum of weights and bin sizes. Resulting histogram  has norm 1 and represents a PDF.</p></li><li><p><code>:density</code>: Normalize by bin sizes only. Resulting histogram represents  count density of input and does not have norm 1. Will not modify the  histogram if it already represents a density (<code>h.isdensity == 1</code>).</p></li><li><p><code>:probability</code>: Normalize by sum of weights only. Resulting histogram  represents the fraction of probability mass for each bin and does not have  norm 1.</p></li><li><p><code>:none</code>: Do not normalize.</p></li></ul><p>The following attributes can move the histogram around, which comes in handy when placing multiple histograms into one plot:</p><ul><li><p>offset = 0.0: adds an offset to every value</p></li><li><p>fillto = 0.0: defines where the bar starts</p></li><li><p>scale_to = nothing: allows to scale all values to a certain height</p></li><li><p>flip = false: flips all values</p></li></ul><p>Color can either be:</p><ul><li><p>a vector of <code>bins</code> colors</p></li><li><p>a single color</p></li><li><p><code>:values</code>, to color the bars with the values from the histogram</p></li></ul><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.hist!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="hlines!"><a href="#hlines!">hlines!</a></div><div class="doc-content"><pre><code>hlines!(ax::Axis, ys; xmin = 0.0, xmax = 1.0, attrs...)</code></pre><p>Create horizontal lines across <code>ax</code> at <code>ys</code> in data coordinates and <code>xmin</code> to <code>xmax</code> in axis coordinates (0 to 1). All three of these can have single or multiple values because they are broadcast to calculate the final line segments.</p></div></div><div class="docstring"><div class="doc-header" id="hovered_scene"><a href="#hovered_scene">hovered_scene</a></div><div class="doc-content"><pre><code>hovered_scene()</code></pre><p>Returns the <code>scene</code> that the mouse is currently hovering over.</p><p>Properly identifies the scene for a plot with multiple sub-plots.</p></div></div><div class="docstring"><div class="doc-header" id="hspan!"><a href="#hspan!">hspan!</a></div><div class="doc-content"><pre><code>hspan!(ax::Axis, y_lows, y_highs; xmin = 0.0, xmax = 1.0, attrs...)</code></pre><p>Create horizontal spans across <code>ax</code> from <code>y_lows</code> to <code>y_highs</code> in data coordinates and <code>xmin</code> to <code>xmax</code> in axis coordinates (0 to 1 by default). All four of these can have single or multiple values because they are broadcast to calculate the final spans.</p></div></div><div class="docstring"><div class="doc-header" id="image"><a href="#image">image</a></div><div class="doc-content"><pre><code>image(x, y, image)
image(image)</code></pre><p>Plots an image on range <code>x, y</code> (defaults to dimensions).</p></div></div><div class="docstring"><div class="doc-header" id="image!"><a href="#image!">image!</a></div><div class="doc-content"><pre><code>image(x, y, image)
image(image)</code></pre><p>Plots an image on range <code>x, y</code> (defaults to dimensions).</p></div></div><div class="docstring"><div class="doc-header" id="insertplots!"><a href="#insertplots!">insertplots!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.insertplots!</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "insertplots!":
[1] insertplots!(screen::GLMakie.GLScreen, scene::Makie.Scene) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/screen.jl:49
[2] insertplots!(screen::AbstractDisplay, scene::Makie.Scene) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:476</code></pre></div></div><div class="docstring"><div class="doc-header" id="interactions"><a href="#interactions">interactions</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.MakieLayout.interactions</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "interactions":
[1] interactions(ax::Makie.MakieLayout.Axis) in Makie.MakieLayout at /home/runner/work/Makie.jl/Makie.jl/src/makielayout/interactions.jl:4
[2] interactions(ax3::Makie.MakieLayout.Axis3) in Makie.MakieLayout at /home/runner/work/Makie.jl/Makie.jl/src/makielayout/interactions.jl:5</code></pre></div></div><div class="docstring"><div class="doc-header" id="ispressed"><a href="#ispressed">ispressed</a></div><div class="doc-content"><pre><code>ispressed(scene, buttons)</code></pre><p>Returns true if all <code>buttons</code> are pressed in the given <code>scene</code>. <code>buttons</code> can be a <code>Vector</code> or <code>Tuple</code> of <code>Keyboard</code> buttons (e.g. <code>Keyboard.a</code>), <code>Mouse</code> buttons (e.g. <code>Mouse.left</code>) and <code>nothing</code>.</p><pre><code>ispressed(scene, button)</code></pre><p>Returns true if <code>button</code> is pressed in the given <code>scene</code>. The <code>button</code> can be a <code>Keyboard</code> button (e.g. <code>Keyboard.a</code>), a <code>Mouse</code> button (e.g. <code>Mouse.left</code>) or <code>nothing</code>. In the latter case <code>true</code> is always returned.</p></div></div><div class="docstring"><div class="doc-header" id="keyboard_buttons"><a href="#keyboard_buttons">keyboard_buttons</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.keyboard_buttons</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "keyboard_buttons":
[1] keyboard_buttons(scene::Makie.Scene, window::GLFW.Window) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:99
[2] keyboard_buttons(scene::Makie.Scene, screen) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:98
[3] keyboard_buttons(scene, native_window) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/interaction/events.jl:9</code></pre></div></div><div class="docstring"><div class="doc-header" id="labelslider!"><a href="#labelslider!">labelslider!</a></div><div class="doc-content"><pre><code>labelslider!(scene, label, range; format = string, sliderkw = Dict(),
labelkw = Dict(), valuekw = Dict(), value_column_width = automatic, layoutkw...)</code></pre><p>Construct a horizontal GridLayout with a label, a slider and a value label in <code>scene</code>.</p><p>Returns a <code>NamedTuple</code>:</p><p><code>(slider = slider, label = label, valuelabel = valuelabel, layout = layout)</code></p><p>Specify a format function for the value label with the <code>format</code> keyword or pass a format string used by <code>Formatting.format</code>. The slider is forwarded the keywords from <code>sliderkw</code>. The label is forwarded the keywords from <code>labelkw</code>. The value label is forwarded the keywords from <code>valuekw</code>. You can set the column width for the value label column with the keyword <code>value_column_width</code>. By default, the width is determined heuristically by sampling a few values from the slider range. All other keywords are forwarded to the <code>GridLayout</code>.</p><p>Example:</p><pre><code>ls = labelslider!(scene, "Voltage:", 0:10; format = x -&gt; "$(x)V")
layout[1, 1] = ls.layout</code></pre></div></div><div class="docstring"><div class="doc-header" id="labelslidergrid!"><a href="#labelslidergrid!">labelslidergrid!</a></div><div class="doc-content"><pre><code>labelslidergrid!(scene, labels, ranges; formats = [string],
    sliderkw = Dict(), labelkw = Dict(), valuekw = Dict(),
    value_column_width = automatic, layoutkw...)</code></pre><p>Construct a GridLayout with a column of label, a column of sliders and a column of value labels in <code>scene</code>. The argument values are broadcast, so you can use scalars if you want to keep labels, ranges or formats constant across rows.</p><p>Returns a <code>NamedTuple</code>:</p><p><code>(sliders = sliders, labels = labels, valuelabels = valuelabels, layout = layout)</code></p><p>Specify format functions for the value labels with the <code>formats</code> keyword or pass format strings used by <code>Formatting.format</code>. The sliders are forwarded the keywords from <code>sliderkw</code>. The labels are forwarded the keywords from <code>labelkw</code>. The value labels are forwarded the keywords from <code>valuekw</code>. You can set the column width for the value label column with the keyword <code>value_column_width</code>. By default, the width is determined heuristically by sampling a few values from the slider ranges. All other keywords are forwarded to the <code>GridLayout</code>.</p><p>Example:</p><pre><code>ls = labelslidergrid!(scene, ["Voltage", "Ampere"], Ref(0:0.1:100); format = x -&gt; "$(x)V")
layout[1, 1] = ls.layout</code></pre></div></div><div class="docstring"><div class="doc-header" id="layoutscene"><a href="#layoutscene">layoutscene</a></div><div class="doc-content"><pre><code>layoutscene(padding = 30; kwargs...)</code></pre><p>Create a <code>Scene</code> in <code>campixel!</code> mode and a <code>GridLayout</code> aligned to the scene's pixel area with <code>alignmode = Outside(padding)</code>.</p><pre><code>layoutscene(nrows::Int, ncols::Int, padding = 30; kwargs...)</code></pre><p>Create a <code>Scene</code> in <code>campixel!</code> mode and a <code>GridLayout</code> aligned to the scene's pixel area with size <code>nrows</code> x <code>ncols</code> and <code>alignmode = Outside(padding)</code>.</p></div></div><div class="docstring"><div class="doc-header" id="left"><a href="#left">left</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.MakieLayout.left</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "left":
[1] left(rect::GeometryBasics.Rect2{T} where T) in Makie.MakieLayout at /home/runner/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:2</code></pre></div></div><div class="docstring"><div class="doc-header" id="lift"><a href="#lift">lift</a></div><div class="doc-content"><pre><code>lift(f, o1::Observables.AbstractObservable, rest...)</code></pre><p>Create a new <code>Observable</code> by applying <code>f</code> to all observables in <code>o1</code> and <code>rest...</code>. The initial value is determined by the first function evaluation.</p></div></div><div class="docstring"><div class="doc-header" id="limits!"><a href="#limits!">limits!</a></div><div class="doc-content"><pre><code>limits!(ax::Axis, xlims, ylims)</code></pre><p>Set the axis limits to <code>xlims</code> and <code>ylims</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis, x1, x2, y1, y2)</code></pre><p>Set the axis x-limits to <code>x1</code> and <code>x2</code> and the y-limits to <code>y1</code> and <code>y2</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis, rect::Rect2)</code></pre><p>Set the axis limits to <code>rect</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis3, xlims, ylims)</code></pre><p>Set the axis limits to <code>xlims</code> and <code>ylims</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis3, x1, x2, y1, y2, z1, z2)</code></pre><p>Set the axis x-limits to <code>x1</code> and <code>x2</code> and the y-limits to <code>y1</code> and <code>y2</code>. If limits are ordered high-low, this reverses the axis orientation.</p><pre><code>limits!(ax::Axis3, rect::Rect3)</code></pre><p>Set the axis limits to <code>rect</code>. If limits are ordered high-low, this reverses the axis orientation.</p></div></div><div class="docstring"><div class="doc-header" id="lines"><a href="#lines">lines</a></div><div class="doc-content"><pre><code>lines(positions)
lines(x, y)
lines(x, y, z)</code></pre><p>Creates a connected line plot for each element in <code>(x, y, z)</code>, <code>(x, y)</code> or <code>positions</code>.</p><div class="admonition tip"><p class="admonition-title">Tip</p><p>You can separate segments by inserting <code>NaN</code>s.</p></div></div></div><div class="docstring"><div class="doc-header" id="lines!"><a href="#lines!">lines!</a></div><div class="doc-content"><pre><code>lines(positions)
lines(x, y)
lines(x, y, z)</code></pre><p>Creates a connected line plot for each element in <code>(x, y, z)</code>, <code>(x, y)</code> or <code>positions</code>.</p><div class="admonition tip"><p class="admonition-title">Tip</p><p>You can separate segments by inserting <code>NaN</code>s.</p></div></div></div><div class="docstring"><div class="doc-header" id="linesegments"><a href="#linesegments">linesegments</a></div><div class="doc-content"><pre><code>linesegments(positions)
linesegments(x, y)
linesegments(x, y, z)</code></pre><p>Plots a line for each pair of points in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p></div></div><div class="docstring"><div class="doc-header" id="linesegments!"><a href="#linesegments!">linesegments!</a></div><div class="doc-content"><pre><code>linesegments(positions)
linesegments(x, y)
linesegments(x, y, z)</code></pre><p>Plots a line for each pair of points in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p></div></div><div class="docstring"><div class="doc-header" id="linkaxes!"><a href="#linkaxes!">linkaxes!</a></div><div class="doc-content"><pre><code>linkaxes!(a::Axis, others...)</code></pre><p>Link both x and y axes of all given <code>Axis</code> so that they stay synchronized.</p></div></div><div class="docstring"><div class="doc-header" id="linkxaxes!"><a href="#linkxaxes!">linkxaxes!</a></div><div class="doc-content"><pre><code>linkxaxes!(a::Axis, others...)</code></pre><p>Link the x axes of all given <code>Axis</code> so that they stay synchronized.</p></div></div><div class="docstring"><div class="doc-header" id="linkyaxes!"><a href="#linkyaxes!">linkyaxes!</a></div><div class="doc-content"><pre><code>linkyaxes!(a::Axis, others...)</code></pre><p>Link the y axes of all given <code>Axis</code> so that they stay synchronized.</p></div></div><div class="docstring"><div class="doc-header" id="map_once"><a href="#map_once">map_once</a></div><div class="doc-content"><pre><code>map_once(closure, inputs::Node....)::Node</code></pre><p>Like Reactive.foreach, in the sense that it will be preserved even if no reference is kept. The difference is, that you can call map once multiple times with the same closure and it will close the old result Node and register a new one instead.</p><p>``` function test(s1::Node)     s3 = map<em>once(x-&gt; (println("1 ", x); x), s1)     s3 = map</em>once(x-&gt; (println("2 ", x); x), s1)</p><p>end test(Node(1), Node(2))</p><blockquote></blockquote></div></div><div class="docstring"><div class="doc-header" id="mesh"><a href="#mesh">mesh</a></div><div class="doc-content"><pre><code>mesh(x, y, z)
mesh(mesh_object)
mesh(x, y, z, faces)
mesh(xyz, faces)</code></pre><p>Plots a 3D or 2D mesh. Supported <code>mesh_object</code>s include <code>Mesh</code> types from <a href="https://github.com/JuliaGeometry/GeometryBasics.jl">GeometryBasics.jl</a>.</p></div></div><div class="docstring"><div class="doc-header" id="mesh!"><a href="#mesh!">mesh!</a></div><div class="doc-content"><pre><code>mesh(x, y, z)
mesh(mesh_object)
mesh(x, y, z, faces)
mesh(xyz, faces)</code></pre><p>Plots a 3D or 2D mesh. Supported <code>mesh_object</code>s include <code>Mesh</code> types from <a href="https://github.com/JuliaGeometry/GeometryBasics.jl">GeometryBasics.jl</a>.</p></div></div><div class="docstring"><div class="doc-header" id="meshscatter"><a href="#meshscatter">meshscatter</a></div><div class="doc-content"><pre><code>meshscatter(positions)
meshscatter(x, y)
meshscatter(x, y, z)</code></pre><p>Plots a mesh for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code> (similar to <code>scatter</code>). <code>markersize</code> is a scaling applied to the primitive passed as <code>marker</code>.</p></div></div><div class="docstring"><div class="doc-header" id="meshscatter!"><a href="#meshscatter!">meshscatter!</a></div><div class="doc-content"><pre><code>meshscatter(positions)
meshscatter(x, y)
meshscatter(x, y, z)</code></pre><p>Plots a mesh for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code> (similar to <code>scatter</code>). <code>markersize</code> is a scaling applied to the primitive passed as <code>marker</code>.</p></div></div><div class="docstring"><div class="doc-header" id="mouse_buttons"><a href="#mouse_buttons">mouse_buttons</a></div><div class="doc-content"><p>Registers a callback for the mouse buttons + modifiers returns <code>Node{NTuple{4, Int}}</code><a href="http://www.glfw.org/docs/latest/group__input.html#ga1e008c7a8751cea648c8f42cc91104cf">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="mouse_position"><a href="#mouse_position">mouse_position</a></div><div class="doc-content"><p>Registers a callback for the mouse cursor position. returns an <code>Node{Vec{2, Float64}}</code>, which is not in scene coordinates, with the upper left window corner being 0 <a href="http://www.glfw.org/docs/latest/group__input.html#ga1e008c7a8751cea648c8f42cc91104cf">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="mouse_selection"><a href="#mouse_selection">mouse_selection</a></div><div class="doc-content"><pre><code>mouse_selection(scene::Scene)</code></pre><p>Returns the plot that is under the current mouse position</p></div></div><div class="docstring"><div class="doc-header" id="mouseover"><a href="#mouseover">mouseover</a></div><div class="doc-content"><pre><code>mouseover(scene::SceneLike, plots::AbstractPlot...)</code></pre><p>Returns true if the mouse currently hovers any of <code>plots</code>.</p></div></div><div class="docstring"><div class="doc-header" id="mouseposition"><a href="#mouseposition">mouseposition</a></div><div class="doc-content"><pre><code>mouseposition(scene = hovered_scene())</code></pre><p>Return the current position of the mouse in <em>data coordinates</em> of the given <code>scene</code>.</p><p>By default uses the <code>scene</code> that the mouse is currently hovering over.</p></div></div><div class="docstring"><div class="doc-header" id="must_update"><a href="#must_update">must_update</a></div><div class="doc-content"><p>Returns whether a scene needs to be updated</p></div></div><div class="docstring"><div class="doc-header" id="ncols"><a href="#ncols">ncols</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.ncols</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "ncols":
[1] ncols(g::GridLayoutBase.GridLayout) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:1274</code></pre></div></div><div class="docstring"><div class="doc-header" id="nrows"><a href="#nrows">nrows</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.nrows</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "nrows":
[1] nrows(g::GridLayoutBase.GridLayout) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:1275</code></pre></div></div><div class="docstring"><div class="doc-header" id="off"><a href="#off">off</a></div><div class="doc-content"><pre><code>off(observable::AbstractObservable, f)</code></pre><p>Removes <code>f</code> from listeners of <code>observable</code>.</p><p>Returns <code>true</code> if <code>f</code> could be removed, otherwise <code>false</code>.</p><pre><code>off(obsfunc::ObserverFunction)</code></pre><p>Remove the listener function <code>obsfunc.f</code> from the listeners of <code>obsfunc.observable</code>. Once <code>obsfunc</code> goes out of scope, this should allow <code>obsfunc.f</code> and all the values it might have closed over to be garbage collected (unless there are other references to it).</p></div></div><div class="docstring"><div class="doc-header" id="old_cam3d!"><a href="#old_cam3d!">old_cam3d!</a></div><div class="doc-content"><pre><code>old_cam3d!(scene; kwargs...)</code></pre><p>An alias to <a href="@ref"><code>old_cam3d_turntable!</code></a>. Creates a 3D camera for <code>scene</code>, which rotates around the plot's axis.</p></div></div><div class="docstring"><div class="doc-header" id="old_cam3d_cad!"><a href="#old_cam3d_cad!">old_cam3d_cad!</a></div><div class="doc-content"><pre><code>old_cam3d_cad!(scene; kw_args...)</code></pre><p>Creates a 3D camera for <code>scene</code> which rotates around the <em>viewer</em>'s "up" axis - similarly to how it's done in CAD software cameras.</p></div></div><div class="docstring"><div class="doc-header" id="on"><a href="#on">on</a></div><div class="doc-content"><pre><code>on(f, observable::AbstractObservable; weak = false)</code></pre><p>Adds function <code>f</code> as listener to <code>observable</code>. Whenever <code>observable</code>'s value is set via <code>observable[] = val</code>, <code>f</code> is called with <code>val</code>.</p><p>Returns an <a href="@ref"><code>ObserverFunction</code></a> that wraps <code>f</code> and <code>observable</code> and allows to disconnect easily by calling <code>off(observerfunction)</code> instead of <code>off(f, observable)</code>. If instead you want to compute a new <code>Observable</code> from an old one, use <a href="@ref"><code>map(f, ::Observable)</code></a>.</p><p>If <code>weak = true</code> is set, the new connection will be removed as soon as the returned <code>ObserverFunction</code> is not referenced anywhere and is garbage collected. This is useful if some parent object makes connections to outside observables and stores the resulting <code>ObserverFunction</code> instances. Then, once that parent object is garbage collected, the weak observable connections are removed automatically.</p><h1>Example</h1><pre><code class="language-jldoctest; setup=:(using Observables)">julia&gt; obs = Observable(0)
Observable{Int64} with 0 listeners. Value:
0

julia&gt; on(obs) do val
           println("current value is ", val)
       end
(::Observables.ObserverFunction) (generic function with 0 methods)

julia&gt; obs[] = 5;
current value is 5</code></pre><pre><code>on(f, c::Camera, nodes::Node...)</code></pre><p>When mapping over nodes for the camera, we store them in the <code>steering_node</code> vector, to make it easier to disconnect the camera steering signals later!</p></div></div><div class="docstring"><div class="doc-header" id="onany"><a href="#onany">onany</a></div><div class="doc-content"><pre><code>onany(f, args...)</code></pre><p>Calls <code>f</code> on updates to any observable refs in <code>args</code>. <code>args</code> may contain any number of <code>Observable</code> objects. <code>f</code> will be passed the values contained in the refs as the respective argument. All other objects in <code>args</code> are passed as-is.</p><p>See also: <a href="@ref"><code>on</code></a>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousedownoutside"><a href="#onmousedownoutside">onmousedownoutside</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === downoutside</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseenter"><a href="#onmouseenter">onmouseenter</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === enter</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftclick"><a href="#onmouseleftclick">onmouseleftclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdoubleclick"><a href="#onmouseleftdoubleclick">onmouseleftdoubleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdoubleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdown"><a href="#onmouseleftdown">onmouseleftdown</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdown</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdrag"><a href="#onmouseleftdrag">onmouseleftdrag</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdrag</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdragstart"><a href="#onmouseleftdragstart">onmouseleftdragstart</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdragstart</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftdragstop"><a href="#onmouseleftdragstop">onmouseleftdragstop</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftdragstop</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseleftup"><a href="#onmouseleftup">onmouseleftup</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === leftup</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddleclick"><a href="#onmousemiddleclick">onmousemiddleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledoubleclick"><a href="#onmousemiddledoubleclick">onmousemiddledoubleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledoubleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledown"><a href="#onmousemiddledown">onmousemiddledown</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledown</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledrag"><a href="#onmousemiddledrag">onmousemiddledrag</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledrag</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledragstart"><a href="#onmousemiddledragstart">onmousemiddledragstart</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledragstart</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddledragstop"><a href="#onmousemiddledragstop">onmousemiddledragstop</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middledragstop</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmousemiddleup"><a href="#onmousemiddleup">onmousemiddleup</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === middleup</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseout"><a href="#onmouseout">onmouseout</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === out</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouseover"><a href="#onmouseover">onmouseover</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === over</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightclick"><a href="#onmouserightclick">onmouserightclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdoubleclick"><a href="#onmouserightdoubleclick">onmouserightdoubleclick</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdoubleclick</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdown"><a href="#onmouserightdown">onmouserightdown</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdown</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdrag"><a href="#onmouserightdrag">onmouserightdrag</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdrag</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdragstart"><a href="#onmouserightdragstart">onmouserightdragstart</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdragstart</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightdragstop"><a href="#onmouserightdragstop">onmouserightdragstop</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightdragstop</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onmouserightup"><a href="#onmouserightup">onmouserightup</a></div><div class="doc-content"><p>Executes the function f whenever the <code>MouseEventHandle</code>'s observable is set to a MouseEvent with <code>event.type === rightup</code>.</p></div></div><div class="docstring"><div class="doc-header" id="onpick"><a href="#onpick">onpick</a></div><div class="doc-content"><pre><code>onpick(func, plot)</code></pre><p>Calls <code>func</code> if one clicks on <code>plot</code>.  Implemented by the backend.</p><pre><code>onpick(f, scene::SceneLike, plots::AbstractPlot...)</code></pre><p>Calls <code>f(plot, idx)</code> whenever the mouse is over any of <code>plots</code>. <code>idx</code> is an index, e.g. when over a scatter plot, it will be the index of the hovered element</p></div></div><div class="docstring"><div class="doc-header" id="pick"><a href="#pick">pick</a></div><div class="doc-content"><p>Picks a mouse position.  Implemented by the backend.</p><pre><code>pick(scene, x, y)</code></pre><p>Returns the plot under pixel position <code>(x, y)</code>.</p><pre><code>pick(scene::Scene, xy::VecLike)</code></pre><p>Return the plot under pixel position xy.</p><pre><code>pick(scene::Scene, xy::VecLike, range)</code></pre><p>Return the plot closest to xy within a given range.</p><pre><code>pick(scene::Scene, rect::Rect2i)</code></pre><p>Return all <code>(plot, index)</code> pairs within the given rect. The rect must be within screen boundaries.</p></div></div><div class="docstring"><div class="doc-header" id="pie"><a href="#pie">pie</a></div><div class="doc-content"><pre><code>pie(fractions; kwargs...)</code></pre><p>Creates a pie chart with the given <code>fractions</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.pie, T} where T</code> are: </p><pre><code>  color           :gray
  inner_radius    0
  inspectable     true
  normalize       true
  offset          0
  radius          1
  strokecolor     :black
  strokewidth     1
  vertex_per_deg  1</code></pre></div></div><div class="docstring"><div class="doc-header" id="pie!"><a href="#pie!">pie!</a></div><div class="doc-content"><pre><code>pie(fractions; kwargs...)</code></pre><p>Creates a pie chart with the given <code>fractions</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.pie!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="pixelarea"><a href="#pixelarea">pixelarea</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.pixelarea</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "pixelarea":
[1] pixelarea(scene::Makie.Scene) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:413
[2] pixelarea(scene::Union{MakieCore.AbstractScene, MakieCore.ScenePlot}) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:414</code></pre></div></div><div class="docstring"><div class="doc-header" id="plot"><a href="#plot">plot</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.plot</code> is a <code>Function</code>.</p><pre><code># 5 methods for generic function "plot":
[1] plot(P::Union{Type{Any}, Type{var"#s268"} where var"#s268"&lt;:MakieCore.AbstractPlot}, gsp::GridLayoutBase.GridSubposition, args...; axis, kwargs...) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/figureplotting.jl:98
[2] plot(P::Union{Type{Any}, Type{var"#s268"} where var"#s268"&lt;:MakieCore.AbstractPlot}, gp::GridLayoutBase.GridPosition, args...; axis, kwargs...) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/figureplotting.jl:50
[3] plot(P::Union{Type{Any}, Type{var"#s268"} where var"#s268"&lt;:MakieCore.AbstractPlot}, args...; axis, figure, kw_attributes...) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/figureplotting.jl:16
[4] plot(scene::Makie.Scene, plot::MakieCore.AbstractPlot) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/interfaces.jl:176
[5] plot(args...; attributes...) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:30</code></pre></div></div><div class="docstring"><div class="doc-header" id="plot!"><a href="#plot!">plot!</a></div><div class="doc-content"><p>Main plotting signatures that plot/plot! route to if no Plot Type is given</p></div></div><div class="docstring"><div class="doc-header" id="plotkey"><a href="#plotkey">plotkey</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.plotkey</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "plotkey":
[1] plotkey(::Type{var"#s14"} where var"#s14"&lt;:MakieCore.AbstractPlot{Typ}) where Typ in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:19
[2] plotkey(::T) where T&lt;:MakieCore.AbstractPlot in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:20</code></pre></div></div><div class="docstring"><div class="doc-header" id="plots"><a href="#plots">plots</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.plots</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "plots":
[1] plots(scene::Union{MakieCore.AbstractScene, MakieCore.ScenePlot}) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:416</code></pre></div></div><div class="docstring"><div class="doc-header" id="poly"><a href="#poly">poly</a></div><div class="doc-content"><pre><code>poly(vertices, indices; kwargs...)
poly(points; kwargs...)
poly(shape; kwargs...)
poly(mesh; kwargs...)</code></pre><p>Plots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to <code>mesh</code>. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by <code>GeometryBasics</code>), it will plot <code>decompose(shape)</code>.</p><pre><code>poly(coordinates, connectivity; kwargs...)</code></pre><p>Plots polygons, which are defined by <code>coordinates</code> (the coordinates of the vertices) and <code>connectivity</code> (the edges between the vertices).</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.poly, T} where T</code> are: </p><pre><code>  color         RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.6f0)
  colormap      :viridis
  colorrange    MakieCore.Automatic()
  cycle         [:color =&gt; :patchcolor]
  inspectable   true
  linestyle     "nothing"
  overdraw      false
  shading       false
  strokecolor   :black
  strokewidth   0
  transparency  false
  visible       true</code></pre></div></div><div class="docstring"><div class="doc-header" id="poly!"><a href="#poly!">poly!</a></div><div class="doc-content"><pre><code>poly(vertices, indices; kwargs...)
poly(points; kwargs...)
poly(shape; kwargs...)
poly(mesh; kwargs...)</code></pre><p>Plots a polygon based on the arguments given. When vertices and indices are given, it functions similarly to <code>mesh</code>. When points are given, it draws one polygon that connects all the points in order. When a shape is given (essentially anything decomposable by <code>GeometryBasics</code>), it will plot <code>decompose(shape)</code>.</p><pre><code>poly(coordinates, connectivity; kwargs...)</code></pre><p>Plots polygons, which are defined by <code>coordinates</code> (the coordinates of the vertices) and <code>connectivity</code> (the edges between the vertices).</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.poly!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="px"><a href="#px">px</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.px</code> is of type <code>MakieCore.Pixel{Int64}</code>.</p><h1>Summary</h1><pre><code>struct MakieCore.Pixel{Int64} &lt;: MakieCore.Unit{Int64}</code></pre><h1>Fields</h1><pre><code>value :: Int64</code></pre><h1>Supertype Hierarchy</h1><pre><code>MakieCore.Pixel{Int64} &lt;: MakieCore.Unit{Int64} &lt;: Number &lt;: Any</code></pre></div></div><div class="docstring"><div class="doc-header" id="qqnorm"><a href="#qqnorm">qqnorm</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.qqnorm</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "qqnorm":
[1] qqnorm() in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:170
[2] qqnorm(args...; attributes...) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:30</code></pre></div></div><div class="docstring"><div class="doc-header" id="qqnorm!"><a href="#qqnorm!">qqnorm!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.qqnorm!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "qqnorm!":
[1] qqnorm!(args...; attributes...) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:34</code></pre></div></div><div class="docstring"><div class="doc-header" id="qqplot"><a href="#qqplot">qqplot</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.qqplot</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "qqplot":
[1] qqplot() in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:170
[2] qqplot(args...; attributes...) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:30</code></pre></div></div><div class="docstring"><div class="doc-header" id="qqplot!"><a href="#qqplot!">qqplot!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.qqplot!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "qqplot!":
[1] qqplot!(args...; attributes...) in Makie at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:34</code></pre></div></div><div class="docstring"><div class="doc-header" id="qrotation"><a href="#qrotation">qrotation</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.qrotation</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "qrotation":
[1] qrotation(axis::StaticArrays.StaticVector{3, T} where T, theta::Number) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/utilities/quaternions.jl:39</code></pre></div></div><div class="docstring"><div class="doc-header" id="quiver"><a href="#quiver">quiver</a></div><div class="doc-content"><pre><code>arrows(points, directions; kwargs...)
arrows(x, y, u, v)
arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)
arrows(x, y, z, u, v, w)</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each 'row' is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.arrows, T} where T</code> are: </p><pre><code>  align           :origin
  ambient         Float32[0.55, 0.55, 0.55]
  arrowcolor      MakieCore.Automatic()
  arrowhead       MakieCore.Automatic()
  arrowsize       MakieCore.Automatic()
  arrowtail       MakieCore.Automatic()
  color           :black
  colormap        :viridis
  diffuse         Float32[0.4, 0.4, 0.4]
  inspectable     true
  lengthscale     1.0f0
  lightposition   :eyeposition
  linecolor       MakieCore.Automatic()
  linestyle       "nothing"
  linewidth       MakieCore.Automatic()
  markerspace     MakieCore.Pixel
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  normalize       false
  overdraw        false
  quality         32
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="quiver!"><a href="#quiver!">quiver!</a></div><div class="doc-content"><pre><code>arrows(points, directions; kwargs...)
arrows(x, y, u, v)
arrows(x::AbstractVector, y::AbstractVector, u::AbstractMatrix, v::AbstractMatrix)
arrows(x, y, z, u, v, w)</code></pre><p>Plots arrows at the specified points with the specified components. <code>u</code> and <code>v</code> are interpreted as vector components (<code>u</code> being the x and <code>v</code> being the y), and the vectors are plotted with the tails at <code>x</code>, <code>y</code>.</p><p>If <code>x, y, u, v</code> are <code>&lt;: AbstractVector</code>, then each 'row' is plotted as a single vector.</p><p>If <code>u, v</code> are <code>&lt;: AbstractMatrix</code>, then <code>x</code> and <code>y</code> are interpreted as specifications for a grid, and <code>u, v</code> are plotted as arrows along the grid.</p><p><code>arrows</code> can also work in three dimensions.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.arrows!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="rangebars"><a href="#rangebars">rangebars</a></div><div class="doc-content"><pre><code>rangebars(val, low, high; kwargs...)
rangebars(val, low_high; kwargs...)
rangebars(val_low_high; kwargs...)</code></pre><p>Plots rangebars at <code>val</code> in one dimension, extending from <code>low</code> to <code>high</code> in the other dimension given the chosen <code>direction</code>.</p><p>If you want to plot errors relative to a reference value, use <code>errorbars</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.rangebars, T} where T</code> are: </p><pre><code>  color         :black
  colormap      :viridis
  direction     :y
  inspectable   true
  linewidth     1.5
  visible       true
  whiskerwidth  0</code></pre></div></div><div class="docstring"><div class="doc-header" id="rangebars!"><a href="#rangebars!">rangebars!</a></div><div class="doc-content"><pre><code>rangebars(val, low, high; kwargs...)
rangebars(val, low_high; kwargs...)
rangebars(val_low_high; kwargs...)</code></pre><p>Plots rangebars at <code>val</code> in one dimension, extending from <code>low</code> to <code>high</code> in the other dimension given the chosen <code>direction</code>.</p><p>If you want to plot errors relative to a reference value, use <code>errorbars</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.rangebars!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="record"><a href="#record">record</a></div><div class="doc-content"><pre><code>record(func, figure, path; framerate = 24, compression = 20, kwargs...)
record(func, figure, path, iter; framerate = 24, compression = 20, kwargs...)</code></pre><p>The first signature provides <code>func</code> with a VideoStream, which it should call <code>recordframe!(io)</code> on when recording a frame.</p><p>The second signature iterates <code>iter</code>, calling <code>recordframe!(io)</code> internally after calling <code>func</code> with the current iteration element.</p><p>Both notations require a Figure, FigureAxisPlot or Scene <code>figure</code> to work.</p><p>The animation is then saved to <code>path</code>, with the format determined by <code>path</code>'s extension.  Allowable extensions are:</p><ul><li><p><code>.mkv</code>  (the default, doesn't need to convert)</p></li><li><p><code>.mp4</code>  (good for Web, most supported format)</p></li><li><p><code>.webm</code> (smallest file size)</p></li><li><p><code>.gif</code>  (largest file size for the same quality)</p></li></ul><p><code>.mp4</code> and <code>.mk4</code> are marginally bigger than <code>webm</code> and <code>.gif</code>s are up to 6 times bigger with the same quality!</p><p>The <code>compression</code> argument controls the compression ratio; <code>51</code> is the highest compression, and <code>0</code> or <code>1</code> is the lowest (with <code>0</code> being lossless).</p><p>Typical usage patterns would look like:</p><pre><code class="language-julia">record(figure, "video.mp4", itr) do i
    func(i) # or some other manipulation of the figure
end</code></pre><p>or, for more tweakability,</p><pre><code class="language-julia">record(figure, "test.gif") do io
    for i = 1:100
        func!(figure)     # animate figure
        recordframe!(io)  # record a new frame
    end
end</code></pre><p>If you want a more tweakable interface, consider using <a href="@ref"><code>VideoStream</code></a> and <a href="@ref"><code>save</code></a>.</p><h2>Extended help</h2><h3>Examples</h3><pre><code class="language-julia">fig, ax, p = lines(rand(10))
record(fig, "test.gif") do io
    for i in 1:255
        p[:color] = RGBf(i/255, (255 - i)/255, 0) # animate figure
        recordframe!(io)
    end
end</code></pre><p>or</p><pre><code class="language-julia">fig, ax, p = lines(rand(10))
record(fig, "test.gif", 1:255) do i
    p[:color] = RGBf(i/255, (255 - i)/255, 0) # animate figure
end</code></pre><h3>Keyword Arguments:</h3><ul><li><p><code>framrate = 24</code>: The target framerate.</p></li><li><p><code>compression = 0</code>: Controls the video compression with <code>0</code> being lossless and                    <code>51</code> being the highest compression. Note that <code>compression = 0</code>                    only works with <code>.mp4</code> if <code>profile = high444</code>.</p></li><li><p><code>profile = "high422</code>: A ffmpeg compatible profile. Currently only applies to                       <code>.mp4</code>. If you have issues playing a video, try                       <code>profile = "high"</code> or <code>profile = "main"</code>.</p></li><li><p><code>pixel_format = "yuv420p"</code>: A ffmpeg compatible pixel format (pix_fmt). Currently                             only applies to <code>.mp4</code>. Defaults to <code>yuv444p</code> for                             <code>profile = high444</code>.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="record_events"><a href="#record_events">record_events</a></div><div class="doc-content"><pre><code>record_events(f, scene::Scene, path::String)</code></pre><p>Records all window events that happen while executing function <code>f</code> for <code>scene</code> and serializes them to <code>path</code>.</p></div></div><div class="docstring"><div class="doc-header" id="recordframe!"><a href="#recordframe!">recordframe!</a></div><div class="doc-content"><pre><code>recordframe!(io::VideoStream)</code></pre><p>Adds a video frame to the VideoStream <code>io</code>.</p></div></div><div class="docstring"><div class="doc-header" id="register_callbacks"><a href="#register_callbacks">register_callbacks</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.register_callbacks</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "register_callbacks":
[1] register_callbacks(scene::Makie.Scene, native_window) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/interaction/events.jl:15</code></pre></div></div><div class="docstring"><div class="doc-header" id="register_interaction!"><a href="#register_interaction!">register_interaction!</a></div><div class="doc-content"><pre><code>register_interaction!(parent, name::Symbol, interaction)</code></pre><p>Register <code>interaction</code> with <code>parent</code> under the name <code>name</code>. The parent will call <code>process_interaction(interaction, event, parent)</code> whenever suitable events happen.</p><p>The interaction can be removed with <code>deregister_interaction!</code> or temporarily toggled with <code>activate_interaction!</code> / <code>deactivate_interaction!</code>.</p><pre><code>register_interaction!(interaction::Function, parent, name::Symbol)</code></pre><p>Register <code>interaction</code> with <code>parent</code> under the name <code>name</code>. The parent will call <code>process_interaction(interaction, event, parent)</code> whenever suitable events happen. This form with the first <code>Function</code> argument is especially intended for <code>do</code> syntax.</p><p>The interaction can be removed with <code>deregister_interaction!</code> or temporarily toggled with <code>activate_interaction!</code> / <code>deactivate_interaction!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="replace_automatic!"><a href="#replace_automatic!">replace_automatic!</a></div><div class="doc-content"><p>Like <code>get!(f, dict, key)</code> but also calls <code>f</code> and replaces <code>key</code> when the corresponding value is nothing</p></div></div><div class="docstring"><div class="doc-header" id="replay_events"><a href="#replay_events">replay_events</a></div><div class="doc-content"><pre><code>replay_events(f, scene::Scene, path::String)
replay_events(scene::Scene, path::String)</code></pre><p>Replays the serialized events recorded with <code>record_events</code> in <code>path</code> in <code>scene</code>.</p></div></div><div class="docstring"><div class="doc-header" id="reset_limits!"><a href="#reset_limits!">reset_limits!</a></div><div class="doc-content"><pre><code>reset_limits!(ax; xauto = true, yauto = true)</code></pre><p>Resets the axis limits depending on the value of <code>ax.limits</code>. If one of the two components of limits is nothing, that value is either copied from the targetlimits if <code>xauto</code> or <code>yauto</code> is false, respectively, or it is determined automatically from the plots in the axis. If one of the components is a tuple of two numbers, those are used directly.</p></div></div><div class="docstring"><div class="doc-header" id="right"><a href="#right">right</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.MakieLayout.right</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "right":
[1] right(rect::GeometryBasics.Rect2{T} where T) in Makie.MakieLayout at /home/runner/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:3</code></pre></div></div><div class="docstring"><div class="doc-header" id="rotate!"><a href="#rotate!">rotate!</a></div><div class="doc-content"><pre><code>rotate!(Accum, scene::Transformable, axis_rot...)</code></pre><p>Apply a relative rotation to the Scene, by multiplying by the current rotation.</p><pre><code>rotate!(scene::Transformable, axis_rot::Quaternion)
rotate!(scene::Transformable, axis_rot::AbstractFloat)
rotate!(scene::Transformable, axis_rot...)</code></pre><p>Apply an absolute rotation to the Scene. Rotations are all internally converted to <code>Quaternion</code>s.</p></div></div><div class="docstring"><div class="doc-header" id="rotate_cam!"><a href="#rotate_cam!">rotate_cam!</a></div><div class="doc-content"><pre><code>rotate_cam!(scene::Scene, theta_v::Number...)
rotate_cam!(scene::Scene, theta_v::VecTypes)</code></pre><p>Rotate the camera of the Scene by the given rotation. Passing <code>theta_v = (α, β, γ)</code> will rotate the camera according to the Euler angles (α, β, γ).</p></div></div><div class="docstring"><div class="doc-header" id="rowgap!"><a href="#rowgap!">rowgap!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.rowgap!</code> is a <code>Function</code>.</p><pre><code># 4 methods for generic function "rowgap!":
[1] rowgap!(gl::GridLayoutBase.GridLayout, i::Int64, s::GridLayoutBase.GapSize) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:592
[2] rowgap!(gl::GridLayoutBase.GridLayout, i::Int64, s::Real) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:600
[3] rowgap!(gl::GridLayoutBase.GridLayout, s::GridLayoutBase.GapSize) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:602
[4] rowgap!(gl::GridLayoutBase.GridLayout, r::Real) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:607</code></pre></div></div><div class="docstring"><div class="doc-header" id="rowsize!"><a href="#rowsize!">rowsize!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.rowsize!</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "rowsize!":
[1] rowsize!(gl::GridLayoutBase.GridLayout, i::Int64, s::GridLayoutBase.ContentSize) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:562
[2] rowsize!(gl::GridLayoutBase.GridLayout, i::Int64, s::Real) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:570</code></pre></div></div><div class="docstring"><div class="doc-header" id="save"><a href="#save">save</a></div><div class="doc-content"><ul><li><p><code>save(filename, data...)</code> saves the contents of a formatted file, trying to infer the format from <code>filename</code>.</p></li><li><p><code>save(Stream{format"PNG"}(io), data...)</code> specifies the format directly, and bypasses the format <a href="@ref"><code>query</code></a>.</p></li><li><p><code>save(File{format"PNG"}(filename), data...)</code> specifies the format directly, and bypasses the format <a href="@ref"><code>query</code></a>.</p></li><li><p><code>save(f, data...; options...)</code> passes keyword arguments on to the saver.</p></li></ul><pre><code>FileIO.save(filename, scene; resolution = size(scene), pt_per_unit = 0.75, px_per_unit = 1.0)</code></pre><p>Save a <code>Scene</code> with the specified filename and format.</p><h1>Supported Formats</h1><ul><li><p><code>GLMakie</code>: <code>.png</code>, <code>.jpeg</code>, and <code>.bmp</code></p></li><li><p><code>CairoMakie</code>: <code>.svg</code>, <code>.pdf</code>, <code>.png</code>, and <code>.jpeg</code></p></li><li><p><code>WGLMakie</code>: <code>.png</code></p></li></ul><h1>Supported Keyword Arguments</h1><h2>All Backends</h2><ul><li><p><code>resolution</code>: <code>(width::Int, height::Int)</code> of the scene in dimensionless units (equivalent to <code>px</code> for GLMakie and WGLMakie).</p></li><li><p><code>update</code>: Update the scene and its children before saving (<code>update_limits!</code> and <code>center!</code>). One might want to set <code>update=false</code> e.g. when saving a zoomed scene.</p></li></ul><h2>CairoMakie</h2><ul><li><p><code>pt_per_unit</code>: The size of one scene unit in <code>pt</code> when exporting to a vector format.</p></li><li><p><code>px_per_unit</code>: The size of one scene unit in <code>px</code> when exporting to a bitmap format. This provides a mechanism to export the same scene with higher or lower resolution.</p></li></ul><pre><code>save(path::String, io::VideoStream[; kwargs...])</code></pre><p>Flushes the video stream and converts the file to the extension found in <code>path</code>, which can be one of the following:</p><ul><li><p><code>.mkv</code>  (the default, doesn't need to convert)</p></li><li><p><code>.mp4</code>  (good for Web, most supported format)</p></li><li><p><code>.webm</code> (smallest file size)</p></li><li><p><code>.gif</code>  (largest file size for the same quality)</p></li></ul><p><code>.mp4</code> and <code>.mk4</code> are marginally bigger and <code>.gif</code>s are up to 6 times bigger with the same quality!</p><p>See the docs of <a href="@ref"><code>VideoStream</code></a> for how to create a VideoStream. If you want a simpler interface, consider using <a href="@ref"><code>record</code></a>.</p><h3>Keyword Arguments:</h3><ul><li><p><code>framrate = 24</code>: The target framerate.</p></li><li><p><code>compression = 0</code>: Controls the video compression with <code>0</code> being lossless and                    <code>51</code> being the highest compression. Note that <code>compression = 0</code>                    only works with <code>.mp4</code> if <code>profile = high444</code>.</p></li><li><p><code>profile = "high422</code>: A ffmpeg compatible profile. Currently only applies to                       <code>.mp4</code>. If you have issues playing a video, try                       <code>profile = "high"</code> or <code>profile = "main"</code>.</p></li><li><p><code>pixel_format = "yuv420p"</code>: A ffmpeg compatible pixel format (pix_fmt). Currently                             only applies to <code>.mp4</code>. Defaults to <code>yuv444p</code> for                             <code>profile = high444</code>.</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="scale!"><a href="#scale!">scale!</a></div><div class="doc-content"><pre><code>scale!(t::Transformable, x, y)
scale!(t::Transformable, x, y, z)
scale!(t::Transformable, xyz)
scale!(t::Transformable, xyz...)</code></pre><p>Scale the given <code>Transformable</code> (a Scene or Plot) to the given arguments. Can take <code>x, y</code> or <code>x, y, z</code>. This is an absolute scaling, and there is no option to perform relative scaling.</p></div></div><div class="docstring"><div class="doc-header" id="scatter"><a href="#scatter">scatter</a></div><div class="doc-content"><pre><code>scatter(positions)
scatter(x, y)
scatter(x, y, z)</code></pre><p>Plots a marker for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p></div></div><div class="docstring"><div class="doc-header" id="scatter!"><a href="#scatter!">scatter!</a></div><div class="doc-content"><pre><code>scatter(positions)
scatter(x, y)
scatter(x, y, z)</code></pre><p>Plots a marker for each element in <code>(x, y, z)</code>, <code>(x, y)</code>, or <code>positions</code>.</p></div></div><div class="docstring"><div class="doc-header" id="scatterlines"><a href="#scatterlines">scatterlines</a></div><div class="doc-content"><pre><code>scatterlines(xs, ys, [zs]; kwargs...)</code></pre><p>Plots <code>scatter</code> markers and <code>lines</code> between them.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.scatterlines, T} where T</code> are: </p><pre><code>  color             :black
  colormap          :viridis
  colorrange        MakieCore.Automatic()
  inspectable       true
  linestyle         "nothing"
  linewidth         1.5
  marker            GeometryBasics.Circle{T} where T
  markercolor       :black
  markercolormap    :viridis
  markercolorrange  MakieCore.Automatic()
  markersize        9
  strokecolor       :black
  strokewidth       0</code></pre></div></div><div class="docstring"><div class="doc-header" id="scatterlines!"><a href="#scatterlines!">scatterlines!</a></div><div class="doc-content"><pre><code>scatterlines(xs, ys, [zs]; kwargs...)</code></pre><p>Plots <code>scatter</code> markers and <code>lines</code> between them.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.scatterlines!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="scene_limits"><a href="#scene_limits">scene_limits</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.scene_limits</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "scene_limits":
[1] scene_limits(scene::Makie.Scene) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:348</code></pre></div></div><div class="docstring"><div class="doc-header" id="scroll"><a href="#scroll">scroll</a></div><div class="doc-content"><p>Registers a callback for the mouse scroll. returns an <code>Node{Vec{2, Float64}}</code>, which is an x and y offset. <a href="http://www.glfw.org/docs/latest/group__input.html#gacc95e259ad21d4f666faa6280d4018fd">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="select_line"><a href="#select_line">select_line</a></div><div class="doc-content"><pre><code>select_line(scene; kwargs...) -&gt; line</code></pre><p>Interactively select a line (typically an arrow) on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. Return an <strong>observable</strong> whose value corresponds to the selected line on the scene. In addition the function <em>plots</em> the line on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted line disappears.</p><p>The value of the returned line is updated <strong>only</strong> when the user un-clicks and only if the selected line has non-zero length.</p><p>The <code>kwargs...</code> are propagated into <code>lines!</code> which plots the selected line.</p></div></div><div class="docstring"><div class="doc-header" id="select_point"><a href="#select_point">select_point</a></div><div class="doc-content"><pre><code>select_point(scene; kwargs...) -&gt; point</code></pre><p>Interactively select a point on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. Return an <strong>observable</strong> whose value corresponds to the selected point on the scene. In addition the function <em>plots</em> the point on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted point disappears.</p><p>The value of the returned point is updated <strong>only</strong> when the user un-clicks.</p><p>The <code>kwargs...</code> are propagated into <code>scatter!</code> which plots the selected point.</p></div></div><div class="docstring"><div class="doc-header" id="select_rectangle"><a href="#select_rectangle">select_rectangle</a></div><div class="doc-content"><pre><code>select_rectangle(scene; kwargs...) -&gt; rect</code></pre><p>Interactively select a rectangle on a 2D <code>scene</code> by clicking the left mouse button, dragging and then un-clicking. The function returns an <strong>observable</strong><code>rect</code> whose value corresponds to the selected rectangle on the scene. In addition the function <em>plots</em> the selected rectangle on the scene as the user clicks and moves the mouse around. When the button is not clicked any more, the plotted rectangle disappears.</p><p>The value of the returned observable is updated <strong>only</strong> when the user un-clicks (i.e. when the final value of the rectangle has been decided) and only if the rectangle has area &gt; 0.</p><p>The <code>kwargs...</code> are propagated into <code>lines!</code> which plots the selected rectangle.</p></div></div><div class="docstring"><div class="doc-header" id="series"><a href="#series">series</a></div><div class="doc-content"><pre><code>series(curves;
    linewidth=2,
    color=:lighttest,
    solid_color=nothing,
    labels=nothing,
    # scatter arguments, if any is set != nothing, a scatterplot is added
    marker=nothing,
    markersize=nothing,
    markercolor=automatic,
    strokecolor=nothing,
    strokewidth=nothing)</code></pre><p>Curves can be:</p><ul><li><p><code>AbstractVector{&lt;: AbstractVector{&lt;: Point2}}</code>: the native representation of a series as a vector of lines</p></li><li><p><code>AbstractMatrix</code>: each row represents y coordinates of the line, while <code>x</code> goes from <code>1:size(curves, 1)</code></p></li><li><p><code>AbstractVector, AbstractMatrix</code>: the same as the above, but the first argument sets the x values for all lines</p></li><li><p><code>AbstractVector{&lt;: Tuple{X&lt;: AbstractVector, Y&lt;: AbstractVector}}</code>: A vector of tuples, where each tuple contains a vector for the x and y coordinates</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="series!"><a href="#series!">series!</a></div><div class="doc-content"><pre><code>series(curves;
    linewidth=2,
    color=:lighttest,
    solid_color=nothing,
    labels=nothing,
    # scatter arguments, if any is set != nothing, a scatterplot is added
    marker=nothing,
    markersize=nothing,
    markercolor=automatic,
    strokecolor=nothing,
    strokewidth=nothing)</code></pre><p>Curves can be:</p><ul><li><p><code>AbstractVector{&lt;: AbstractVector{&lt;: Point2}}</code>: the native representation of a series as a vector of lines</p></li><li><p><code>AbstractMatrix</code>: each row represents y coordinates of the line, while <code>x</code> goes from <code>1:size(curves, 1)</code></p></li><li><p><code>AbstractVector, AbstractMatrix</code>: the same as the above, but the first argument sets the x values for all lines</p></li><li><p><code>AbstractVector{&lt;: Tuple{X&lt;: AbstractVector, Y&lt;: AbstractVector}}</code>: A vector of tuples, where each tuple contains a vector for the x and y coordinates</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="set_close_to!"><a href="#set_close_to!">set_close_to!</a></div><div class="doc-content"><p>Set the <code>slider</code> to the value in the slider's range that is closest to <code>value</code> and return this value.</p><p>Set the <code>slider</code> to the values in the slider's range that are closest to <code>v1</code> and <code>v2</code>, and return those values ordered min, max.</p></div></div><div class="docstring"><div class="doc-header" id="set_theme!"><a href="#set_theme!">set_theme!</a></div><div class="doc-content"><pre><code>set_theme(theme; kwargs...)</code></pre><p>Set the global default theme to <code>theme</code> and add / override any attributes given as keyword arguments.</p></div></div><div class="docstring"><div class="doc-header" id="showgradients"><a href="#showgradients">showgradients</a></div><div class="doc-content"><pre><code>showgradients(
    cgrads::AbstractVector{Symbol};
    h = 0.0, offset = 0.2, textsize = 0.7,
    resolution = (800, length(cgrads) * 84)
)::Scene</code></pre><p>Plots the given colour gradients arranged as horizontal colourbars. If you change the offsets or the font size, you may need to change the resolution.</p></div></div><div class="docstring"><div class="doc-header" id="spy"><a href="#spy">spy</a></div><div class="doc-content"><p>spy(x::Range, y::Range, z::AbstractSparseArray)</p><p>Visualizes big sparse matrices. Usage:</p><pre><code class="language-julia">N = 200_000
x = sprand(Float64, N, N, (3(10^6)) / (N*N));
spy(x)
# or if you want to specify the range of x and y:
spy(0..1, 0..1, x)</code></pre><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.spy, T} where T</code> are: </p><pre><code>  colormap     :viridis
  colorrange   MakieCore.Automatic()
  framecolor   :black
  framesize    1
  inspectable  true
  marker       MakieCore.Automatic()
  markersize   MakieCore.Automatic()</code></pre></div></div><div class="docstring"><div class="doc-header" id="spy!"><a href="#spy!">spy!</a></div><div class="doc-content"><p>spy(x::Range, y::Range, z::AbstractSparseArray)</p><p>Visualizes big sparse matrices. Usage:</p><pre><code class="language-julia">N = 200_000
x = sprand(Float64, N, N, (3(10^6)) / (N*N));
spy(x)
# or if you want to specify the range of x and y:
spy(0..1, 0..1, x)</code></pre><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.spy!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="stairs"><a href="#stairs">stairs</a></div><div class="doc-content"><pre><code>stairs(xs, ys; kwargs...)</code></pre><p>Plot a stair function.</p><p>The <code>step</code> parameter can take the following values:</p><ul><li><p><code>:pre</code>: horizontal part of step extends to the left of each value in <code>xs</code>.</p></li><li><p><code>:post</code>: horizontal part of step extends to the right of each value in <code>xs</code>.</p></li><li><p><code>:center</code>: horizontal part of step extends halfway between the two adjacent values of <code>xs</code>.</p></li></ul><p>The conversion trait of stem is <code>PointBased</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.stairs, T} where T</code> are: </p><pre><code>  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  cycle           [:color]
  diffuse         Float32[0.4, 0.4, 0.4]
  inspectable     true
  lightposition   :eyeposition
  linestyle       "nothing"
  linewidth       1.5
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  step            :pre
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="stairs!"><a href="#stairs!">stairs!</a></div><div class="doc-content"><pre><code>stairs(xs, ys; kwargs...)</code></pre><p>Plot a stair function.</p><p>The <code>step</code> parameter can take the following values:</p><ul><li><p><code>:pre</code>: horizontal part of step extends to the left of each value in <code>xs</code>.</p></li><li><p><code>:post</code>: horizontal part of step extends to the right of each value in <code>xs</code>.</p></li><li><p><code>:center</code>: horizontal part of step extends halfway between the two adjacent values of <code>xs</code>.</p></li></ul><p>The conversion trait of stem is <code>PointBased</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.stairs!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="stem"><a href="#stem">stem</a></div><div class="doc-content"><pre><code>stem(xs, ys, [zs]; kwargs...)</code></pre><p>Plots markers at the given positions extending from <code>offset</code> along stem lines.</p><p><code>offset</code> can be a number, in which case it sets y for 2D, and z for 3D stems. It can be a Point2 for 2D plots, as well as a Point3 for 3D plots. It can also be an iterable of any of these at the same length as xs, ys, zs.</p><p>The conversion trait of stem is <code>PointBased</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.stem, T} where T</code> are: </p><pre><code>  color            :black
  colormap         :viridis
  colorrange       MakieCore.Automatic()
  cycle            [[:stemcolor, :color, :trunkcolor] =&gt; :color]
  inspectable      true
  marker           :circle
  markersize       9
  offset           0
  stemcolor        :black
  stemcolormap     :viridis
  stemcolorrange   MakieCore.Automatic()
  stemlinestyle    "nothing"
  stemwidth        1.5
  strokecolor      :black
  strokewidth      0
  trunkcolor       :black
  trunkcolormap    :viridis
  trunkcolorrange  MakieCore.Automatic()
  trunklinestyle   "nothing"
  trunkwidth       1.5
  visible          true</code></pre></div></div><div class="docstring"><div class="doc-header" id="stem!"><a href="#stem!">stem!</a></div><div class="doc-content"><pre><code>stem(xs, ys, [zs]; kwargs...)</code></pre><p>Plots markers at the given positions extending from <code>offset</code> along stem lines.</p><p><code>offset</code> can be a number, in which case it sets y for 2D, and z for 3D stems. It can be a Point2 for 2D plots, as well as a Point3 for 3D plots. It can also be an iterable of any of these at the same length as xs, ys, zs.</p><p>The conversion trait of stem is <code>PointBased</code>.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.stem!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="streamplot"><a href="#streamplot">streamplot</a></div><div class="doc-content"><p>streamplot(f::function, xinterval, yinterval; kwargs...)</p><p>f must either accept <code>f(::Point)</code> or <code>f(x::Number, y::Number)</code>. f must return a Point2.</p><p>Example:</p><pre><code class="language-julia">v(x::Point2{T}) where T = Point2f(x[2], 4*x[1])
streamplot(v, -2..2, -2..2)</code></pre><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.streamplot, T} where T</code> are: </p><pre><code>  ambient         Float32[0.55, 0.55, 0.55]
  arrow_head      MakieCore.Automatic()
  arrow_size      0.03
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  cycle           [:color]
  density         1.0
  diffuse         Float32[0.4, 0.4, 0.4]
  gridsize        (32, 32, 32)
  inspectable     true
  lightposition   :eyeposition
  linestyle       "nothing"
  linewidth       1.5
  maxsteps        500
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  quality         16
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  stepsize        0.01
  transparency    false
  visible         true</code></pre><h2>Implementation</h2><p>See the function <code>Makie.streamplot_impl</code> for implementation details.</p></div></div><div class="docstring"><div class="doc-header" id="streamplot!"><a href="#streamplot!">streamplot!</a></div><div class="doc-content"><p>streamplot(f::function, xinterval, yinterval; kwargs...)</p><p>f must either accept <code>f(::Point)</code> or <code>f(x::Number, y::Number)</code>. f must return a Point2.</p><p>Example:</p><pre><code class="language-julia">v(x::Point2{T}) where T = Point2f(x[2], 4*x[1])
streamplot(v, -2..2, -2..2)</code></pre><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.streamplot!, T} where T</code> are: </p><pre><code></code></pre><h2>Implementation</h2><p>See the function <code>Makie.streamplot_impl</code> for implementation details.</p></div></div><div class="docstring"><div class="doc-header" id="surface"><a href="#surface">surface</a></div><div class="doc-content"><pre><code>surface(x, y, z)</code></pre><p>Plots a surface, where <code>(x, y)</code>  define a grid whose heights are the entries in <code>z</code>. <code>x</code> and <code>y</code> may be <code>Vectors</code> which define a regular grid, <strong>or</strong><code>Matrices</code> which define an irregular grid.</p></div></div><div class="docstring"><div class="doc-header" id="surface!"><a href="#surface!">surface!</a></div><div class="doc-content"><pre><code>surface(x, y, z)</code></pre><p>Plots a surface, where <code>(x, y)</code>  define a grid whose heights are the entries in <code>z</code>. <code>x</code> and <code>y</code> may be <code>Vectors</code> which define a regular grid, <strong>or</strong><code>Matrices</code> which define an irregular grid.</p></div></div><div class="docstring"><div class="doc-header" id="swap!"><a href="#swap!">swap!</a></div><div class="doc-content"><p>Swaps or rotates the layout positions of the given elements to their neighbor's.</p></div></div><div class="docstring"><div class="doc-header" id="text"><a href="#text">text</a></div><div class="doc-content"><pre><code>text(string)</code></pre><p>Plots a text.</p></div></div><div class="docstring"><div class="doc-header" id="text!"><a href="#text!">text!</a></div><div class="doc-content"><pre><code>text(string)</code></pre><p>Plots a text.</p></div></div><div class="docstring"><div class="doc-header" id="theme"><a href="#theme">theme</a></div><div class="doc-content"><p>No documentation found.</p><p><code>MakieCore.theme</code> is a <code>Function</code>.</p><pre><code># 6 methods for generic function "theme":
[1] theme(x::MakieCore.AbstractScene) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:54
[2] theme(x::MakieCore.AbstractScene, key) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:55
[3] theme(x::Union{MakieCore.AbstractScene, MakieCore.ScenePlot}, args...) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:53
[4] theme(x::MakieCore.AbstractPlot) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/attributes.jl:156
[5] theme(x::MakieCore.AbstractPlot, key) in MakieCore at /home/runner/.julia/packages/MakieCore/S8PkO/src/recipes.jl:56
[6] theme(::Nothing, key::Symbol) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/theming.jl:150</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_black"><a href="#theme_black">theme_black</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_black</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_black":
[1] theme_black() in Makie at /home/runner/work/Makie.jl/Makie.jl/src/themes/theme_black.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_dark"><a href="#theme_dark">theme_dark</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_dark</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_dark":
[1] theme_dark() in Makie at /home/runner/work/Makie.jl/Makie.jl/src/themes/theme_dark.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_ggplot2"><a href="#theme_ggplot2">theme_ggplot2</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_ggplot2</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_ggplot2":
[1] theme_ggplot2() in Makie at /home/runner/work/Makie.jl/Makie.jl/src/themes/theme_ggplot2.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_light"><a href="#theme_light">theme_light</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_light</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_light":
[1] theme_light() in Makie at /home/runner/work/Makie.jl/Makie.jl/src/themes/theme_light.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="theme_minimal"><a href="#theme_minimal">theme_minimal</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.theme_minimal</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "theme_minimal":
[1] theme_minimal() in Makie at /home/runner/work/Makie.jl/Makie.jl/src/themes/theme_minimal.jl:1</code></pre></div></div><div class="docstring"><div class="doc-header" id="tight_ticklabel_spacing!"><a href="#tight_ticklabel_spacing!">tight_ticklabel_spacing!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.MakieLayout.tight_ticklabel_spacing!</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "tight_ticklabel_spacing!":
[1] tight_ticklabel_spacing!(la::Makie.MakieLayout.LineAxis) in Makie.MakieLayout at /home/runner/work/Makie.jl/Makie.jl/src/makielayout/lineaxis.jl:406
[2] tight_ticklabel_spacing!(la::Makie.MakieLayout.Axis) in Makie.MakieLayout at /home/runner/work/Makie.jl/Makie.jl/src/makielayout/layoutables/axis.jl:1135
[3] tight_ticklabel_spacing!(lc::Makie.MakieLayout.Colorbar) in Makie.MakieLayout at /home/runner/work/Makie.jl/Makie.jl/src/makielayout/layoutables/colorbar.jl:378</code></pre></div></div><div class="docstring"><div class="doc-header" id="tight_xticklabel_spacing!"><a href="#tight_xticklabel_spacing!">tight_xticklabel_spacing!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.MakieLayout.tight_xticklabel_spacing!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "tight_xticklabel_spacing!":
[1] tight_xticklabel_spacing!(la::Makie.MakieLayout.Axis) in Makie.MakieLayout at /home/runner/work/Makie.jl/Makie.jl/src/makielayout/layoutables/axis.jl:1131</code></pre></div></div><div class="docstring"><div class="doc-header" id="tight_yticklabel_spacing!"><a href="#tight_yticklabel_spacing!">tight_yticklabel_spacing!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.MakieLayout.tight_yticklabel_spacing!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "tight_yticklabel_spacing!":
[1] tight_yticklabel_spacing!(la::Makie.MakieLayout.Axis) in Makie.MakieLayout at /home/runner/work/Makie.jl/Makie.jl/src/makielayout/layoutables/axis.jl:1127</code></pre></div></div><div class="docstring"><div class="doc-header" id="tightlimits!"><a href="#tightlimits!">tightlimits!</a></div><div class="doc-content"><pre><code>tightlimits!(la::Axis)</code></pre><p>Sets the autolimit margins to zero on all sides.</p><pre><code>tightlimits!(la::Axis, sides::Union{Left, Right, Bottom, Top}...)</code></pre><p>Sets the autolimit margins to zero on all given sides.</p><p>Example:</p><pre><code>tightlimits!(laxis, Bottom())</code></pre></div></div><div class="docstring"><div class="doc-header" id="timeseries"><a href="#timeseries">timeseries</a></div><div class="doc-content"><pre><code>timeseries(x::Node{{Union{Number, Point2}}})</code></pre><p>Plots a sampled signal. Usage:</p><pre><code class="language-julia">signal = Node(1.0)
scene = timeseries(signal)
display(scene)
# @async is optional, but helps to continue evaluating more code
@async while isopen(scene)
    # aquire data from e.g. a sensor:
    data = rand()
    # update the signal
    signal[] = data
    # sleep/ wait for new data/ whatever...
    # It's important to yield here though, otherwise nothing will be rendered
    sleep(1/30)
end
</code></pre></div></div><div class="docstring"><div class="doc-header" id="timeseries!"><a href="#timeseries!">timeseries!</a></div><div class="doc-content"><pre><code>timeseries(x::Node{{Union{Number, Point2}}})</code></pre><p>Plots a sampled signal. Usage:</p><pre><code class="language-julia">signal = Node(1.0)
scene = timeseries(signal)
display(scene)
# @async is optional, but helps to continue evaluating more code
@async while isopen(scene)
    # aquire data from e.g. a sensor:
    data = rand()
    # update the signal
    signal[] = data
    # sleep/ wait for new data/ whatever...
    # It's important to yield here though, otherwise nothing will be rendered
    sleep(1/30)
end
</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_align"><a href="#to_align">to_align</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_align</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "to_align":
[1] to_align(align) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/conversions.jl:710</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_color"><a href="#to_color">to_color</a></div><div class="doc-content"><pre><code>to_color(color)</code></pre><p>Converts a <code>color</code> symbol (e.g. <code>:blue</code>) to a color RGBA.</p></div></div><div class="docstring"><div class="doc-header" id="to_colormap"><a href="#to_colormap">to_colormap</a></div><div class="doc-content"><pre><code>to_colormap(cm[, N = 20])</code></pre><p>Converts a colormap <code>cm</code> symbol (e.g. <code>:Spectral</code>) to a colormap RGB array, where <code>N</code> specifies the number of color points.</p></div></div><div class="docstring"><div class="doc-header" id="to_font"><a href="#to_font">to_font</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_font</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "to_font":
[1] to_font(font) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/conversions.jl:709</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_ndim"><a href="#to_ndim">to_ndim</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_ndim</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "to_ndim":
[1] to_ndim(T::Type{var"#s12"} where var"#s12"&lt;:Union{Tuple{Vararg{ET, N}}, StaticArrays.StaticVector{N, ET}}, vec::Union{Tuple{Vararg{T, N2}}, StaticArrays.StaticVector{N2, T}} where T, fillval) where {N, ET, N2} in Makie at /home/runner/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:203</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_rotation"><a href="#to_rotation">to_rotation</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_rotation</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "to_rotation":
[1] to_rotation(rotation) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/conversions.jl:708</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_textsize"><a href="#to_textsize">to_textsize</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_textsize</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "to_textsize":
[1] to_textsize(textsize) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/conversions.jl:711</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_value"><a href="#to_value">to_value</a></div><div class="doc-content"><pre><code>to_value(x::Union{Any, AbstractObservable})</code></pre><p>Extracts the value of an observable, and returns the object if it's not an observable!</p></div></div><div class="docstring"><div class="doc-header" id="to_vector"><a href="#to_vector">to_vector</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_vector</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "to_vector":
[1] to_vector(x::AbstractVector{T} where T, len, T) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:232
[2] to_vector(x::AbstractArray, len, T) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:233
[3] to_vector(x::IntervalSets.ClosedInterval{T} where T, len, T) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/utilities/utilities.jl:240</code></pre></div></div><div class="docstring"><div class="doc-header" id="to_world"><a href="#to_world">to_world</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.to_world</code> is a <code>Function</code>.</p><pre><code># 3 methods for generic function "to_world":
[1] to_world(scene::Makie.Scene, point::T) where T&lt;:(StaticArrays.StaticVector{N, T} where {N, T}) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/camera/projection_math.jl:278
[2] to_world(p::GeometryBasics.Vec{N, T}, prj_view_inv::StaticArrays.SMatrix{4, 4, T, 16} where T, cam_res::StaticArrays.StaticVector{N, T} where {N, T}) where {N, T} in Makie at /home/runner/work/Makie.jl/Makie.jl/src/camera/projection_math.jl:308
[3] to_world(p::StaticArrays.StaticVector{N, T}, prj_view_inv::StaticArrays.SMatrix{4, 4, T, 16} where T, cam_res::StaticArrays.StaticVector{N, T} where {N, T}) where {N, T} in Makie at /home/runner/work/Makie.jl/Makie.jl/src/camera/projection_math.jl:292</code></pre></div></div><div class="docstring"><div class="doc-header" id="top"><a href="#top">top</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.MakieLayout.top</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "top":
[1] top(rect::GeometryBasics.Rect2{T} where T) in Makie.MakieLayout at /home/runner/work/Makie.jl/Makie.jl/src/makielayout/geometrybasics_extension.jl:5</code></pre></div></div><div class="docstring"><div class="doc-header" id="translate!"><a href="#translate!">translate!</a></div><div class="doc-content"><pre><code>translate!(scene::Transformable, xyz::VecTypes)
translate!(scene::Transformable, xyz...)</code></pre><p>Apply an absolute translation to the Scene, translating it to <code>x, y, z</code>.</p><pre><code>translate!(Accum, scene::Transformable, xyz...)</code></pre><p>Translate the scene relative to its current position.</p></div></div><div class="docstring"><div class="doc-header" id="translate_cam!"><a href="#translate_cam!">translate_cam!</a></div><div class="doc-content"><pre><code>translate_cam!(scene::Scene, translation::VecTypes)</code></pre><p>Translate the camera by a translation vector given in camera space. </p></div></div><div class="docstring"><div class="doc-header" id="translated"><a href="#translated">translated</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.translated</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "translated":
[1] translated(scene::Makie.Scene; kw_args...) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/layouting/transformation.jl:72
[2] translated(scene::Makie.Scene, translation...) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/layouting/transformation.jl:66</code></pre></div></div><div class="docstring"><div class="doc-header" id="translation"><a href="#translation">translation</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.translation</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "translation":
[1] translation(scene::MakieCore.Transformable) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/layouting/transformation.jl:143</code></pre></div></div><div class="docstring"><div class="doc-header" id="trim!"><a href="#trim!">trim!</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.trim!</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "trim!":
[1] trim!(gl::GridLayoutBase.GridLayout) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:458</code></pre></div></div><div class="docstring"><div class="doc-header" id="unicode_input"><a href="#unicode_input">unicode_input</a></div><div class="doc-content"><p>Registers a callback for keyboard unicode input. returns an <code>Node{Vector{Char}}</code>, containing the pressed char. Is empty, if no key is pressed. <a href="http://www.glfw.org/docs/latest/group__input.html#ga1e008c7a8751cea648c8f42cc91104cf">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="update!"><a href="#update!">update!</a></div><div class="doc-content"><pre><code>`update!(p::Scene)`</code></pre><p>Updates a <code>Scene</code> and all its children. Update will perform the following operations for every scene:</p><pre><code class="language-julia">if !scene.raw[]
    scene.update_limits[] &amp;&amp; update_limits!(scene)
    scene.center[] &amp;&amp; center!(scene)
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="update_cam!"><a href="#update_cam!">update_cam!</a></div><div class="doc-content"><pre><code>update_cam!(scene::SceneLike, area)</code></pre><p>Updates the camera for the given <code>scene</code> to cover the given <code>area</code> in 2d.</p><pre><code>update_cam!(scene::SceneLike)</code></pre><p>Updates the camera for the given <code>scene</code> to cover the limits of the <code>Scene</code>. Useful when using the <code>Node</code> pipeline.</p><pre><code>update_cam!(scene::Scene, eyeposition, lookat, up = Vec3f(0, 0, 1))</code></pre><p>Updates the camera's controls to point to the specified location.</p></div></div><div class="docstring"><div class="doc-header" id="update_limits!"><a href="#update_limits!">update_limits!</a></div><div class="doc-content"><pre><code>update_limits!(scene::Scene, limits::Union{Automatic, Rect} = scene.limits[], padding = scene.padding[])</code></pre><p>This function updates the limits of the <code>Scene</code> passed to it based on its data. If an actual limit is set by the theme or its attributes (scene.limits !== automatic), it will not update the limits. Call update_limits!(scene, automatic) for that.</p><pre><code>update_limits!(scene::Scene, new_limits::Rect, padding = Vec3f(0))</code></pre><p>This function updates the limits of the given <code>Scene</code> according to the given Rect.</p><p>A <code>Rect</code> is a generalization of a rectangle to n dimensions.  It contains two vectors. The first vector defines the origin; the second defines the displacement of the vertices from the origin. This second vector can be thought of in two dimensions as a vector of width (x-axis) and height (y-axis), and in three dimensions as a vector of the width (x-axis), breadth (y-axis), and height (z-axis).</p><p>Such a <code>Rect</code> can be constructed using the <code>Rectf</code> or <code>Rect3f</code> functions that are exported by <code>Makie.jl</code>.  See their documentation for more information.</p></div></div><div class="docstring"><div class="doc-header" id="update_theme!"><a href="#update_theme!">update_theme!</a></div><div class="doc-content"><pre><code>update_theme!(with_theme::Theme; kwargs...)</code></pre><p>Updates the current theme incrementally, that means only the keys given in <code>with_theme</code> or through keyword arguments are changed, the rest is left intact. Nested attributes are either also updated incrementally, or replaced if they are not attributes in the new theme.</p></div></div><div class="docstring"><div class="doc-header" id="used_attributes"><a href="#used_attributes">used_attributes</a></div><div class="doc-content"><pre><code>used_attributes(args...) = ()</code></pre><p>function used to indicate what keyword args one wants to get passed in <code>convert_arguments</code>. Usage:</p><pre><code class="language-julia">    struct MyType end
    used_attributes(::MyType) = (:attribute,)
    function convert_arguments(x::MyType; attribute = 1)
        ...
    end
    # attribute will get passed to convert_arguments
    # without keyword_verload, this wouldn't happen
    plot(MyType, attribute = 2)
    #You can also use the convenience macro, to overload convert_arguments in one step:
    @keywords convert_arguments(x::MyType; attribute = 1)
        ...
    end</code></pre></div></div><div class="docstring"><div class="doc-header" id="vgrid!"><a href="#vgrid!">vgrid!</a></div><div class="doc-content"><pre><code>vbox!(content::Vararg; kwargs...)</code></pre><p>Creates a single-column GridLayout with all elements contained in <code>content</code> placed from top to bottom.</p></div></div><div class="docstring"><div class="doc-header" id="violin"><a href="#violin">violin</a></div><div class="doc-content"><pre><code>violin(x, y; kwargs...)</code></pre><p>Draw a violin plot.</p><h1>Arguments</h1><ul><li><p><code>x</code>: positions of the categories</p></li><li><p><code>y</code>: variables whose density is computed</p></li></ul><h1>Keywords</h1><ul><li><p><code>orientation=:vertical</code>: orientation of the violins (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=0.8</code>: width of the violin</p></li><li><p><code>show_median=true</code>: show median as midline</p></li><li><p><code>side=:both</code>: specify <code>:left</code> or <code>:right</code> to only plot the violin on one side</p></li><li><p><code>datalimits</code>: specify values to trim the <code>violin</code>. Can be a <code>Tuple</code> or a <code>Function</code> (e.g. <code>datalimits=extrema</code>)</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="violin!"><a href="#violin!">violin!</a></div><div class="doc-content"><pre><code>violin(x, y; kwargs...)</code></pre><p>Draw a violin plot.</p><h1>Arguments</h1><ul><li><p><code>x</code>: positions of the categories</p></li><li><p><code>y</code>: variables whose density is computed</p></li></ul><h1>Keywords</h1><ul><li><p><code>orientation=:vertical</code>: orientation of the violins (<code>:vertical</code> or <code>:horizontal</code>)</p></li><li><p><code>width=0.8</code>: width of the violin</p></li><li><p><code>show_median=true</code>: show median as midline</p></li><li><p><code>side=:both</code>: specify <code>:left</code> or <code>:right</code> to only plot the violin on one side</p></li><li><p><code>datalimits</code>: specify values to trim the <code>violin</code>. Can be a <code>Tuple</code> or a <code>Function</code> (e.g. <code>datalimits=extrema</code>)</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="vlines!"><a href="#vlines!">vlines!</a></div><div class="doc-content"><pre><code>vlines!(ax::Axis, xs; ymin = 0.0, ymax = 1.0, attrs...)</code></pre><p>Create vertical lines across <code>ax</code> at <code>xs</code> in data coordinates and <code>ymin</code> to <code>ymax</code> in axis coordinates (0 to 1). All three of these can have single or multiple values because they are broadcast to calculate the final line segments.</p></div></div><div class="docstring"><div class="doc-header" id="volume"><a href="#volume">volume</a></div><div class="doc-content"><pre><code>volume(volume_data)</code></pre><p>Plots a volume. Available algorithms are:</p><ul><li><p><code>:iso</code> =&gt; IsoValue</p></li><li><p><code>:absorption</code> =&gt; Absorption</p></li><li><p><code>:mip</code> =&gt; MaximumIntensityProjection</p></li><li><p><code>:absorptionrgba</code> =&gt; AbsorptionRGBA</p></li><li><p><code>:additive</code> =&gt; AdditiveRGBA</p></li><li><p><code>:indexedabsorption</code> =&gt; IndexedAbsorptionRGBA</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="volume!"><a href="#volume!">volume!</a></div><div class="doc-content"><pre><code>volume(volume_data)</code></pre><p>Plots a volume. Available algorithms are:</p><ul><li><p><code>:iso</code> =&gt; IsoValue</p></li><li><p><code>:absorption</code> =&gt; Absorption</p></li><li><p><code>:mip</code> =&gt; MaximumIntensityProjection</p></li><li><p><code>:absorptionrgba</code> =&gt; AbsorptionRGBA</p></li><li><p><code>:additive</code> =&gt; AdditiveRGBA</p></li><li><p><code>:indexedabsorption</code> =&gt; IndexedAbsorptionRGBA</p></li></ul></div></div><div class="docstring"><div class="doc-header" id="volumeslices"><a href="#volumeslices">volumeslices</a></div><div class="doc-content"><p>VolumeSlices</p><pre><code>volumeslices(x, y, z, v)</code></pre><p>Draws heatmap slices of the volume v</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.volumeslices, T} where T</code> are: </p><pre><code>  colorrange  MakieCore.Automatic()
  heatmap     Attributes with 0 entries</code></pre></div></div><div class="docstring"><div class="doc-header" id="volumeslices!"><a href="#volumeslices!">volumeslices!</a></div><div class="doc-content"><p>VolumeSlices</p><pre><code>volumeslices(x, y, z, v)</code></pre><p>Draws heatmap slices of the volume v</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.volumeslices!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="vspan!"><a href="#vspan!">vspan!</a></div><div class="doc-content"><pre><code>vspan!(ax::Axis, x_lows, x_highs; ymin = 0.0, ymax = 1.0, attrs...)</code></pre><p>Create vertical spans across <code>ax</code> from <code>x_lows</code> to <code>x_highs</code> in data coordinates and <code>ymin</code> to <code>ymax</code> in axis coordinates (0 to 1 by default). All four of these can have single or multiple values because they are broadcast to calculate the final spans.</p></div></div><div class="docstring"><div class="doc-header" id="width"><a href="#width">width</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.width</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "width":
[1] width(rect::GeometryBasics.Rect2{T} where T) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/geometry_integration.jl:6</code></pre></div></div><div class="docstring"><div class="doc-header" id="widths"><a href="#widths">widths</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GeometryBasics.widths</code> is a <code>Function</code>.</p><pre><code># 5 methods for generic function "widths":
[1] widths(prim::GeometryBasics.HyperRectangle) in GeometryBasics at /home/runner/.julia/packages/GeometryBasics/WMp6v/src/primitives/rectangles.jl:162
[2] widths(c::GeometryBasics.HyperSphere{N, T}) where {N, T} in GeometryBasics at /home/runner/.julia/packages/GeometryBasics/WMp6v/src/primitives/spheres.jl:28
[3] widths(x::AbstractRange) in GeometryBasics at /home/runner/.julia/packages/GeometryBasics/WMp6v/src/geometry_primitives.jl:4
[4] widths(scene::Makie.Scene) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/scenes.jl:306
[5] widths(x::GLMakie.Screen) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/screen.jl:42</code></pre></div></div><div class="docstring"><div class="doc-header" id="window_area"><a href="#window_area">window_area</a></div><div class="doc-content"><p>No documentation found.</p><p><code>Makie.window_area</code> is a <code>Function</code>.</p><pre><code># 2 methods for generic function "window_area":
[1] window_area(scene::Makie.Scene, screen::GLMakie.Screen) in GLMakie at /home/runner/work/Makie.jl/Makie.jl/GLMakie/src/events.jl:43
[2] window_area(scene, native_window) in Makie at /home/runner/work/Makie.jl/Makie.jl/src/interaction/events.jl:4</code></pre></div></div><div class="docstring"><div class="doc-header" id="window_open"><a href="#window_open">window_open</a></div><div class="doc-content"><p>Returns a signal, which is true as long as the window is open. returns <code>Node{Bool}</code><a href="http://www.glfw.org/docs/latest/group__window.html#gaade9264e79fae52bdb78e2df11ee8d6a">GLFW Docs</a></p></div></div><div class="docstring"><div class="doc-header" id="wireframe"><a href="#wireframe">wireframe</a></div><div class="doc-content"><pre><code>wireframe(x, y, z)
wireframe(positions)
wireframe(mesh)</code></pre><p>Draws a wireframe, either interpreted as a surface or as a mesh.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.wireframe, T} where T</code> are: </p><pre><code>  ambient         Float32[0.55, 0.55, 0.55]
  color           :black
  colormap        :viridis
  colorrange      MakieCore.Automatic()
  cycle           [:color]
  diffuse         Float32[0.4, 0.4, 0.4]
  inspectable     true
  lightposition   :eyeposition
  linestyle       "nothing"
  linewidth       1.5
  nan_color       RGBA{Float32}(0.0f0,0.0f0,0.0f0,0.0f0)
  overdraw        false
  shininess       32.0f0
  specular        Float32[0.2, 0.2, 0.2]
  ssao            false
  transparency    false
  visible         true</code></pre></div></div><div class="docstring"><div class="doc-header" id="wireframe!"><a href="#wireframe!">wireframe!</a></div><div class="doc-content"><pre><code>wireframe(x, y, z)
wireframe(positions)
wireframe(mesh)</code></pre><p>Draws a wireframe, either interpreted as a surface or as a mesh.</p><h2>Attributes</h2><p>Available attributes and their defaults for <code>MakieCore.Combined{Makie.wireframe!, T} where T</code> are: </p><pre><code></code></pre></div></div><div class="docstring"><div class="doc-header" id="with_theme"><a href="#with_theme">with_theme</a></div><div class="doc-content"><pre><code>with_theme(f, theme = Theme(); kwargs...)</code></pre><p>Calls <code>f</code> with <code>theme</code> temporarily activated. Attributes in <code>theme</code> can be overridden or extended with <code>kwargs</code>. The previous theme is always restored afterwards, no matter if <code>f</code> succeeds or fails.</p><p>Example:</p><pre><code class="language-julia">my_theme = Theme(resolution = (500, 500), color = :red)
with_theme(my_theme, color = :blue, linestyle = :dashed) do
    scatter(randn(100, 2))
end</code></pre></div></div><div class="docstring"><div class="doc-header" id="with_updates_suspended"><a href="#with_updates_suspended">with_updates_suspended</a></div><div class="doc-content"><p>No documentation found.</p><p><code>GridLayoutBase.with_updates_suspended</code> is a <code>Function</code>.</p><pre><code># 1 method for generic function "with_updates_suspended":
[1] with_updates_suspended(f::Function, gl::GridLayoutBase.GridLayout; update) in GridLayoutBase at /home/runner/.julia/packages/GridLayoutBase/nYdeK/src/gridlayout.jl:121</code></pre></div></div><div class="docstring"><div class="doc-header" id="xlabel!"><a href="#xlabel!">xlabel!</a></div><div class="doc-content"><pre><code>xlabel!([scene,] xlabel)</code></pre><p>Set the x-axis label for the given Scene. Defaults to using the current Scene.</p></div></div><div class="docstring"><div class="doc-header" id="xlims!"><a href="#xlims!">xlims!</a></div><div class="doc-content"><pre><code>xlims!(limits::Real...)
xlims!(limits::NTuple{2, Real})
xlims!(scene, limits::Real...)
xlims!(scene, limits::NTuple{2, Real})</code></pre><p>Set the x-limits for the given Scene (defaults to current Scene).</p></div></div><div class="docstring"><div class="doc-header" id="xticklabels"><a href="#xticklabels">xticklabels</a></div><div class="doc-content"><pre><code>xticklabels(scene)</code></pre><p>Returns the all the x-axis tick labels. See also <code>ticklabels</code>.</p></div></div><div class="docstring"><div class="doc-header" id="xtickrange"><a href="#xtickrange">xtickrange</a></div><div class="doc-content"><pre><code>xtickrange(scene)</code></pre><p>Returns the tick range along the x-axis. See also <code>tickranges</code>.</p></div></div><div class="docstring"><div class="doc-header" id="xtickrotation"><a href="#xtickrotation">xtickrotation</a></div><div class="doc-content"><pre><code>xtickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the x-axis. See also <code>tickrotations</code></p></div></div><div class="docstring"><div class="doc-header" id="xtickrotation!"><a href="#xtickrotation!">xtickrotation!</a></div><div class="doc-content"><pre><code>xtickrotation!([scene,] xangle)</code></pre><p>Set the rotation of tick labels along the x-axis. See also <code>tickrotations!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="xticks!"><a href="#xticks!">xticks!</a></div><div class="doc-content"><pre><code>xticks!([scene,]; xtickrange=xtickrange(scene), xticklabels=xticklabel(scene))</code></pre><p>Set the tick labels and range along the x-axes. See also <code>ticks!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ylabel!"><a href="#ylabel!">ylabel!</a></div><div class="doc-content"><pre><code>ylabel!([scene,] ylabel)</code></pre><p>Set the y-axis label for the given Scene. Defaults to using the current Scene.</p></div></div><div class="docstring"><div class="doc-header" id="ylims!"><a href="#ylims!">ylims!</a></div><div class="doc-content"><pre><code>ylims!(limits::Real...)
ylims!(limits::NTuple{2, Real})
ylims!(scene, limits::Real...)
ylims!(scene, limits::NTuple{2, Real})</code></pre><p>Set the y-limits for the given Scene (defaults to current Scene).</p></div></div><div class="docstring"><div class="doc-header" id="yticklabels"><a href="#yticklabels">yticklabels</a></div><div class="doc-content"><pre><code>yticklabels(scene)</code></pre><p>Returns the all the y-axis tick labels. See also <code>ticklabels</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ytickrange"><a href="#ytickrange">ytickrange</a></div><div class="doc-content"><pre><code>ytickrange(scene)</code></pre><p>Returns the tick range along the y-axis. See also <code>tickranges</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ytickrotation"><a href="#ytickrotation">ytickrotation</a></div><div class="doc-content"><pre><code>ytickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the y-axis. See also <code>tickrotations</code></p></div></div><div class="docstring"><div class="doc-header" id="ytickrotation!"><a href="#ytickrotation!">ytickrotation!</a></div><div class="doc-content"><pre><code>ytickrotation!([scene,] yangle)</code></pre><p>Set the rotation of tick labels along the y-axis. See also <code>tickrotations!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="yticks!"><a href="#yticks!">yticks!</a></div><div class="doc-content"><pre><code>yticks!([scene,]; ytickrange=ytickrange(scene), yticklabels=yticklabel(scene))</code></pre><p>Set the tick labels and range along all the y-axis. See also <code>ticks!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="zlabel!"><a href="#zlabel!">zlabel!</a></div><div class="doc-content"><pre><code>zlabel!([scene,] zlabel)</code></pre><p>Set the z-axis label for the given Scene. Defaults to using the current Scene.</p><div class="admonition warning"><p class="admonition-title">Warning</p><p>The Scene must have an Axis3D.  If not, then this function will error.</p></div></div></div><div class="docstring"><div class="doc-header" id="zlims!"><a href="#zlims!">zlims!</a></div><div class="doc-content"><pre><code>zlims!(limits::Real...)
zlims!(limits::NTuple{2, Real})
zlims!(scene, limits::Real...)
zlims!(scene, limits::NTuple{2, Real})</code></pre><p>Set the z-limits for the given Scene (defaults to current Scene).</p></div></div><div class="docstring"><div class="doc-header" id="zoom!"><a href="#zoom!">zoom!</a></div><div class="doc-content"><pre><code>zoom!(scene, zoom_step)</code></pre><p>Zooms the camera in or out based on the multiplier <code>zoom_step</code>. A <code>zoom_step</code>  of 1.0 is neutral, larger zooms out and lower zooms in.</p><p>Note that this method only applies to Camera3D.</p><pre><code>zoom!(scene, point, zoom_step, shift_lookat::Bool)</code></pre><p>Zooms the camera of <code>scene</code> in towards <code>point</code> by a factor of <code>zoom_step</code>. A positive <code>zoom_step</code> zooms in while a negative <code>zoom_step</code> zooms out.</p></div></div><div class="docstring"><div class="doc-header" id="zticklabels"><a href="#zticklabels">zticklabels</a></div><div class="doc-content"><pre><code>zticklabels(scene)</code></pre><p>Returns the all the z-axis tick labels. See also <code>ticklabels</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ztickrange"><a href="#ztickrange">ztickrange</a></div><div class="doc-content"><pre><code>ztickrange(scene)</code></pre><p>Returns the tick range along the z-axis. See also <code>tickranges</code>.</p></div></div><div class="docstring"><div class="doc-header" id="ztickrotation"><a href="#ztickrotation">ztickrotation</a></div><div class="doc-content"><pre><code>ztickrotation(scene)</code></pre><p>Returns the rotation of tick labels along the z-axis. See also <code>tickrotations</code></p></div></div><div class="docstring"><div class="doc-header" id="ztickrotation!"><a href="#ztickrotation!">ztickrotation!</a></div><div class="doc-content"><pre><code>ztickrotation!([scene,] zangle)</code></pre><p>Set the rotation of tick labels along the z-axis. See also <code>tickrotations!</code>.</p></div></div><div class="docstring"><div class="doc-header" id="zticks!"><a href="#zticks!">zticks!</a></div><div class="doc-content"><pre><code>zticks!([scene,]; ztickranges=ztickrange(scene), zticklabels=zticklabel(scene))</code></pre><p>Set the tick labels and range along all z-axis. See also <code>ticks!</code>.</p></div></div><div class="page-foot"><div class="copyright">
    © Makie.jl. Last modified: October 16, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
      <p>These docs were autogenerated using Makie: v0.15.3, GLMakie: v0.4.7, CairoMakie: v0.6.6, WGLMakie: v0.4.7</p></div></div></div></div><div class="page__footer"><footer><div class="page__footer-follow"><ul class="social-icons"><li><a href="https://twitter.com/MakiePlots" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-twitter-square"></i> Twitter</a></li><li><a href="https://github.com/JuliaPlots/Makie.jl" rel="nofollow noopener noreferrer"><i aria-hidden="true" class="fab fa-fw fa-github"></i> GitHub</a></li></ul></div><div class="page__footer-copyright">© Makie.jl. Powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div></footer></div></div><script src="../../libs/navbar.js"></script><script src="../../libs/lunr/lunr.min.js"></script><script src="../../libs/lunr/lunr_index.js"></script><script src="../../libs/lunr/lunrclient.min.js"></script><script crossorigin="anonymous" defer="" integrity="sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH" src="https://use.fontawesome.com/releases/v5.8.2/js/all.js"></script></body></HTML>